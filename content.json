[{"title":"【面经】2018-阿里6面，终拿offer!","date":"2018-05-23T14:50:33.000Z","path":"2018/05/23/【面经】阿里6面，终拿offer!/","text":"从3月开始准备，一直到5月22号，终于拿到阿里的实习offer，这一路，真的是一把辛酸泪！下面细说之！在这一路上，坎坎坷坷，跌跌宕宕，期间，面了阿里，腾讯，百度，今日头条，小米，笔试网易，美团，携程，爱奇艺…. 不得不说，阿里是持续周期最长的，从3.28直到5.10，但所幸，也是第一个录取我的公司，也是我最想要的一个结果，在此，先说一句：感谢阿里！ 其他的比如百度，腾讯等的面经，等我以后有机会整理，这里我先只说下阿里的6面面经，特分享给大家，以期对诸位有所帮助！ 本文章已授权移至：https://xiaozhuanlan.com/front-end-interview?rel=ChungKing欢迎订阅！ 阿里一面阿里二面阿里三面阿里四面阿里五面阿里六面越努力，越幸运！大家一起加油！顺便说下我最喜欢的一首诗：“力学如力耕，勤惰尔自如。但使书种多，会有岁稔时。”共勉！！！ 好了，以上就是我的面经，欢迎大家讨论，有什么不懂得可以问我，但我不保证我会哈（害羞）！","tags":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"前端安全问题","date":"2018-03-31T09:50:33.000Z","path":"2018/03/31/2018-03-31前端安全问题/","text":"xss防范 csrf防范 sql注入防范 劫持与httpsContent-Security-Policy（浏览器自动升级请求）Strict-Transport-Security（配置浏览器和服务器之间安全的通信。它主要是用来防止中间人攻击，因为它强制所有的通信都走TLS）Access-Control-Allow-Origin（这个header是决定哪些网站可以访问资源，通过定义一个通配符来决定是单一的网站还是所有网站可以访问我们的资源）X-Frame-Options（这个header主要用来配置哪些网站可以通过frame来加载资源。它主要是用来防止UI redressing 补偿样式攻击） XSS攻击 攻击过程：主要是通过html标签注入，篡改网页，插入恶意的脚本，前端可能没有经过严格的校验直接就进到数据库，数据库又通过前端程序又回显到浏览器。攻击者可通过这种方式拿到用户的一些信息，例如cookie 获取敏感信息，甚至自己建网站，做一些非法的操作等；或者，拿到数据后以用户的身份进行勒索，发一下不好的信息等。 1234例如一个留言板：如果内容是 hello!&lt;script type=&quot;type/javascript src=&quot;恶意网址&quot;&gt;&lt;/script&gt; 这样会通过前端代码来执行js脚本，如果这个恶意网址通过cookie获得了用户的私密信息，那么用户的信息就被盗了 解决方法先前端要对用户输入的信息进行过滤，可以用正则，通过替换标签的方式进行转码或解码例如&lt;&gt; 空格 &amp; ‘’ “”等替换成html编码 12345678910111213 htmlEncodeByRegExp:function (str)&#123; var s = &quot;&quot;; if(str.length == 0) return &quot;&quot;; s = str.replace(/&amp;/g,&quot;&amp;amp;&quot;); s = s.replace(/&lt;/g,&quot;&amp;lt;&quot;); s = s.replace(/&gt;/g,&quot;&amp;gt;&quot;); s = s.replace(/ /g,&quot;&amp;nbsp;&quot;); s = s.replace(/\\&apos;/g,&quot;&amp;#39;&quot;); s = s.replace(/\\&quot;/g,&quot;&amp;quot;&quot;); return s; &#125;, 其次在java后端还要进行安全防御，具体可以看一下这个http://blog.csdn.net/qq_34120041/article/details/76890092 XSS初体验-存储型XSS DOM XSS 突变XSS 反射型XSS CSRF攻击(cross site request forgery,跨站请求伪造)CSRF,即(Cross-site request forgery), 中文名为跨站请求伪造。是一种挟持用户在当前已登录的Web应用程序上执行非本意的操作的一种攻击方式。CSRF攻击的本质在于利用用户的身份，执行非本意的操作。根据CSRF的全名，可以得出的结论是：CSRF的请求是跨域且伪造的。 csrf攻击形式：攻击者盗用用户的身份信息，并以用户的名义进行发送恶意的请求等，例如发邮件，盗取账号等非法手段123例如：你登录网站，并在本地种下了cookie 如果在没退出该网站的时候 不小心访问了恶意网站，而且这个网站需要你发一些请求等 此时，你是携带cookie进行访问的，那么你的存在cookie里的信息就会被恶意网站捕捉到，那么你的信息就被盗用 攻击防御：1、验证HTTP Referer字段 在HTTP头中有Referer字段，他记录该HTTP请求的来源地址，如果跳转的网站与来源地址相符，那就是合法的，如果不符则可能是csrf攻击，拒绝该请求 2、在请求地址中添加token并验证 这种的话在请求的时候加一个token，值可以是随机产生的一段数字，token是存入数据库之后，后台返给客户端的，如果客户端再次登录的时候，后台发现token没有，或者通过查询数据库不正确，那么就拒绝该请求 如果想防止一个账号避免在不同的机器上登录，那么我们就可以通过token来判断，如果a机器登录后，我们就将用户的token从数据库清除，从新生成，那么另外一台b机器在执行操作的时候，token就失效了，只能重新登录，这样就可以防止两台机器登同一账号具体方案如下： 服务端在收到客户端请求时，生成一个随机数，在渲染页面时将随机数埋入页面(一般埋入form表单中)，）`的形式。每次刷新页面后这个随机数都会改变，并在服务器中存储。 服务端设置Set-Cookie, 把该随机数作为cookie种入用户浏览器。 当用户发送GET或POST请求时带上_csrf_token参数（对于form表单直接提交即可） 后台在接受到请求后解析请求头中的cookie字段，获取_csrf_token的值，然后和用户请求提交的_csrf_token值做比较。如果相等则表示请求来源是合法的。 3、在HTTP头中自定义属性并验证 如果说通过每次请求的时候都得加token那么各个接口都得加很麻烦，那么我们通过http的请求头来设置token例如：12345678910$.ajax(&#123; url: &apos;/v1/api&apos;, dataType: &apos;json&apos;, data: param, type:&apos;post&apos;, headers: &#123;&apos;Accept&apos;:&apos;application/json&apos;,&apos;Authorization&apos;:tokenValue&#125; success:function(res)&#123; console.log(res) &#125;&#125;) 总结：因为CSRF攻击利用的是冲着浏览器分不清发起请求是不是真正的用户本人，所以防范的关键在于在请求中放入黑客所不能伪造的信息。从而防止黑客伪造一个完整的请求欺骗服务器。 unclekeith: 前端安全之CSRF攻击-get csrf,post csrf SQL注入所谓SQL注入，就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令有一个Login画面，在这个Login画面上有两个文本框分别用来输入用户名和密码，当用户点了登录按钮的时候，会对输入的用户名和密码进行验证。验证的SQL语句如下：select * from student where username=’输入的用户名’ and password=’输入的密码’如果能够检索到数据，说明验证通过，否则验证不通过。123456789如果用户在用户名文本框中输入** ‘ or ‘1’ = ‘1’ or ‘1’ = ‘1，**则验证的SQL语句变成：select * from student **where username=” or ‘1’ = ‘1’ or ‘1’ = ‘1’ and password=”**如果用户在密码文本框中输入 1′ or ‘1’ = ‘1，则验证的SQL语句变成：select * from student where username=” and password=’1’ or ‘1’=’1′以上两个**SQL语句的where条件永远是成立的，所以验证永远是有效的。** 攻击防御：1.URL地址防注入：//过滤URL非法SQL字符 12345678//过滤URL非法SQL字符var sUrl=location.search.toLowerCase();var sQuery=sUrl.substring(sUrl.indexOf(&quot;=&quot;)+1);re=/select|update|delete|truncate|join|union|exec|insert|drop|count|&apos;|&quot;|;|&gt;|&lt;|%/i;if(re.test(sQuery))&#123;alert(&quot;请勿输入非法字符&quot;);location.href=sUrl.replace(sQuery,&quot;&quot;); 2.输入文本框防注入：/防止SQL注入 1234567891011121314151617181920function AntiSqlValid(oField )&#123;re= /``select``|``update``|``delete``|``exec``|``count``|&apos;|``&quot;|=|;|&gt;|&lt;|%/i;if ( re.test(oField.value) )&#123;//alert(&quot;``请您不要在参数中输入特殊字符和SQL关键字！``&quot;); //注意中文乱码oField.value = &quot;``;oField.className=``&quot;errInfo&quot;``;oField.focus();return` `false``;&#125; 在需要防注入的输入文本框添加如下方法 txtName.Attributes.``Add``(``&quot;onblur&quot;``, &quot;AntiSqlValid(this)&quot;``);//防止Sql脚本注入请求劫持与HTTPS请求劫持现在主要分为两种，DNS劫持与HTTP劫持： DNS劫持： DNS劫持就是通过劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。DNS劫持通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。 DNS劫持症状：在某些地区的用户在成功连接宽带后，首次打开任何页面都指向ISP提供的“电信互联星空”、“网通黄页广告”等内容页面。还有就是曾经出现过用户访问Google域名的时候出现了百度的网站。这些都属于DNS劫持。 再说简单点，当你输入google.com这个网址的时候，你看到的网站却是百度的首页。 http劫持： 在用户的客户端与其要访问的服务器经过网络协议协调后，二者之间建立了一条专用的数据通道，用户端程序在系统中开放指定网络端口用于接收数据报文，服务器端将全部数据按指定网络协议规则进行分解打包，形成连续数据报文。 用户端接收到全部报文后，按照协议标准来解包组合获得完整的网络数据。其中传输过程中的每一个数据包都有特定的标签，表示其来源、携带的数据属性以及要到何处，所有的数据包经过网络路径中ISP的路由器传输接力后，最终到达目的地，也就是客户端。 HTTP劫持是在使用者与其目的网络服务所建立的专用数据通道中，监视特定数据信息，提示当满足设定的条件时，就会在正常的数据流中插入精心设计的网络数据报文，目的是让用户端程序解释“错误”的数据，并以弹出新窗口的形式在使用者界面展示宣传性广告或者直接显示某网站的内容。列入本地的fiddler为一种劫持 请求劫持唯一可行的预防方法就是尽量使用HTTPS协议访问。HTTPS协议：https://juejin.im/entry/58d7635e5c497d0057fae036 公钥和私钥什么是https，这里不再解释了，简单理解就是通过SSL（Secure Sockets Layer）层来加密http数据来进行安全传输。 那使用HTTPS是怎样进行加解密和安全数据传输的？ 先看个有意思的问题： A、B两个人分别在两个岛上，并且分别有一个箱子，一把锁，和打开这把锁的钥匙（A的钥匙打不开B手上的锁，B的钥匙也打不开A的锁）。此时A要跟B互通情报，此时需要借助C的船运输，C是一个不可靠的人，如果A直接把情报送给B或把情报放在箱子里给B，都可能会被C偷走；如果A把情报锁在箱子里，B没有打开A锁的钥匙无法获得情报内容。请问有什么办法可以尽可能快的让A和B互通情报。 这就是公钥和私钥的问题了，答案比较简单，也对应了公钥和私钥在https中的应用过程。 公钥（Public Key）与私钥（Private Key）是通过一种算法得到的一个密钥对（即一个公钥和一个私钥），公钥是密钥对中公开的部分，私钥则是非公开的部分。公钥通常用于加密会话密钥、验证数字签名，或加密可以用相应的私钥解密的数据。通过这种算法得到的密钥对能保证在世界范围内是唯一的。使用这个密钥对的时候，如果用其中一个密钥加密一段数据，必须用另一个密钥解密。比如用公钥加密数据就必须用私钥解密，如果用私钥加密也必须用公钥解密，否则解密将不会成功。—百度百科 Https的通信过程整个通信过程如下图，以公钥加密方式为例：1、客户端发送https请求，告诉服务器发将建立https连接2、服务器将服务端生成的公钥返回给客户端，如果是第一次请求将告诉客户端需要验证链接3、客户端接收到请求后’client finished’报文串通过获取到的服务器公钥加密发送给服务器，并将客户端生成的公钥也发送给服务器4、服务器获取到加密的报文和客户端公钥，先使用服务器私钥解密报文，然后将报文通过客户端的公钥加密返回给客户端。5、客户端通过私钥解密报文，判断是否为自己开始发送的报文串；如果正确，说明安全连接验证成功，将数据通过服务器公钥加密不断发送给服务器，服务器也不断解密获取报文，并通过客户端公钥加密返回给客户端验证。这样就建立了不断通信的连接。 Https协议头解析以打开 https://github.com/ 的过程为例，请求通用头部如下 Request URL:https://github.com/ouvens\\n Request Method:GET Status Code:200 OK (from cache) Remote Address:192.30.252.131:443 Response Headers先看下请求头的字段 再截取部分返回头的字段 需要注意的upgrade-insecure-requests https正常升级后chrome浏览器会出现下面的警告 考虑到这个问题，w3c在2015年4月份出了一个 Upgrade Insecure Requests 的草案，他的作用就是让浏览器自动升级请求。在服务器的响应头中加入： header(“Content-Security-Policy: upgrade-insecure-requests”); ###浏览器中web安全控制http层面上浏览器设置的安全性控制较多，这里列几个典型的来看看： X-XSS-Protection这个header主要是用来防止浏览器中的反射性xss。现在，只有IE，chrome和safari（webkit）支持这个header。正确的设置:X-XSS-Protection:1; mode=block 0 – 关闭对浏览器的xss防护 1 – 开启xss防护 1; mode=block – 开启xss防护并通知浏览器阻止而不是过滤用户注入的脚本。 1; report=http://site.com/report – 这个只有chrome和webkit内核的浏览器支持，这种模式告诉浏览器当发现疑似xss攻击的时候就将这部分数据post到指定地址。 通常不正确的设置 2.X-Content-Type-Options&ems; 这个header主要用来防止在IE9、chrome和safari中的MIME类型混淆攻击。firefox目前对此还存在争议。通常浏览器可以通过嗅探内容本身的方法来决定它是什么类型，而不是看响应中的content-type值。通过设置 X-Content-Type-Options：如果content-type和期望的类型匹配，则不需要嗅探，只能从外部加载确定类型的资源。举个例子，如果加载了一个样式表，那么资源的MIME类型只能是text/css，对于IE中的脚本资源，以下的内容类型是有效的：application/ecmascript application/javascript application/x-javascript text/ecmascript text/javascript text/jscript text/x-javascript text/vbs text/vbscript对于chrome，则支持下面的MIME 类型：text/javascript text/ecmascript application/javascript application/ecmascript application/x-javascript text/javascript1.1 text/javascript1.2 text/javascript1.3 text/jscript text/live scriptnosniff – 这个是唯一正确的设置，必须这样。 Strict-Transport-SecurityStrict Transport Security (STS) 是用来配置浏览器和服务器之间安全的通信。它主要是用来防止中间人攻击，因为它强制所有的通信都走TLS。目前IE还不支持 STS头。需要注意的是，在普通的http请求中配置STS是没有作用的，因为攻击者很容易就能更改这些值。为了防止这样的现象发生，很多浏览器内置了一个配置了STS的站点list。正确的设置 : 注意下面的值必须在https中才有效，如果是在http中配置会没有效果。max-age=31536000 – 告诉浏览器将域名缓存到STS list里面，时间是一年。 max-age=31536000; includeSubDomains – 告诉浏览器将域名缓存到STS list里面并且包含所有的子域名，时间是一年。 max-age=0 – 告诉浏览器移除在STS缓存里的域名，或者不保存此域名。 通常不正确的设置判断一个主机是否在你的STS缓存中，chrome可以通过访问chrome://net-internals/#hsts，首先，通过域名请求选项来确认此域名是否在你的STS缓存中。然后，通过https访问这个网站，尝试再次请求返回的STS头，来决定是否添加正确。 4.Content-Security-PolicyCSP是一种由开发者定义的安全性政策性申明，通过CSP所约束的的规责指定可信的内容来源（这里的内容可以指脚本、图片、iframe、fton、style等等可能的远程的资源）。通过CSP协定，让WEB能够加载指定安全域名下的资源文件，保证运行时处于一个安全的运行环境中。正确配置：Content-Security-Policy:default-src *; base-uri &#39;self&#39;; block-all-mixed-content; child-src &#39;self&#39; render.githubusercontent.com; connect-src &#39;self&#39; uploads.github.com status.github.com api.github.com www.google-analytics.com github-cloud.s3.amazonaws.com wss://live.github.com; font-src assets-cdn.github.com; form-action &#39;self&#39; github.com gist.github.com; frame-src &#39;self&#39; render.githubusercontent.com; img-src &#39;self&#39; data: assets-cdn.github.com identicons.github.com www.google-analytics.com collector.githubapp.com *.gravatar.com *.wp.com *.githubusercontent.com; media-src &#39;none&#39;; object-src assets-cdn.github.com; plugin-types application/x-shockwave-flash; script-src assets-cdn.github.com; style-src &#39;self&#39; &#39;unsafe-inline&#39; assets-cdn.github.com 5.X-Frame-Options这个header主要用来配置哪些网站可以通过frame来加载资源。它主要是用来防止UI redressing 补偿样式攻击。IE8和firefox 18以后的版本都开始支持ALLOW-FROM。chrome和safari都不支持ALLOW-FROM，但是WebKit已经在研究这个了。正确的设置X-Frame-Options: deny deny – 禁止所有的资源（本地或远程）试图通过frame来加载其他也支持X-Frame-Options 的资源。 sameorigion – 只允许遵守同源策略的资源（和站点同源）通过frame加载那些受保护的资源。 allow-from http://www.example.com – 允许指定的资源（必须带上协议http或者https）通过frame来加载受保护的资源。这个配置只在IE和firefox下面有效。其他浏览器则默认允许任何源的资源（在X-Frame-Options没设置的情况下）。 6.Access-Control-Allow-OriginAccess-Control-Allow-Origin是从Cross Origin Resource Sharing (CORS)中分离出来的。这个header是决定哪些网站可以访问资源，通过定义一个通配符来决定是单一的网站还是所有网站可以访问我们的资源。需要注意的是，如果定义了通配符，那么 Access-Control-Allow-Credentials选项就无效了，而且user-agent的cookies不会在请求里发送。正确的设置Access-Control-Allow-Origin : * *– 通配符允许任何远程资源来访问含有Access-Control-Allow-Origin 的内容。 http://www.example.com – 只允许特定站点才能访问(http://[host], 或者 https://[host]) 7.Public-Key-Pins 公钥固定（Public Key Pinning）是指一个证书链中必须包含一个白名单中的公钥，也就是说只有被列入白名单的证书签发机构（CA）才能为某个域名*.example.com签发证书，而不是你的浏览器中所存储的任何 CA 都可以为之签发。可以理解为https的证书域名白名单。 Public-Key-Pins (PKP)的目的主要是允许网站经营者提供一个哈希过的公共密钥存储在用户的浏览器缓存里。跟Strict-Transport-Security功能相似的是，它能保护用户免遭中间人攻击。这个header可能包含多层的哈希运算，比如pin-sha256=base64(sha256(SPKI))，具体是先将 X.509 证书下的Subject Public Key Info (SPKI) 做sha256哈希运算，然后再做base64编码。然而，这些规定有可能更改，例如有人指出，在引号中封装哈希是无效的，而且在33版本的chrome中也不会保存pkp的哈希到缓存中。 这个header和 STS的作用很像，因为它规定了最大子域名的数量。此外，pkp还提供了一个Public-Key-Pins-Report-Only 头用来报告异常，但是不会强制阻塞证书信息。当然，这些chrome都是不支持的。 请求头说明参考： https://www.veracode.com/blog/2014/03/guidelines-for-setting-security-headers/ 总结总结下web的安全策略，主要介绍了xss防范csrf防范sql注入防范劫持与httpsContent-Security-Policy（浏览器自动升级请求）Strict-Transport-Security（配置浏览器和服务器之间安全的通信。它主要是用来防止中间人攻击，因为它强制所有的通信都走TLS）Access-Control-Allow-Origin（这个header是决定哪些网站可以访问资源，通过定义一个通配符来决定是单一的网站还是所有网站可以访问我们的资源）X-Frame-Options（这个header主要用来配置哪些网站可以通过frame来加载资源。它主要是用来防止UI redressing 补偿样式攻击）","tags":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"},{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/安全/"}]},{"title":"关于eslint使用规则，和各种报错对应规则","date":"2018-01-22T09:50:33.000Z","path":"2018/01/22/关于eslint使用规则，和各种报错对应规则/","text":"在用vue2.0写项目时，由于vue-cli脚 架自动带了带了代码规范监测，稍微不小心就会出现一些Warning,这时就需要，根据自己习惯的代码规范，用一下代码进行对Eslint规范的一些忽略。下面详细介绍一下：ESLint 由 JavaScript 红宝书 作者 Nicholas C. Zakas 编写， 2013 年发布第一个版本。 NCZ 的初衷不是重复造一个轮子，而是在实际需求得不到 JSHint 团队响应 的情况下做出的选择：以可扩展、每条规则独立、不内置编码风格为理念编写一个 lint 工具。ESLint 主要有以下特点： 默认规则包含所有 JSLint、JSHint 中存在的规则，易迁移； 规则可配置性高：可设置「警告」、「错误」两个 error 等级，或者直接禁用； 包含代码风格检测的规则（可以丢掉 JSCS 了）； 支持插件扩展、自定义规则。 下面说一下如何配置：比如，我写vue过程中，出现了下面的warning:12WARNING Compiled with 1 warnings11:26:30http://eslint.org/docs/rules/quotes Strings must use singlequote 警告的意思就是字符串必须用单引号如下图：这时候，你就可以在.eslintrc.js配置你的规则rule&quot;quotes&quot;: [1, &quot;single&quot;],//引号类型 `` &quot;&quot; &#39;&#39; Use / eslint-disable / to ignore all warnings in a file.还有一种万能方法，就是在报错的JS文件中第一行写上/* eslint-disable */ 如下图这样就可以和Eslint携手并进了 配置（我主要用第三种方法,为了方便查看，特记录如下：）可以通过以下三种方式配置 ESLint: 使用 .eslintrc 文件（支持 JSON 和 YAML 两种语法）； 在 package.json 中添加 eslintConfig 配置块；直接在代码文件中定义。 以下是.eslintrc 文件示例和解释：为了方便查看，特记录如下,需要用的规则，到时候直接搜索就可以了，简直开心极了：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298&#123; &quot;env&quot;: &#123; &quot;browser&quot;: true, &quot;node&quot;: true, &quot;commonjs&quot;: true &#125;, &quot;ecmaFeatures&quot;: &#123; // lambda表达式 &quot;arrowFunctions&quot;: true, // 解构赋值 &quot;destructuring&quot;: true, // class &quot;classes&quot;: true, // http://es6.ruanyifeng.com/#docs/function#函数参数的默认值 &quot;defaultParams&quot;: true, // 块级作用域，允许使用let const &quot;blockBindings&quot;: true, // 允许使用模块，模块内默认严格模式 &quot;modules&quot;: true, // 允许字面量定义对象时，用表达式做属性名 // http://es6.ruanyifeng.com/#docs/object#属性名表达式 &quot;objectLiteralComputedProperties&quot;: true, // 允许对象字面量方法名简写 /*var o = &#123; method() &#123; return &quot;Hello!&quot;; &#125; &#125;; 等同于 var o = &#123; method: function() &#123; return &quot;Hello!&quot;; &#125; &#125;; */ &quot;objectLiteralShorthandMethods&quot;: true, /* 对象字面量属性名简写 var foo = &apos;bar&apos;; var baz = &#123;foo&#125;; baz // &#123;foo: &quot;bar&quot;&#125; // 等同于 var baz = &#123;foo: foo&#125;; */ &quot;objectLiteralShorthandProperties&quot;: true, // http://es6.ruanyifeng.com/#docs/function#rest参数 &quot;restParams&quot;: true, // http://es6.ruanyifeng.com/#docs/function#扩展运算符 &quot;spread&quot;: true, // http://es6.ruanyifeng.com/#docs/iterator#for---of循环 &quot;forOf&quot;: true, // http://es6.ruanyifeng.com/#docs/generator &quot;generators&quot;: true, // http://es6.ruanyifeng.com/#docs/string#模板字符串 &quot;templateStrings&quot;: true, &quot;superInFunctions&quot;: true, // http://es6.ruanyifeng.com/#docs/object#对象的扩展运算符 &quot;experimentalObjectRestSpread&quot;: true &#125;, &quot;rules&quot;: &#123; // 定义对象的set存取器属性时，强制定义get &quot;accessor-pairs&quot;: 2, // 指定数组的元素之间要以空格隔开(,后面)， never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格 &quot;array-bracket-spacing&quot;: [2, &quot;never&quot;], // 在块级作用域外访问块内定义的变量是否报错提示 &quot;block-scoped-var&quot;: 0, // if while function 后面的&#123;必须与if在同一行，java风格。 &quot;brace-style&quot;: [2, &quot;1tbs&quot;, &#123; &quot;allowSingleLine&quot;: true &#125;], // 双峰驼命名格式 &quot;camelcase&quot;: 2, // 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗号， // always-multiline：多行模式必须带逗号，单行模式不能带逗号 &quot;comma-dangle&quot;: [2, &quot;never&quot;], // 控制逗号前后的空格 &quot;comma-spacing&quot;: [2, &#123; &quot;before&quot;: false, &quot;after&quot;: true &#125;], // 控制逗号在行尾出现还是在行首出现 // http://eslint.org/docs/rules/comma-style &quot;comma-style&quot;: [2, &quot;last&quot;], // 圈复杂度 &quot;complexity&quot;: [2,9], // 以方括号取对象属性时，[ 后面和 ] 前面是否需要空格, 可选参数 never, always &quot;computed-property-spacing&quot;: [2,&quot;never&quot;], // 强制方法必须返回值，TypeScript强类型，不配置 &quot;consistent-return&quot;: 0, // 用于指统一在回调函数中指向this的变量名，箭头函数中的this已经可以指向外层调用者，应该没卵用了 // e.g [0,&quot;that&quot;] 指定只能 var that = this. that不能指向其他任何值，this也不能赋值给that以外的其他值 &quot;consistent-this&quot;: 0, // 强制在子类构造函数中用super()调用父类构造函数，TypeScrip的编译器也会提示 &quot;constructor-super&quot;: 0, // if else while for do后面的代码块是否需要&#123; &#125;包围，参数： // multi 只有块中有多行语句时才需要&#123; &#125;包围 // multi-line 只有块中有多行语句时才需要&#123; &#125;包围, 但是块中的执行语句只有一行时， // 块中的语句只能跟和if语句在同一行。if (foo) foo++; else doSomething(); // multi-or-nest 只有块中有多行语句时才需要&#123; &#125;包围, 如果块中的执行语句只有一行，执行语句可以零另起一行也可以跟在if语句后面 // [2, &quot;multi&quot;, &quot;consistent&quot;] 保持前后语句的&#123; &#125;一致 // default: [2, &quot;all&quot;] 全都需要&#123; &#125;包围 &quot;curly&quot;: [2, &quot;all&quot;], // switch语句强制default分支，也可添加 // no default 注释取消此次警告 &quot;default-case&quot;: 2, // 强制object.key 中 . 的位置，参数: // property，&apos;.&apos;号应与属性在同一行 // object, &apos;.&apos; 号应与对象名在同一行 &quot;dot-location&quot;: [2, &quot;property&quot;], // 强制使用.号取属性 // 参数： allowKeywords：true 使用保留字做属性名时，只能使用.方式取属性 // false 使用保留字做属性名时, 只能使用[]方式取属性 e.g [2, &#123;&quot;allowKeywords&quot;: false&#125;] // allowPattern: 当属性名匹配提供的正则表达式时，允许使用[]方式取值,否则只能用.号取值 e.g [2, &#123;&quot;allowPattern&quot;: &quot;^[a-z]+(_[a-z]+)+$&quot;&#125;] &quot;dot-notation&quot;: [2, &#123;&quot;allowKeywords&quot;: true&#125;], // 文件末尾强制换行 &quot;eol-last&quot;: 2, // 使用 === 替代 == &quot;eqeqeq&quot;: [2, &quot;allow-null&quot;], // 方法表达式是否需要命名 &quot;func-names&quot;: 0, // 方法定义风格，参数： // declaration: 强制使用方法声明的方式，function f()&#123;&#125; e.g [2, &quot;declaration&quot;] // expression：强制使用方法表达式的方式，var f = function() &#123;&#125; e.g [2, &quot;expression&quot;] // allowArrowFunctions: declaration风格中允许箭头函数。 e.g [2, &quot;declaration&quot;, &#123; &quot;allowArrowFunctions&quot;: true &#125;] &quot;func-style&quot;: 0, &quot;no-alert&quot;: 0,//禁止使用alert confirm prompt&quot;no-array-constructor&quot;: 2,//禁止使用数组构造器&quot;no-bitwise&quot;: 0,//禁止使用按位运算符&quot;no-caller&quot;: 1,//禁止使用arguments.caller或arguments.callee&quot;no-catch-shadow&quot;: 2,//禁止catch子句参数与外部作用域变量同名&quot;no-class-assign&quot;: 2,//禁止给类赋值&quot;no-cond-assign&quot;: 2,//禁止在条件表达式中使用赋值语句&quot;no-console&quot;: 2,//禁止使用console&quot;no-const-assign&quot;: 2,//禁止修改const声明的变量&quot;no-constant-condition&quot;: 2,//禁止在条件中使用常量表达式 if(true) if(1)&quot;no-continue&quot;: 0,//禁止使用continue&quot;no-control-regex&quot;: 2,//禁止在正则表达式中使用控制字符&quot;no-debugger&quot;: 2,//禁止使用debugger&quot;no-delete-var&quot;: 2,//不能对var声明的变量使用delete操作符&quot;no-div-regex&quot;: 1,//不能使用看起来像除法的正则表达式/=foo/&quot;no-dupe-keys&quot;: 2,//在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125;&quot;no-dupe-args&quot;: 2,//函数参数不能重复&quot;no-duplicate-case&quot;: 2,//switch中的case标签不能重复&quot;no-else-return&quot;: 2,//如果if语句里面有return,后面不能跟else语句&quot;no-empty&quot;: 2,//块语句中的内容不能为空&quot;no-empty-character-class&quot;: 2,//正则表达式中的[]内容不能为空&quot;no-empty-label&quot;: 2,//禁止使用空label&quot;no-eq-null&quot;: 2,//禁止对null使用==或!=运算符&quot;no-eval&quot;: 1,//禁止使用eval&quot;no-ex-assign&quot;: 2,//禁止给catch语句中的异常参数赋值&quot;no-extend-native&quot;: 2,//禁止扩展native对象&quot;no-extra-bind&quot;: 2,//禁止不必要的函数绑定&quot;no-extra-boolean-cast&quot;: 2,//禁止不必要的bool转换&quot;no-extra-parens&quot;: 2,//禁止非必要的括号&quot;no-extra-semi&quot;: 2,//禁止多余的冒号&quot;no-fallthrough&quot;: 1,//禁止switch穿透&quot;no-floating-decimal&quot;: 2,//禁止省略浮点数中的0 .5 3.&quot;no-func-assign&quot;: 2,//禁止重复的函数声明&quot;no-implicit-coercion&quot;: 1,//禁止隐式转换&quot;no-implied-eval&quot;: 2,//禁止使用隐式eval&quot;no-inline-comments&quot;: 0,//禁止行内备注&quot;no-inner-declarations&quot;: [2, &quot;functions&quot;],//禁止在块语句中使用声明（变量或函数）&quot;no-invalid-regexp&quot;: 2,//禁止无效的正则表达式&quot;no-invalid-this&quot;: 2,//禁止无效的this，只能用在构造器，类，对象字面量&quot;no-irregular-whitespace&quot;: 2,//不能有不规则的空格&quot;no-iterator&quot;: 2,//禁止使用__iterator__ 属性&quot;no-label-var&quot;: 2,//label名不能与var声明的变量名相同&quot;no-labels&quot;: 2,//禁止标签声明&quot;no-lone-blocks&quot;: 2,//禁止不必要的嵌套块&quot;no-lonely-if&quot;: 2,//禁止else语句内只有if语句&quot;no-loop-func&quot;: 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）&quot;no-mixed-requires&quot;: [0, false],//声明时不能混用声明类型&quot;no-mixed-spaces-and-tabs&quot;: [2, false],//禁止混用tab和空格&quot;linebreak-style&quot;: [0, &quot;windows&quot;],//换行风格&quot;no-multi-spaces&quot;: 1,//不能用多余的空格&quot;no-multi-str&quot;: 2,//字符串不能用\\换行&quot;no-multiple-empty-lines&quot;: [1, &#123;&quot;max&quot;: 2&#125;],//空行最多不能超过2行&quot;no-native-reassign&quot;: 2,//不能重写native对象&quot;no-negated-in-lhs&quot;: 2,//in 操作符的左边不能有!&quot;no-nested-ternary&quot;: 0,//禁止使用嵌套的三目运算&quot;no-new&quot;: 1,//禁止在使用new构造一个实例后不赋值&quot;no-new-func&quot;: 1,//禁止使用new Function&quot;no-new-object&quot;: 2,//禁止使用new Object()&quot;no-new-require&quot;: 2,//禁止使用new require&quot;no-new-wrappers&quot;: 2,//禁止使用new创建包装实例，new String new Boolean new Number&quot;no-obj-calls&quot;: 2,//不能调用内置的全局对象，比如Math() JSON()&quot;no-octal&quot;: 2,//禁止使用八进制数字&quot;no-octal-escape&quot;: 2,//禁止使用八进制转义序列&quot;no-param-reassign&quot;: 2,//禁止给参数重新赋值&quot;no-path-concat&quot;: 0,//node中不能使用__dirname或__filename做路径拼接&quot;no-plusplus&quot;: 0,//禁止使用++，--&quot;no-process-env&quot;: 0,//禁止使用process.env&quot;no-process-exit&quot;: 0,//禁止使用process.exit()&quot;no-proto&quot;: 2,//禁止使用__proto__属性&quot;no-redeclare&quot;: 2,//禁止重复声明变量&quot;no-regex-spaces&quot;: 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/&quot;no-restricted-modules&quot;: 0,//如果禁用了指定模块，使用就会报错&quot;no-return-assign&quot;: 1,//return 语句中不能有赋值表达式&quot;no-script-url&quot;: 0,//禁止使用javascript:void(0)&quot;no-self-compare&quot;: 2,//不能比较自身&quot;no-sequences&quot;: 0,//禁止使用逗号运算符&quot;no-shadow&quot;: 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名&quot;no-shadow-restricted-names&quot;: 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用&quot;no-spaced-func&quot;: 2,//函数调用时 函数名与()之间不能有空格&quot;no-sparse-arrays&quot;: 2,//禁止稀疏数组， [1,,2]&quot;no-sync&quot;: 0,//nodejs 禁止同步方法&quot;no-ternary&quot;: 0,//禁止使用三目运算符&quot;no-trailing-spaces&quot;: 1,//一行结束后面不要有空格&quot;no-this-before-super&quot;: 0,//在调用super()之前不能使用this或super&quot;no-throw-literal&quot;: 2,//禁止抛出字面量错误 throw &quot;error&quot;;&quot;no-undef&quot;: 1,//不能有未定义的变量&quot;no-undef-init&quot;: 2,//变量初始化时不能直接给它赋值为undefined&quot;no-undefined&quot;: 2,//不能使用undefined&quot;no-unexpected-multiline&quot;: 2,//避免多行表达式&quot;no-underscore-dangle&quot;: 1,//标识符不能以_开头或结尾&quot;no-unneeded-ternary&quot;: 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;&quot;no-unreachable&quot;: 2,//不能有无法执行的代码&quot;no-unused-expressions&quot;: 2,//禁止无用的表达式&quot;no-unused-vars&quot;: [2, &#123;&quot;vars&quot;: &quot;all&quot;, &quot;args&quot;: &quot;after-used&quot;&#125;],//不能有声明后未被使用的变量或参数&quot;no-use-before-define&quot;: 2,//未定义前不能使用&quot;no-useless-call&quot;: 2,//禁止不必要的call和apply&quot;no-void&quot;: 2,//禁用void操作符&quot;no-var&quot;: 0,//禁用var，用let和const代替&quot;no-warning-comments&quot;: [1, &#123; &quot;terms&quot;: [&quot;todo&quot;, &quot;fixme&quot;, &quot;xxx&quot;], &quot;location&quot;: &quot;start&quot; &#125;],//不能有警告备注&quot;no-with&quot;: 2,//禁用with&quot;array-bracket-spacing&quot;: [2, &quot;never&quot;],//是否允许非空数组里面有多余的空格&quot;arrow-parens&quot;: 0,//箭头函数用小括号括起来&quot;arrow-spacing&quot;: 0,//=&gt;的前/后括号&quot;accessor-pairs&quot;: 0,//在对象中使用getter/setter&quot;block-scoped-var&quot;: 0,//块语句中使用var&quot;brace-style&quot;: [1, &quot;1tbs&quot;],//大括号风格&quot;callback-return&quot;: 1,//避免多次调用回调什么的&quot;camelcase&quot;: 2,//强制驼峰法命名&quot;comma-dangle&quot;: [2, &quot;never&quot;],//对象字面量项尾不能有逗号&quot;comma-spacing&quot;: 0,//逗号前后的空格&quot;comma-style&quot;: [2, &quot;last&quot;],//逗号风格，换行时在行首还是行尾&quot;complexity&quot;: [0, 11],//循环复杂度&quot;computed-property-spacing&quot;: [0, &quot;never&quot;],//是否允许计算后的键名什么的&quot;consistent-return&quot;: 0,//return 后面是否允许省略&quot;consistent-this&quot;: [2, &quot;that&quot;],//this别名&quot;constructor-super&quot;: 0,//非派生类不能调用super，派生类必须调用super&quot;curly&quot;: [2, &quot;all&quot;],//必须使用 if()&#123;&#125; 中的&#123;&#125;&quot;default-case&quot;: 2,//switch语句最后必须有default&quot;dot-location&quot;: 0,//对象访问符的位置，换行的时候在行首还是行尾&quot;dot-notation&quot;: [0, &#123; &quot;allowKeywords&quot;: true &#125;],//避免不必要的方括号&quot;eol-last&quot;: 0,//文件以单一的换行符结束&quot;eqeqeq&quot;: 2,//必须使用全等&quot;func-names&quot;: 0,//函数表达式必须有名字&quot;func-style&quot;: [0, &quot;declaration&quot;],//函数风格，规定只能使用函数声明/函数表达式&quot;generator-star-spacing&quot;: 0,//生成器函数*的前后空格&quot;guard-for-in&quot;: 0,//for in循环要用if语句过滤&quot;handle-callback-err&quot;: 0,//nodejs 处理错误&quot;id-length&quot;: 0,//变量名长度&quot;indent&quot;: [2, 4],//缩进风格&quot;init-declarations&quot;: 0,//声明时必须赋初值&quot;key-spacing&quot;: [0, &#123; &quot;beforeColon&quot;: false, &quot;afterColon&quot;: true &#125;],//对象字面量中冒号的前后空格&quot;lines-around-comment&quot;: 0,//行前/行后备注&quot;max-depth&quot;: [0, 4],//嵌套块深度&quot;max-len&quot;: [0, 80, 4],//字符串最大长度&quot;max-nested-callbacks&quot;: [0, 2],//回调嵌套深度&quot;max-params&quot;: [0, 3],//函数最多只能有3个参数&quot;max-statements&quot;: [0, 10],//函数内最多有几个声明&quot;new-cap&quot;: 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用&quot;new-parens&quot;: 2,//new时必须加小括号&quot;newline-after-var&quot;: 2,//变量声明后是否需要空一行&quot;object-curly-spacing&quot;: [0, &quot;never&quot;],//大括号内是否允许不必要的空格&quot;object-shorthand&quot;: 0,//强制对象字面量缩写语法&quot;one-var&quot;: 1,//连续声明&quot;operator-assignment&quot;: [0, &quot;always&quot;],//赋值运算符 += -=什么的&quot;operator-linebreak&quot;: [2, &quot;after&quot;],//换行时运算符在行尾还是行首&quot;padded-blocks&quot;: 0,//块语句内行首行尾是否要空行&quot;prefer-const&quot;: 0,//首选const&quot;prefer-spread&quot;: 0,//首选展开运算&quot;prefer-reflect&quot;: 0,//首选Reflect的方法&quot;quotes&quot;: [1, &quot;single&quot;],//引号类型 `` &quot;&quot; &apos;&apos;&quot;quote-props&quot;:[2, &quot;always&quot;],//对象字面量中的属性名是否强制双引号&quot;radix&quot;: 2,//parseInt必须指定第二个参数&quot;id-match&quot;: 0,//命名检测&quot;require-yield&quot;: 0,//生成器函数必须有yield&quot;semi&quot;: [2, &quot;always&quot;],//语句强制分号结尾&quot;semi-spacing&quot;: [0, &#123;&quot;before&quot;: false, &quot;after&quot;: true&#125;],//分号前后空格&quot;sort-vars&quot;: 0,//变量声明时排序&quot;space-after-keywords&quot;: [0, &quot;always&quot;],//关键字后面是否要空一格&quot;space-before-blocks&quot;: [0, &quot;always&quot;],//不以新行开始的块&#123;前面要不要有空格&quot;space-before-function-paren&quot;: [0, &quot;always&quot;],//函数定义时括号前面要不要有空格&quot;space-in-parens&quot;: [0, &quot;never&quot;],//小括号里面要不要有空格&quot;space-infix-ops&quot;: 0,//中缀操作符周围要不要有空格&quot;space-return-throw-case&quot;: 2,//return throw case后面要不要加空格&quot;space-unary-ops&quot;: [0, &#123; &quot;words&quot;: true, &quot;nonwords&quot;: false &#125;],//一元运算符的前/后要不要加空格&quot;spaced-comment&quot;: 0,//注释风格不要有空格什么的&quot;strict&quot;: 2,//使用严格模式&quot;use-isnan&quot;: 2,//禁止比较时使用NaN，只能用isNaN()&quot;valid-jsdoc&quot;: 0,//jsdoc规则&quot;valid-typeof&quot;: 2,//必须使用合法的typeof的值&quot;vars-on-top&quot;: 2,//var必须放在作用域顶部&quot;wrap-iife&quot;: [2, &quot;inside&quot;],//立即执行函数表达式的小括号风格&quot;wrap-regex&quot;: 0,//正则表达式字面量用小括号包起来&quot;yoda&quot;: [2, &quot;never&quot;]//禁止尤达条件 &#125; &#125; 参考文章：ESLint配置参数介绍关于eslint使用规则，和各种报错应对书写规则。*","tags":[{"name":"技术杂谈","slug":"技术杂谈","permalink":"http://yoursite.com/tags/技术杂谈/"},{"name":"eslint","slug":"eslint","permalink":"http://yoursite.com/tags/eslint/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"Git 多分支管理亲手操作一波","date":"2018-01-21T09:50:33.000Z","path":"2018/01/21/Git-多分支管理亲手操作一波/","text":"文 | 阿小庆 2018-01-21❤ 快过年了，是时候对以前的知识总结一波了！ 先问大家一个问题：问：如果一个人想针对项目不同阶段都有个备份，在一台电脑上多分支管理一个项目，应该怎么搞呢？答：我给你用电脑操作一下吧，哈哈，下面带大家实际操作一波。 首先我建立一个仓库，clone到本地，建立了README.md 主分支master.txt 新建branch1分支，并切换到branch1分支（git branch 可以查看所有分支）git branch 分支名git checkout 想要切换的分支名 新建次分支branch1.txt并提交在此分支下提交可能会报错，报错后再执行下一句就可以git push -u origin dev表示本地分支将建立对远程仓库目标分支的检测，如果远程仓库目标分支不存在，将新建分支再push；如果存在，将进行push更新。具体解决方法见下link: git：fatal the current branch master has no upstream branch 提交成功后 ，在github上查看，就能看到新建的branch1分支提交了次分支branch1.txt 而主分支master内容没变 好，这样就大功告成了，如果自己一个人开发，为了不容易乱，我是把不同的分支放在不同的文件夹下，如下图，当然，你也可以用你自己的方法我把代码放在Github上了，供大家参考https://github.com/HuangCongQing/branch 好看的人儿，点个喜欢❤ 你会更好看哦~~","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"计算机网络考试 复习时你应该要看的几道题！","date":"2018-01-13T09:50:33.000Z","path":"2018/01/13/计算机网络考试-复习时你应该要看的几道题！/","text":"计算机网络考试 复习时你应该要看的几道题！文 | 阿小庆 | 2018-01-03 在学校马上就要考《计算机网络》这门课了，复习的过程中，发现有些题目很经典，特地整理总结了一下，我只挑了有用的以期回顾，若有观者阅，悦，那自己更是欣喜！☺ 下面即是计算机网络一些题目的解析： 数据链路层1、假定站点A和B在同一个10Mb/s以太网网段上。这两个站点之间的传播时延为225比特时间。现假定A开始发送一帧，并且在A发送结束之前B也发送一帧。如果A发送的是以太网所容许的最短的帧，那么A在检测到和B发生碰撞之前能否把自己的数据发送完毕？换言之，如果A在发送完毕之前并没有检测到碰撞，那么能否肯定A所发送的帧不会和B发送的帧发生碰撞？（提示：在计算时应当考虑到每一个以太网帧在发送到信道上时，在MAC帧前面还要增加若干字节的前同步码和帧定界符）2、在上题中的站点A和B在t=0时同时发送了数据帧。当t=255比特时间，A和B同时检测到发生了碰撞，并且在t=255+48=273比特时间完成了干扰信号的传输。A和B在CSMA/CD算法中选择不同的r值退避。假定A和B选择的随机数分别是rA=0和rB=1。试问A和B各在什么时间开始重传其数据帧？A重传的数据帧在什么时间到达B？A重传的数据会不会和B重传的数据再次发生碰撞？B会不会在预定的重传时间停止发送数据？这道题，开始我是懵的，在网上搜了下资料，发现下面这篇文章很好，就不再赘述，直接附链接：http://blog.csdn.net/angelniu1024/article/details/23793373下面是课本参考答案： 19.主机A发送IP数据报给主机B，途中经过了5个路由器。试问在IP数据报的发送过程中总共使用了几次ARP？ 6次，主机用一次，每个路由器各使用一次。网络层5—21 假定使用连续ARQ协议中，发送窗口大小事3，而序列范围[0,15],而传输媒体保证在接收方能够按序收到分组。在某时刻，接收方，下一个期望收到序号是5.试问：（1） 在发送方的发送窗口中可能有出现的序号组合有哪几种？（2） 接收方已经发送出去的、但在网络中（即还未到达发送方）的确认分组可能有哪些？说明这些确认分组是用来确认哪些序号的分组。 运输层假定TCP在开始建立连接时，发送方设定超时重传时间是RTO=6s。（1）当发送方接到对方的连接确认报文段时，测量出RTT样本值为1.5s。试计算现在的RTO值。（2）当发送方发送数据报文段并接收到确认时，测量出RTT样本值为2.5s。试计算现在的RTO值。课后答案是下面这样的不过，我看和公式不符啊，网上搜罗了下，发现有位已经有了先见之明，下面这张图应该是对的！ 上图来源文章：TCP-IP详解: RTT和RTO的计算方法 - CSDN博客5—13 一个UDP用户数据的数据字段为8192季节。在数据链路层要使用以太网来传送。试问应当划分为几个IP数据报片？说明每一个IP数据报字段长度和片偏移字段的值。 答：6个 数据字段的长度：前5个是1480字节，最后一个是800字节。 片偏移字段的值分别是：0，1480，2960，4440，5920和7400.因为UDP用户数据报的数据字段为8192字节，所以数据报文的长度是8192+upd首部8字节=8200。所以第6个数据报片使8200-1480*5=800 注意：链路层具有最大传输单元MTU这个特性，它限制了数据帧的最大长度以太网的MTU为1500字节，一般IP首部为20字节，UDP首部为8字节，数据的净荷（payload）部分预留是1500-20-8=1472字节。如果数据部分大于1472字节，就会出现分片现象。 5—23 主机A向主机B连续发送了两个TCP报文段，其序号分别为70和100。试问：（1） 第一个报文段携带了多少个字节的数据？（2） 主机B收到第一个报文段后发回的确认中的确认号应当是多少？（3） 如果主机B收到第二个报文段后发回的确认中的确认号是180，试问A发送的第二个报文段中的数据有多少字节？（4） 如果A发送的第一个报文段丢失了，但第二个报文段到达了B。B在第二个报文段到达后向A发送确认。试问这个确认号应为多少？ 解：（1）第一个报文段的数据序号是70到99，共30字节的数据。（2）确认号应为100.（3）80字节。 （4）705—39 TCP的拥塞窗口cwnd大小与传输轮次n的关系如下所示： （1）试画出如图5-25所示的拥塞窗口与传输轮次的关系曲线。（2）指明TCP工作在慢开始阶段的时间间隔。（3）指明TCP工作在拥塞避免阶段的时间间隔。（4）在第16轮次和第22轮次之后发送方是通过收到三个重复的确认还是通过超市检测到丢失了报文段？（5）在第1轮次，第18轮次和第24轮次发送时，门限ssthresh分别被设置为多大？（6）在第几轮次发送出第70个报文段？（7）假定在第26轮次之后收到了三个重复的确认，因而检测出了报文段的丢失，那么拥塞窗口cwnd和门限ssthresh应设置为多大？ 好了，总结基本到这里了，其实还有很多内容，我只是挑了一些重要的点出来，大家接着复习吧，哈哈！ 好看的人儿，点个喜欢❤ 你会更好看哦~~","tags":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"}]},{"title":"MySQL——修改root密码的4种方法(以windows为例)","date":"2017-11-22T09:50:33.000Z","path":"2017/11/22/MySQL——修改root密码的4种方法(以windows为例)/","text":"方法1： 用SET PASSWORD命令首先登录MySQL。格式：mysql&gt; set password for 用户名@localhost = password(&#39;新密码&#39;);例子：mysql&gt; set password for root@localhost = password(&#39;123&#39;); 方法2：用mysqladmin格式：mysqladmin -u用户名 -p旧密码 password 新密码例子：mysqladmin -uroot -p123456 password 123 方法3：用UPDATE直接编辑user表首先登录MySQL。123mysql&gt; use mysql; mysql&gt; update user set password=password(&apos;123&apos;) where user=&apos;root&apos; and host=&apos;localhost&apos;; mysql&gt; flush privileges; 方法4：在忘记root密码的时候，可以这样以windows为例： 关闭正在运行的MySQL服务。 打开DOS窗口，转到mysql\\bin目录。 输入mysqld –skip-grant-tables 回车。–skip-grant-tables 的意思是启动MySQL服务的时候跳过权限表认证。 再开一个DOS窗口（因为刚才那个DOS窗口已经不能动了），转到mysql\\bin目录。 输入mysql回车，如果成功，将出现MySQL提示符 &gt;。 连接权限数据库： use mysql; 。 改密码：update user set password=password(“123”) where user=”root”;（别忘了最后加分号） 。 刷新权限（必须步骤）：flush privileges; 。 退出 quit。 注销系统，再进入，使用用户名root和刚才设置的新密码123登录。 参考转载： http://www.jb51.net/article/39454.htm好看的人儿，点个喜欢❤ 你会更好看哦~~","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"如何用css和js禁止网页选择文字(兼容) 保护版权呢？（附代码）","date":"2017-11-14T09:50:33.000Z","path":"2017/11/14/如何用css和js禁止网页选择文字(兼容)-保护版权呢？（附代码）/","text":"现在有好多人为了省事直接复制他人的文章，从而损害到别人的利益，那么如何从技术上保护呢？ 问： 前端开发css禁止选中文本如何禁止选中文字？？？ 禁止选中的方法很简单，有两种方法：JS和CSS两种 js方法（onselectstart=”return false;）直接干货123456789if(document.all)&#123; document.onselectstart= function()&#123;return false;&#125;; //for ie&#125;else&#123; document.onmousedown= function()&#123;return false;&#125;; document.onmouseup= function()&#123;return true;&#125;;&#125;document.onselectstart = new Function(&apos;event.returnValue=false;&apos;); //劫持开始选择事件和（或）鼠标按下、抬起事件。 简单方法，可以直接在标签里添加onselectstart=&quot;return false;例子如下：123&lt;div onselectstart=&quot;return false&quot;&gt; adasdasdasdasdasdasdad &lt;/div&gt; css方法（user-select）user-select有两个值： none：用户不能选择文本 text：用户可以选择文本 需要注意的是：user-select并不是一个W3C的CSS标准属性，浏览器支持的不完整，需要对每种浏览器进行调整 123456789101112body&#123;-moz-user-select: none; /*火狐*/-webkit-user-select: none; /*webkit浏览器*/-ms-user-select: none; /*IE10*/-khtml-user-select: none; /*早期浏览器*/user-select: none;&#125;IE6-9还没发现相关的CSS属性//IE6-9document.body.onselectstart = document.body.ondrag = function()&#123;return false;&#125; 附GitHub代码 好看的人儿，点个喜欢❤ 你会更好看哦~~","tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"Github contribution settings 提交颜色说明（绿的程度）","date":"2017-11-12T09:50:33.000Z","path":"2017/11/12/Github-contribution-settings-提交颜色说明（绿的程度）/","text":"经常玩github的朋友都知道github有个Your Contributions，每天的contributions 会点亮相应的表格。很多刚玩github对于contribution settings 颜色存有疑问，比如什么时候是深绿色，什么时候是浅绿色。 其实这个跟你提交的次数有关的，提交一次的时候就是浅绿，随着提交次数的增多，颜色也会加深。比如下图： 更多知识： github 的 Your Contributions 是根据什么判断 Myday？ 好看的人儿，点个喜欢❤ 你会更好看哦~~","tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]},{"title":"xgboost python包的完美安装（附包链接）","date":"2017-10-27T09:50:33.000Z","path":"2017/10/27/xgboost-python包的完美安装（附包链接）/","text":"在http://www.lfd.uci.edu/~gohlke/pythonlibs/#xgboost网站上找到xgboost现成的whl文件 进入’C:\\Users\\hasee\\AppData\\Local\\Programs\\Python\\Python35\\Scripts’目录下执行 pip install &quot;C:\\Users\\hasee\\AppData\\Local\\Programs\\Python\\Python35\\Scripts&quot; 注意：安装包要用英文状态下的双引号括住 好了，这样就成功了！ 运行import xgboost出现警告，不知怎么回事，望见过此错误的能回答一下呀？：12DeprecationWarning: This module was deprecated in version 0.18 in favor of the model_selection module into which all the refactored classes and functions are moved. Also note that the interface of the new CV iterators are different from that of this module. This module will be removed in 0.20. &quot;This module will be removed in 0.20.&quot;, DeprecationWarning) 扩展阅读：xgboost入门与实战（原理篇）python xgboost 运行异常在windows 10环境下安装xgboostpython xgboost 运行异常 | ZL 好看的人儿，点个喜欢❤ 你会更好看哦~~","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"最新版-windows安装TensorFlow（踩了多少坑）（附下载链接）","date":"2017-10-26T09:50:33.000Z","path":"2017/10/26/最新版-windows安装TensorFlow（踩了多少坑）（附下载链接）/","text":"摘要: 利用Anaconda安装python环境，并安装TensorFlow 网上有很多之类的文章，但是还是会很难安装成功,根据网上的及自己的经验，其间跳坑无数，摔得遍体鳞伤，曾一度怀疑自己廉颇老矣。最终吐血总结出来这篇博文，希望对大家有帮助！先说下我的电脑是win7,64位系统，支持（tensorflow在windows下只支持python 3.5以上、amd64） 大致步骤 先安装Anaconda（利用Anaconda创建python35的环境） 安装CUDA,CUDNN（GPU运行要用到） 安装 TensorFlow 什么是 Anaconda？ Anaconda is the leading open data science platform powered by Python.Anaconda 是一个由 Python 语言编写领先的开放数据科学平台 神魔是cuDnn和CUDACPU、GPU、CUDA，CuDNN 简介 什么是 TensorFlow？ TensorFlow is an open source software library for numerical computation using data flow graphs.TensorFlow是一个开源软件库，用于使用数据流图进行数值计算。 具体安装步骤####1. 下载 Anacondatensorflow在windows下只支持python 3.5以上、amd64 Anaconda3-4.2.0-Windows-x86_64.exe由于国外网站下载极慢，给下百度链接：http://pan.baidu.com/s/1jHNoIwu 密码：uvbgAnaconda安装过程见下面教程（只需看到Anaconda这一步就行）【Tensorflow】Windows下基于Anaconda的Tensorflow环境…_CSDN博客 2.1 安装CUDA（为了GPU）cuda_8.0.61_windows.exe链接：http://pan.baidu.com/s/1c2cZPNM 密码：o9x2下面是安装步骤win7 CUDA8.0下tensorflow gpu版环境搭配(亲测）重新启动计算机。至此，cuda的安装就搞定了。 2.2 安装CUDNN（这里只有win10和win7安装包）（为了GPU）cudnn-8.0-windows7-x64-v6.0.zipwin7链接：http://pan.baidu.com/s/1o8qmH7c 密码：l9zmwn10链接：http://pan.baidu.com/s/1pLmhiqR 密码：puk1安装步骤：http://blog.csdn.net/jiugeshao/article/details/76370137 win7 CUDA8.0下tensorflow gpu版环境搭配(亲测） ####3.安装 TensorFlow目前Google的TensorFlow是增加了Windows版本的支持，以前是只有Linux和MacOs版本。好了，那么我们就按照官方文档来安装吧。 首先在安装上有2个区分，如果你电脑支持GPU（一般都支持），那么你可以安装GPU版本，如果你的电脑不支持GPU，那么安装CPU版本。 先看看GPU版本需要多安装哪些。需要安装下面这2个驱动。 CPU版本命令输入：(不建议) pip3 install --upgrade tensorflow GPU版本命令输入：（用此方法安装，运行代码速度快的多） pip3 install --upgrade tensorflow-gpu 如下图： 测试安装完后shell进入,输入python回车输入import tensorflow试试，没报错，就证明可以 耶，可以好好玩tensorflow!可参考：如何安装支持GPU运算的TensorFlow 1.0? - 知乎专栏ubuntu16.04+cuda8.0+cudnn6+tensorflow安装Tensorflow常见错误安装tensorflow，那叫一个坑啊在Windows下直接安装Tensorflow的Windows版本【Tensorflow】Windows下基于Anaconda的Tensorflow环境…_CSDN博客Win10下用Anaconda安装TensorFlow- CSDN博客 好看的人儿，点个喜欢❤ 你会更好看哦~~","tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://yoursite.com/tags/TensorFlow/"}]},{"title":"TensorFlow版本更新后运行代码所遇到的error（持续更新）","date":"2017-10-25T09:50:33.000Z","path":"2017/10/25/TensorFlow版本更新后运行代码所遇到的error（持续更新）/","text":"本博客会持续更新，如果遇到新的问题，欢迎大家提问，大家一起进步！ AttributeError: module ‘tensorflow’ has no attribute ‘mul’ 原因：TensorFlow 发布的新版本的 API 修改了tf.mul, tf.sub and tf.neg are deprecated in favor of tf.multiply, tf.subtract and tf.negative. 解决方法：使用时将 tf.mul 改成 tf.multiply 即可其余的 tf.sub 和 tf.neg 也要相应修改为 tf.subtract 和 tf.negative。 相關學習：Tensorflow 1.3版本更新概览 windows tensorflow 版本与升级好看的人儿，点个喜欢❤ 你会更好看哦~~","tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://yoursite.com/tags/TensorFlow/"}]},{"title":"TensorFlow版本-如何更新？（踩坑版）","date":"2017-10-25T09:50:33.000Z","path":"2017/10/25/TensorFlow版本-如何更新？（踩坑版）/","text":"2017/10/26,我的tensorflow是从0.12版本升级到最新版本（1.3）的，基于python3.5的 升级升级很简单（在这里感谢一下为简化 TensorFlow 安装过程的工程师们），就是一行语句，这也是安装命令：对于 GPU 版本：pip3 install --upgrade tensorflow-gpu 对于 CPU 版本：pip3 install --upgrade tensorflow 可能踩得坑！！说到命令行，大家可能习惯性的就敲个cmd进去了。但是如果就这么简单的输入命令开始安装，会发现整个下载过程非常顺利，但是到了安装步骤的时候就出现异常了。 最关键的错误在最后两行：PermissionError: [WinError 5] 拒绝访问。 涉及到权限问题了。 暗红色的报错信息洋洋洒洒一整屏，最后还有一个换色的提示，说pip已经有9了建议升级，看到这个可能会被带到另外一个沟里，以为是pip版本太低导致的。实际上最关键的错误在最后两行：PermissionError: [WinError 5] 拒绝访问。 涉及到权限问题了。我们知道win7开始有严格的用户账户控制，大部分安装程序在安装的时候都会跳出对话框让你授权。这给系统安全带来了好处，但是也会带来一些莫名其妙的问题（之前写过一篇关于win7下装oracle10g，其中一个坑也是用户账户控制带来的）。出现这种情况一般两种情况：1、降低用户账户控制级别 2、用更高的权限来运行程序。我个人反对前者，建议从开始菜单中找到Windows PowerShell，然后从右击菜单中选择以管理员身份运行。 好了，终于可以啦！！如果遇到其他问题，欢迎大家提问！ 参考：【TensorFlow | 升级】TensorFlow 1.0 发布Tensorflow升级1.0版本 win10安装TensorFlow填坑笔记好看的人儿，点个喜欢❤ 你会更好看哦~~","tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://yoursite.com/tags/TensorFlow/"}]},{"title":"25分钟学会使用MySQL基本操作","date":"2017-09-17T09:50:33.000Z","path":"2017/09/17/25分钟学会使用MySQL基本操作/","text":"###1 MySQL登录与退出 MySQL登陆MySQL 参数(在cmd命令框中输入) 登陆MySqlmysql -uroot -p -P3306 -h127.0.0.1 MySql退出 MySQL修改root密码 MySQL修改root密码链接 2 修改MySQL提示符及语法规范先说一个小技巧，cmd命令框清屏用cls 首先说一下神魔是MySql提示符？看下面图就懂了 连接客户端即登录时通过参数指定mysql -uroot -proot --prompt 提示符 连接上客户端后，通过prompt命令修改prompt 提示符 下面是MySql具体可更更改的操作 PROMPT \\u@\\h \\d 修改为用户名@主机名 数据库名称 3 MySQL常用命令 4 MySQL语句规范特别注意分号，因为不加分号，这段语句不执行，如下图 5 数据库操作{}必选项，[]可选项 数据库怎么看呢？当前服务器下到底有多少数据库(正确安装之后，默认有四个数据库)show DATABASES 创建数据库编码方式是什么？不加，默认是配置文件设置的编码方式 如果想创建一个GBK的编码方式的数据库怎么来？CREATE DATABASE IF NOT EXISTS Hello2 CHARACTER SET gbk 修改数据库 修改编码方式ALTER DATABASE Hello2 CHARACTER SET utf8 删除数据库DROP DATABASE 数据库名 基本操作就这样了！回顾下重点： 对了，还要说下，写SQL每句语句的后面，一定要加分号 ;哦！！ 可参考的常用命令链接： MYSQL常用命令Mysql命令大全 - 宁静.致远 - 博客园","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"coursera视频无法播放（翻墙也无效）？看这里就全懂了","date":"2017-09-17T09:50:33.000Z","path":"2017/09/17/coursera视频无法播放（翻墙也无效）？看这里就全懂了/","text":"Coursera是国外的一款非常有名的公开课网站，值得大家一起学习,但有时候要在coursera上看个课程，发现看不了，爬墙各种方法都试了，特意在网上搜集了解决方案，亲测有效，现在特意记录下来，希望能帮到你。好好学习，天天向上。 该方法针对Windows用户(win7，win8，win10)，亲测有效。Mac电脑的可参考我最后发的链接 用管理员权限记事本打开host文件，地址如下: C:\\Windows\\System32\\drivers\\etc，（以文本格式打开hosts就好） 将如下内容复制到文件末尾12345678952.84.246.90 d3c33hcgiwev3.cloudfront.net52.84.246.252 d3c33hcgiwev3.cloudfront.net52.84.246.144 d3c33hcgiwev3.cloudfront.net52.84.246.72 d3c33hcgiwev3.cloudfront.net52.84.246.106 d3c33hcgiwev3.cloudfront.net52.84.246.135 d3c33hcgiwev3.cloudfront.net52.84.246.114 d3c33hcgiwev3.cloudfront.net52.84.246.90 d3c33hcgiwev3.cloudfront.net52.84.246.227 d3c33hcgiwev3.cloudfront.net 如下图： 打开cmd命令行，输入如下命令ipconfig/flushdns 刷新页面即可，终于可以看视频啦 参考链接：coursera 视频总是缓冲或者无法观看,有什么方法解决? - 知乎coursera无法观看视频解决方法Coursera无法观看课程解决方案-百度经验 Mac和windows国内coursera官网看不了视频怎么办**好看的人儿，点个喜欢❤ 你会更好看哦~~","tags":[{"name":"技术杂谈","slug":"技术杂谈","permalink":"http://yoursite.com/tags/技术杂谈/"},{"name":"coursera","slug":"coursera","permalink":"http://yoursite.com/tags/coursera/"}]},{"title":"吴恩达-神经网络和深度学习（ 第三周 浅层神经网络：）","date":"2017-09-14T09:50:33.000Z","path":"2017/09/14/吴恩达-神经网络和深度学习（-第三周--浅层神经网络：）/","text":"学习使用前向传播和反向传播搭建出有一个隐藏层的神经网络。 hidden layer Neural Network ###3.1 神经网络概览 ###3.2 神经网络表示 双层神经网络（只有一个隐藏层，单隐层神经网络） 输入层-四个隐藏层单元-输出层 双层神经网络。不把输入层看做一个标准的层 这里的隐藏层有两个相关的参数w和b,使用上标[1]表示这些参数，w是4x3矩阵,b是4x1向量（4代表有四个节点或者隐藏单元，3来自于3个输入特征） 输出层也有相关的参数w^[2] (1x4,隐藏层有四个隐藏单元，输出层只有一个单元),b^[2]【1x1】 ###3.3 计算神经网络的输出 gengrate 生成compute 计算matrix 矩阵 神经网络只不过是计算这些步骤很多次 ###3.4 多个例子中的向量化 训练样本横向堆叠构成矩阵X m个训练样本 用激活函数来表示这些式子a^[2](i)【i是训练样本i,2指的是第二层】 一个for循环遍历所有的m训练样本 向量化 ###3.5 向量化实现的解释 这就是对不同训练样本向量化的神经网络，接下来，我们目前为止我们一直都是用sigmoid函数 ###3.6 激活函数（activation function） 如何使用不同种类的激活函数，simoid只是其中的一个可能选择 为了搭建神经网络，可以选择的是选择隐层里用哪个激活函数，还有神经网络的输出单元用什么激活函数有一个函数总比sigmoid函数表现好，那就是a=tanh(z)（双曲正切函数），函数介于+1和-1之间，意味着激活函数的平均值更接近0 但 二分分类是，输出层最好用sigmoid,因为y输出介于0-1更合理 不过，sigmoid和tanh函数都有一个缺点，如果z非常大，或非常小，函数的斜率很接近0，这样会拖慢梯度下降算法 修正线性单元（ReLU）就派上用场了（z为正，斜率为1，为负，斜率为0） 在选择激活函数时有一些经验法则 如果你的输出值是0或1，如果你在做二元分类，那么sigmoid很适合作为输出层的激活函数，然后其他所有单元都用ReUL。如果你不确定隐层应该用哪个，那就用ReUL作为激活函数 还有个带泄露的ReUL（z小于0是有一个缓缓的斜率，）通常比ReUL激活函数好，不过实际中使用的频率没那么高 在实践中使用ReUL激活函数，学习速度通常会快得多，比使用tanh或sigmoid激活函数快得多，因为ReUL没有函数斜率接近0时，减慢学习速度的学习速度的效应 说一下几个激活函数 sigmoid除非用在二元分类的输出层，不然绝对不要用，或者几乎从来不会用 最常用的默认激活函数ReLU，不确定用哪个，就用这个，或者带泄露的ReLU（max(0.01z, z)） ###3.7 为什么需要非线性激活函数（nonlinear activation function）？ 如果用线性激活函数（linear activation function）或者叫做恒等激活函数，那么神经网络只是把输入线性组合再输出，无论你的神经网络多少层，一直在做的只是计算线性激活函数，和没有任何的标准Logistic回归是一样的，因为两个线性函数组合的本身就是线性函数，除非你引用非线性， 只有一个地方可以使用线性激活函数g（z） = z，就是你要机器学习的是回归问题，所以y是一个实数， 线性激活函数不可能用在隐藏层（除压缩），要用，也是用在输出层， ###3.8 激活函数的导数 接下来讨论梯度下降的基础，如何估计，如何计算单个激活函数的导数，斜率， ###3.9 神经网络的梯度下降法梯度下降算法的具体实现，如何处理单隐层神经网络，提供所需的方程，来实现反向传播，或者说梯度下降算法， keepdims = true(确保python输出的是矩阵) 正向传播 4个方程 反向传播 6个方程 ###3.10 （选修）直观理解反向传播 ###3.11 随机初始化 当你训练神经网络时，随机初始化权重非常重要，对于logistic回归，可以将权重初始化为零，但如果将神经网络各参数数组初始化为0，再使用梯度下降算法（gredient descent），那会完全失效 因为我们需要两个不同的隐藏单元，去计算不同的函数，这个问题的解决方案是随机初始化所有参数， 可以令W^[1] = np.random,randn, 这可以产生参数为（2， 2）的高斯分布随机变量，然后你再乘以一个很小的数字【因为通常喜欢把权重矩阵初始化非常小的随机数】，所有你将权重初始化很小的随机数， 如果训练单隐层神经网络时，没有太多的隐藏层，设为0.01还可以，但当训练一个很深的神经网络时，可能要试试0.01以外的常数， 把b初始化0是可以的 所以，在这周的视频里，你知道如何设立单隐层神经网络，初始化参数，并用正向传播计算预测值，还有计算导数，然后使用梯度下降，反向传播","tags":[{"name":"神经网络","slug":"神经网络","permalink":"http://yoursite.com/tags/神经网络/"},{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/tags/深度学习/"}]},{"title":"看透神经网络和深度学习的脉络，终于不迷糊了","date":"2017-09-09T09:50:33.000Z","path":"2017/09/09/看透神经网络和深度学习的脉络，终于不迷糊了/","text":"神经网络和深度学习近几年好多人在学习，但是他们具体是什么关系，又有什么联系，众说纷纭，有人说：深度学习可以理解成用深度神经网络（DNN，Deep Neural Network）来进行机器学习，有人说：深度学习是一种方法，神经网络是个模型。用了深度学习可以有效解决层数多的网络不好学习的问题还有人说：本是同根生，相煎何太急接下来，下面这张图，能帮助大家更好地学习神经网络和深度学习，掌握理清脉络 线性回归是最基本的注释：红色是基础 ＮＬＰ自然语言处理(nlp,natural language processing) 机器学习(machine learning) ＣＮＮ卷积神经网络（convolutional neural network） ＲＮＮ递归神经网络(Recurrent Neural Network) LSTM Long Short Term Memory长的短时记忆长短时记忆长短时记忆模型 CNN：卷积神经网络【空间】RNN: 递归神经网络【时域】神经网络中，隐含层网络的输出作为下一时刻自身的输入–&gt;一级一级会衰弱–》需要记忆封存的结构（LSTM）RNN-&gt;LSTM【记忆量的扩充】 描述 非线性的运算关系叠加起来就是一个神经网络 神经网络到CNN，RNN（空间和时间的扩展） 卷积核：二维的处理算组，图像的处理 神经网络到CNN就是一维到二维三维的转化，在空间上进行扩展 神经网络到RNN（神经网络一维有个时间的延续，比如说语音） 记忆GATE-根据输入的信息判断哪些是需要提前记下来的，在之后处理的时候选择要不要释放 小象学院公开课具体讲述了这一内容，下面是视频链接：视频连接 本文转载自微信公众号：重庆小哥稳","tags":[{"name":"神经网络","slug":"神经网络","permalink":"http://yoursite.com/tags/神经网络/"},{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/tags/深度学习/"}]},{"title":"吴恩达-神经网络和深度学习(第二周神经网络基础)","date":"2017-09-07T09:50:33.000Z","path":"2017/09/07/吴恩达-神经网络和深度学习(第二周神经网络基础)/","text":"学习如何用神经网络的思维模式提出机器学习问题、如何使用向量化加速你的模型。 先介绍一些名词 training set (训练集) feature vector(特征向量) classifier(分类器) calculus（微积分） 循环（loop） 数据集（datasets） vectorization (向量化) matrix(矩阵) vector(向量) 本周用到的一些符号【Notation】 （x,y）表示一个单独的样本 x是xn维的特征向量 标签y值为0/1 训练集由m个训练样本构成 (x^(1), y^(1))表示样本一输入和输出， {x^(1), y^(1),…..x^(n), y^(n).}整个训练集 测试集的 样本数。训练集的样本数 矩阵也可表示训练集输入x,输出标签y 注意：训练样本作为行向量堆叠 输出y是1xm矩阵 如下图： 二分分类【Binary Classification】 神经网络的计算过程中，通常有一个正向过程【forward pass】（或者正向传播步骤）,接着有一个反向过程【backward pass】(或者反向传播步骤) logistic回归是一个用于二分分类的算法 计算机保存图片，要保存三个独立矩阵（Red红 blue绿 Green蓝）如果有64X64的一张图片，则输入向量的维度n=64X64X3=12288 在二分分类问题中，目标是训练出一个分类器，他以图片的特征向量x作为输入，，预测输出的结果y(只有两个值) logistic回归这是一个学习算法，用在监督学习中，如下图： logistic回归损失函数损失函数【error function】在单个训练样本中定义的，他衡量了在单个训练样本上的表现成本函数【cost function 】在全体训练集样本下的表现–&gt;对损失函数求和对以上函数要找到合适的参数w和b成本函数用于衡量参数w和b的效果 如下图： 梯度下降法【Gradient Descent】 训练或学习训练集上的参数w和b 导数等于= be equal to pluse minusX times/ divide 计算图 可以说，一个神经网络的计算都是按照前向或者反向传播过程来实现的，首先计算出神经网络的输出首先计算出神经网络的输出，紧接着一个反向传播操作，后者我们用来计算出对应的梯度或者导数，流程图解释了为什么这样实现流程图，是用蓝色箭头画出来的的，从左到右的计算 计算图的导数计算从右到左计算导数 logistic回归中的梯度下降法（用偏导数实现）导数流程图来计算梯度用偏导数有点大材小用，但对理解比较好 m个样本的梯度下降运用到整个样本集中 向量化循环很低效率，用向量化来加速运算(np.function)z=np.dot(w, x) + b可能有人说：可扩展深度学习实现是在GPU(图像处理单元)上做的，而我们做的再jupyter notebook上（CPU）但GPU和CPU都有并行化的指令，SIMD单指令流多数据流，这点对GPU和CPU上面是成立的，只是GPU更擅长SIMD运算 for循环能不用就不用，如果可以使用内置函数或者其他方法计算循环，会比for循环更快 进一步向量化logistic回归 向量化logistic回归的梯度输出这就得到高度向量化的，高效的logistic回归梯度下降法 python中的广播（使python和Numpy部分代码更高效）广播（broadcasting）对列向量，行向量都有效例子： 实现神经网络算法时主要用到的广播形式 关于python/numpy向量的说明千万不要用秩为1的数组随意插入assert()声明，要仔细检查矩阵和数组的维度不要害怕调用reshape,来确保你的矩阵和向量 可以排除，简化甚至消灭代码中各种奇怪的bug 学习链接4. Logistic代码实战","tags":[{"name":"神经网络","slug":"神经网络","permalink":"http://yoursite.com/tags/神经网络/"},{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/tags/深度学习/"}]},{"title":"吴恩达-神经网络和深度学习(第一周深度学习概论)","date":"2017-09-01T09:50:33.000Z","path":"2017/09/01/吴恩达-神经网络和深度学习(第一周深度学习概论)/","text":"学习驱动神经网络兴起的主要技术趋势，了解现今深度学习在哪里应用、如何应用。 8 月 8 日，吴恩达正式发布了 Deepleanring.ai——基于 Coursera 的系列深度学习课程，但在中国无法访问这套课程（除非你连VPN），还有Coursera中是英文授课，就有点尴尬。幸好，之后，吴恩达和网易合作，将课程内容免费放到网易的教育平台上.所以，终于有机会学这门课了！特记下笔记，以备忘！ 可以先看一下人工智能的完整学习图 有一起学习的同学，可以联系我，一起进步哦！！！Coursera学习Deep Learning Specialization网易云学习地址 什么是神经网络由输入到输出修正线性单元（ReLU） 用神经网络进行监督学习神经网络（neutral networks） 机器学习–&gt;监督学习 监督学习 standard NN – 房屋价格预测，广告点金 卷积神经网络（CNN）—图像领域 循环神经网络（RNN）—一维序列，时间，音频(机器翻译，语音变文本) 复杂，混合神经网络（complex,hybrid,NN）—（无人驾驶）基本图例： 结构化数据和非结构化数据 结构化数据：数据的数据库 非结构化数据：机器不容易理解的语音,图片,文本(用于语音识别，图像识别，自然语言文字处理) 如下图理解： 符号规定m–训练集的规模（训练样本的数量） 深度学习进行过程 学完第一周的课程，特意找了一张图片，宏观把控，今后一定非常有用 待续…….","tags":[{"name":"神经网络","slug":"神经网络","permalink":"http://yoursite.com/tags/神经网络/"},{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/tags/深度学习/"}]},{"title":"mongoexport导出数据时遇到的种种问题（好坑）","date":"2017-08-26T09:50:33.000Z","path":"2017/08/26/mongoexport导出数据时遇到的种种问题（好坑）/","text":"想导出mongodb数据库里的数据，结果，搞了一天，踩了无数的坑，才终于导出数据，真的，要哭了，赶紧记录下来（说实话，网上有些文章真的随着版本的更新，有些过时了，真的是助我踩坑耶）我主要讲我踩得坑哈，顺便说下！ 首先要开启服务，进入命令框NET START MongoDB然后进入安装目录（我的安装目录）：cd D:\\Program Files\\Work\\MongoDB\\Server\\3.4\\bin，执行mongo 执行以上两步后，就可以输入有用的命令了导出数据：mongoexport -h 127.0.0.1 -u root -p 12345 -d taobao -c prodect --type=cvs -o D:\\data\\prodect_cvs.dat不知上述意思的可以参见： Mongo的导出工具mongoexport介绍然后就报错122017-08-26T15:48:30.940+0800 error connecting to db server: server returned error on SASL authentication step: Authentication failed. 网上搜了一下，说–authenticationDatabase admin 这是是必须的，否则会报上述错误：解决办法再添加一串代码： --authenticationDatabase admin但是添加了之后还是报相同的错，又搜了一下,看了下面一篇博文 mongoDB authentication 连接到admin数据库，在admin数据库上创建一个用户，这个用户保存在admin.system.users中，它的权限比在其它数据库中设置的用户权限更大。（当admin.system.users中一个用户都没有时，即使mongod启动时添加了–auth参数，如果没有在admin数据库中添加用户，此时不进行任何认证还是可以做任何操作，直到在admin.system.users中添加了一个用户。） 原来是我没创建一个用户，但大家要注意创建用户的命令版本不同，命令也有可能不同，我就遇到了这个问题，mongodb3.X用的方法： mongoDB add user in v3.0 问题的解决（Property ‘addUser’ of object admin is not a func） 我的版本是3.X的，所有我应该执行下面 123456789101112use admindb.createUser( &#123; user: &quot;appAdmin&quot;, pwd: &quot;password&quot;, roles: [ &#123; role: &quot;readWrite&quot;, db: &quot;config&quot; &#125;, &quot;clusterAdmin&quot; ] &#125;) 旧点的版本：12use admindb.addUser(&apos;appAdmin&apos;, &apos;password&apos;) 创建完成之后如下图： 然后又遇到一个问题csv mode requires a field list,原因是第一次没有指明要导出的列，所以只是实现一个空的文件 123456user@user-xubuntu:/usr/lib/mongodb/bin$ sudo ./mongoexport -d wx_connect -c template --csv -o template_csv.dat connected to: 127.0.0.1 csv mode requires a field list ------第一次没有指明要导出的列，所以只是实现一个空的文件 user@user-xubuntu:/usr/lib/mongodb/bin$ sudo ./mongoexport -d wx_connect -c template --csv -f msgId,templateId,status,toUser -o template_csv_new.dat connected to: 127.0.0.1 exported 28 records ------导出成功 所以在末尾再加上-f 一列的名字mongoexport -h 127.0.0.1 -u root -p 12345 -d taobao -c prodect --type=cvs -o D:\\data\\prodect_cvs.dat --authenticationDatabase admin -f shop 参考博客： mongoDB的基本操作以及数据的导入导出，备份和恢复如下图 哇。终于完成了，有点小激动啊！！","tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://yoursite.com/tags/mongodb/"}]},{"title":"windows下mongodb的安装与配置（全）","date":"2017-08-25T09:50:33.000Z","path":"2017/08/25/windows下mongodb的安装与配置（全）/","text":"由于学Python存数据，需要用到mongodb数据库，自己在网上搜了很多教程，也踩了许多坑，特记录下来，希望能够对一些朋友有用,也记录下自己学的东西。 下载与安装 下载地址：https://www.mongodb.com/download-center#community 下载符合你系统的版本，然后安装。默认安装到C:\\Program Files\\MongoDB,你也可以自定义安装目录。我的目录是：·D:\\Program Files\\Work\\MongoDB\\Server\\3.4 创建数据目录MongoDB将数据目录存储在 db 目录下。但是这个数据目录不会主动创建，我们在安装完成后需要创建它。 请注意，数据目录应该放在根目录下（(如： C:\\ 或者 D:\\ 等 )。 这里我们新建mongodb文件夹在文件夹下新建各种东西我们假设创建数据目录在D:\\mongodbData\\data\\db 命令行运行mogondb服务假设你的mongodb安装在D:\\Program Files\\Work\\MongoDB\\Server\\3.4 打开cmd命令框进入安装目录D:\\Program Files\\Work\\MongoDB\\Server\\3.4\\bin 启动服务：mongod.exe --dbpath D:\\mongodbData\\data\\db 出现下图数据即算成功 将MongoDB服务器作为Windows服务运行先终止命令行，执行：12D:\\Program Files\\Work\\MongoDB\\Server\\3.4\\bin&gt; mongod.exe --logpath &quot;D:\\mongodbData\\data\\log\\mongodb.log&quot; --logappend --dbpath &quot;D:\\mongodbData/data/db&quot; --port 27017 --serviceName &quot;MongoDB&quot; --install 下表为mongodb启动的参数说明：自己注意按照自己的路径进行修改 12345678--bind_ip 绑定服务IP，若绑定127.0.0.1，则只能本机访问，不指定默认本地所有IP--logpath 定MongoDB日志文件，注意是指定文件不是目录--logappend 使用追加的方式写日志--dbpath 指定数据库路径--port 指定服务端口号，默认端口27017--serviceName 指定服务名称--serviceDisplayName 指定服务名称，有多个mongodb服务时执行。--install 指定作为一个Windows服务安装。 终止命令行中的mongodb服务，打开刚才新建的mongodb服务：NET START MongoDB运行之后如下图 如果出现服务器无法正常启动的问题，是因为mongod.lock这个文件，在服务器异常退出时，该文件会影响下一次启动mongod服务的,我们首先关闭命令行mongodb服务，然后只需要删除该文件就行了： mongod.exe --config e:\\data\\db\\mongod.lock --remove windows删除服务命令： sc delete MongoDB MongoDB后台管理 Shell进入安装目录：1cd D:\\Program Files\\Work\\MongoDB\\Server\\3.4\\bin` 执行mongo.exe,如下图 启动MongoDB服务net start MongoDB 关闭MongoDB服务net stop MongoDB 移除MongoDB服务D:\\Program Files\\Work\\MongoDB\\Server\\3.4\\bin\\mongod.exe --remove 最后说一下： 由于mongodb数据看不到摸不着，可视化工具是必须的推荐，推荐一个MongoDB可视化工具RoboMongoMongoDB可视化工具RoboMongo安装与连接教程安装很简单，但是别忘了配置环境变量 再推荐一个mongodbd的操作教程：http://wiki.jikexueyuan.com/project/mongodb/ 好了接下来就可以好好玩数据了 参考文章：http://www.jianshu.com/p/4bda3b7a9ea6http://www.jianshu.com/p/bc088aa972e9http://www.runoob.com/mongodb/mongodb-window-install.html","tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://yoursite.com/tags/mongodb/"}]},{"title":"python3X安装beautifulsoup&&BS64遇到的一些error","date":"2017-08-19T09:50:33.000Z","path":"2017/08/19/python3X安装beautifulsoup&&BS64遇到的一些error/","text":"用beautifulsoup写的没错的小爬虫地址： 前言: Beautiful Soup 3 目前已经停止开发，推荐在现在的项目中使用Beautiful Soup 4，不过它已经被移植到BS4了，也就是说导入时我们需要 import bs4 。所以这里我们用的版本是 Beautiful Soup 4.3.2 (简称BS4)，另外据说 BS4 对 Python3 的支持不够好，虽然我用的Python35，如果有小伙伴用的是 Python3 版本，可以考虑下载 BS3 版本。自己搞网页数据爬取时，需要 from bs4 import BeautifulSoup,所以在py程序运行中遇到了一系列错误……. 错误一：ImportError: No module named &#39;bs4&#39;错误如下： 解决方法如下 Python如何安装模块： 1.下载BS4模块： http://www.crummy.com/software/BeautifulSoup/bs4/download/4.3/beautifulsoup4-4.3.2.tar.gz 2.解压到Python安装目录下的根目录中： 3.运行cmd，进入解压缩后的目录（如果Python默认安装在C盘下，打开cmd之后可以使用cd …语句先返回根目录，再进入Python27\\beautifulsoup4-4.3.2）4.进入Python27\\beautifulsoup4-4.3.2之后安装BS4模块：执行：python setup.py install 可参考链接：http://www.cnblogs.com/victor5230/p/6397449.html 然而又出现错误： 错误二： ImportError: cannot import name &#39;HTMLParseError&#39;解决bs4在Python 3.5下出现“ImportError: cannot import name ‘HTMLParseError’”错误 解决方法如下：直接在cmd命令框中执行pip --upgrade beautifulsoup4 可参考链接：http://blog.csdn.net/sinat_26599509/article/details/50609646 错误三：bs4.FeatureNotFound又出现错误:如下 bs4.FeatureNotFound: Couldn&#39;t find a tree builder with the features you requested: lxml. Do you need to install a parser library? 解决方法：首先安装’pip install wheel’https://www.zhihu.com/question/49221958/answer/115712155 安装pip install lxml可参考链接1：https://www.zhihu.com/question/49221958/answer/115712155可参考链接2：http://study.163.com/forum/detail/1002230039.htm 竟然就好了！！！！！！！","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Python 爬虫必备-正则表达式（re模块）","date":"2017-08-19T09:50:33.000Z","path":"2017/08/19/Python-爬虫必备-正则表达式（re模块）/","text":"正则表达式须知 正则表达式是用来匹配字符串非常强大的工具，在其他编程语言中同样有正则表达式的概念，Python同样不例外，利用了正则表达式，我们想要从返回的页面内容提取出我们想要的内容就易如反掌了。 正则表达式的大致匹配过程是：1.依次拿出表达式和文本中的字符比较，2.如果每一个字符都能匹配，则匹配成功；一旦有匹配不成功的字符则匹配失败。3.如果表达式中有量词或边界，这个过程会稍微有一些不同。 正则表达式语法规则下面是Python中正则表达式的一些匹配规则，图片资料来自CSDN 正则表达式特别强调 python转义字符 正则表达式使用反斜杠” \\ “来代表特殊形式或用作转义字符，这里跟Python的语法冲突，因此，Python用” \\\\ “表示正则表达式中的” \\ “，因为正则表达式中如果要匹配” \\ “，需要用\\来转义，变成” \\ “，而Python语法中又需要对字符串中每一个\\进行转义，所以就变成了” \\\\ “。 Python里的原生字符串很好地解决了这个问题，这个例子中的正则表达式可以使用r”\\”表示。同样，匹配一个数字的”\\d”可以写成r”\\d”。有了原生字符串，妈妈也不用担心是不是漏写了反斜杠，写出来的表达式也更直观勒。 贪婪模式和非贪婪模式 正则表达式通常用于在文本中查找匹配的字符串。Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；非贪婪则相反，总是尝试匹配尽可能少的字符。在”*”,”?”,”+”,”{m,n}”后面加上？,使贪婪变成非贪婪。 可参考： python 正则表达式的贪婪匹配与非贪婪匹配 Python Re模块Python 自带了re模块，它提供了对正则表达式的支持。主要用到的方法列举如下 12345678910#返回pattern对象re.compile(string[,flag]) #以下为匹配所用函数re.match(pattern, string[, flags])re.search(pattern, string[, flags])re.split(pattern, string[, maxsplit])re.findall(pattern, string[, flags])re.finditer(pattern, string[, flags])re.sub(pattern, repl, string[, count])re.subn(pattern, repl, string[, count]) 在介绍这几个方法之前，我们先来介绍一下pattern的概念，pattern可以理解为一个匹配模式，那么我们怎么获得这个匹配模式呢？很简单，我们需要利用re.compile方法就可以。例如1pattern = re.compile(r&apos;hello&apos;) 另外大家可能注意到了另一个参数 flags，在这里解释一下这个参数的含义： 参数flag是匹配模式，取值可以使用按位或运算符’|’表示同时生效，比如re.I | re.M。 可选值有：123456• re.I(全拼：IGNORECASE): 忽略大小写（括号内是完整写法，下同）• re.M(全拼：MULTILINE): 多行模式，改变&apos;^&apos;和&apos;$&apos;的行为（参见上图）• re.S(全拼：DOTALL): 点任意匹配模式，改变&apos;.&apos;的行为• re.L(全拼：LOCALE): 使预定字符类 \\w \\W \\b \\B \\s \\S 取决于当前区域设定• re.U(全拼：UNICODE): 使预定字符类 \\w \\W \\b \\B \\s \\S \\d \\D 取决于unicode定义的字符属性• re.X(全拼：VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。 在刚才所说的另外几个方法例如 re.match 里我们就需要用到这个pattern了，下面我们一一介绍。 （1）re.match(pattern, string[, flags])这个方法将会从string（我们要匹配的字符串）的开头开始，尝试匹配pattern，一直向后匹配，如果遇到无法匹配的字符，立即返回None，如果匹配未结束已经到达string的末尾，也会返回None。两个结果均表示匹配失败，否则匹配pattern成功，同时匹配终止，不再对string向后匹配。下面我们通过一个例子理解一下123456789101112131415161718192021222324252627282930313233343536373839# 将正则表达式编译成Pattern对象，注意hello前面的r的意思是“原生字符串”pattern = re.compile(r&apos;hello&apos;) # 使用re.match匹配文本，获得匹配结果，无法匹配时将返回Noneresult1 = re.match(pattern,&apos;hello&apos;)result2 = re.match(pattern,&apos;helloo CQC!&apos;)result3 = re.match(pattern,&apos;helo CQC!&apos;)result4 = re.match(pattern,&apos;hello CQC!&apos;) #如果1匹配成功if result1: # 使用Match获得分组信息 print(result1.group())else: print (&apos;1匹配失败！&apos;) #如果2匹配成功if result2: # 使用Match获得分组信息 print(result2.group())else: print( &apos;2匹配失败！&apos;) #如果3匹配成功if result3: # 使用Match获得分组信息 print( result3.group())else: print(&apos;3匹配失败！&apos;) #如果4匹配成功if result4: # 使用Match获得分组信息 print( result4.group())else: print( &apos;4匹配失败！&apos;) 我们还看到最后打印出了result.group()，这个是什么意思呢？下面我们说一下关于match对象的的属性和方法Match对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。 12341.group([group1, …]):获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。2.groups([default]):以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。 （2）re.search(pattern, string[, flags])search方法与match方法极其类似，区别在于match()函数只检测re是不是在string的开始位置匹配，search()会扫描整个string查找匹配，match（）只有在0位置匹配成功的话才有返回，如果不是开始位置匹配成功的话，match()就返回None。同样，search方法的返回对象同样match()返回对象的方法和属性。我们用一个例子感受一下 12345678# 将正则表达式编译成Pattern对象pattern = re.compile(r&apos;world&apos;)# 使用search()查找匹配的子串，不存在能匹配的子串时将返回None# 这个例子中使用match()无法成功匹配match = re.search(pattern,&apos;hello world!&apos;)if match: # 使用Match获得分组信息 print( match.group()) （3）re.split(pattern, string[, maxsplit])按照能够匹配的子串将string分割后返回列表。maxsplit用于指定最大分割次数，不指定将全部分割。我们通过下面的例子感受一下。 12345pattern = re.compile(r&apos;\\d+&apos;)print( re.split(pattern,&apos;one1two2three3four4&apos;)) ### 输出 #### [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;, &apos;four&apos;, &apos;&apos;] （4）re.findall(pattern, string[, flags])搜索string，以列表形式返回全部能匹配的子串。我们通过这个例子来感受一下 12345pattern = re.compile(r&apos;\\d+&apos;)print( re.findall(pattern,&apos;one1two2three3four4&apos;)) ### 输出 #### [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;] （5）re.finditer(pattern, string[, flags])搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。我们通过下面的例子来感受一下 123456pattern = re.compile(r&apos;\\d+&apos;)for m in re.finditer(pattern,&apos;one1two2three3four4&apos;): print( m.group()), ### 输出 #### 1 2 3 4 （6）re.sub(pattern, repl, string[, count])使用repl替换string中每一个匹配的子串后返回替换后的字符串。当repl是一个字符串时，可以使用\\id或\\g、\\g引用分组，但不能使用编号0。当repl是一个方法时，这个方法应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。count用于指定最多替换次数，不指定时全部替换。123456789pattern = re.compile(r&apos;(\\w+) (\\w+)&apos;)s = &apos;i say, hello world!&apos; print( re.sub(pattern,r&apos;\\2 \\1&apos;, s)) def func(m): return m.group(1).title() + &apos; &apos; + m.group(2).title() print( re.sub(pattern,func, s)) （7）re.subn(pattern, repl, string[, count])返回 (sub(repl, string[, count]), 替换次数)。12345678910111213pattern = re.compile(r&apos;(\\w+) (\\w+)&apos;)s = &apos;i say, hello world!&apos; print( re.subn(pattern,r&apos;\\2 \\1&apos;, s)) def func1(m): return m.group(1).title() + &apos; &apos; + m.group(2).title() print( re.subn(pattern,func1, s)) ### output #### (&apos;say i, world hello!&apos;, 2)# (&apos;I Say, Hello World!&apos;, 2) 参考：静觅 » Python爬虫入门七之正则表达式python中re项目详解","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python35下的NLTK工具的安装和配置","date":"2017-08-17T09:50:33.000Z","path":"2017/08/17/python35下的NLTK工具的安装和配置/","text":"首先要说明的是我的安装环境是win7 64位，安装了python35 官网下载NLTKhttps://pypi.python.org/pypi/nltk我安装的是nltk-3.2.4.tar.gz安装上述软件，我的安装目录是D:\\Program Files\\Computer-learning解压缩nltk-3.2.4.tar.gz，在 cmd 中进入到D:\\Program Files\\Computer-learning\\nltk-3.2.4目录，执行 python setup.py install 成功标志：123Installed c:\\users\\hasee\\appdata\\local\\programs\\python\\python35\\lib\\site-packages\\six-1.10.0-py3.5.eggFinished processing dependencies for nltk==3.2.4 安装完成后，在IDLE中运行：执行下面两行 12import nltknltk.download() 出现一个NLTK Downloader对话框，修改Download Diretory（E盘或其他盘符下），我放在了C:\\Users\\hasee\\AppData\\Roaming\\nltk_data。点击all开始下载，如下 下载完成后 下载慢还可以到NLTK Corpora http://nltk.org/nltk_data/手工下载缺失的，然后放到Download Diretory，zip别删。重装系统后nltk_data文件夹可以保留，避免重复下载。","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Python安装与Eclipse环境配置（踩坑,看完这篇就够了）","date":"2017-08-12T09:50:33.000Z","path":"2017/08/12/Python安装与Eclipse环境配置（踩坑,看完这篇就够了）/","text":"安装python（配置环境变量）http://www.runoob.com/python/python-tutorial.html 配置Eclipse（路径）http://www.runoob.com/python/python-ide.html 配置PyDev 点击help按钮–&gt;Install New Software Name:取PyDevLocation：http://www.pydev.org/updates进去之后只需选择第一个包，点击next，之后一直点击下一步即可（有任何弹框，选择accept）完成，点击Yes重新启动Eclipse 新建python项目流程点击new Project，会出现Pydev文件夹，选择PyDev Project，点击Next点击OK点击apply应用点击next点击finish然后在新建的Project（python35）右击，new一个PyDev Module这样基本就完成了下面写一行代码测试一下选直接运行就行，目前不需要单元测试运行之后报错12Python脚本语法错误：SyntaxError: (unicode error) &apos;utf8&apos; codec can&apos;t decode byte 0xc0 in position 0: invalid start byte ![mark](http://upload-images.jianshu.io/upload_images/4340772-e7845b15c4257aa3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 这是因为编码格式出现问题具体了解可参考下面这个文章http://againinput4.blog.163.com/blog/static/1727994912011112224749861/要加两行代码12#!/usr/bin/python # -*- coding: UTF-8 -*- 有个尴尬的问题：我加上那两行代码，还是出错，删除那两行代码，又可以运行了,可能之前我安装了python27,这次安装了python35，第一次运行没反应过来，哈哈。总结一下： python2.X版本需要加下面这两行代码，python3.X则不需要12#!/usr/bin/python # -*- coding: UTF-8 -*- 接下来就可以好好玩Python（蛇）了","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Windows环境下msysgit下安装gitflow步骤","date":"2017-08-11T09:50:33.000Z","path":"2017/08/11/Windows环境下msysgit下安装gitflow步骤/","text":"在网上，查了好多资料，不过网上说法有好多坑，所有自己特意写了一篇，以便看此博文的人少踩坑！！ #一、Git相关配置（Windows） ##1.安装git和git flowWindows下git客户端：Git-1.9.2-preview20140411.exe参考文档，来自github的gitflow的wiki，链接：https://github.com/nvie/gitflow/wiki/Windows 这里只介绍msysgit环境下的gitflow安装。首先需要下载两个文件：getopt.exe和libintl3.dll下载地址：（可以在浏览器下载就直接下载，如果不行（反正我是不行），复制网址到 迅雷直接下载）http://sourceforge.net/projects/gnuwin32/files/util-linux/2.14.1/util-linux-ng-2.14.1-bin.zip/downloadhttp://sourceforge.net/projects/gnuwin32/files/util-linux/2.14.1/util-linux-ng-2.14.1-dep.zip/download上面两个链接，分别下载到两个文件：util-Linux-ng-2.14.1-bin.zip和util-linux-ng-2.14.1-dep.zip我们需要的文件，getopt.exe文件在util-linux-ng-2.14.1-bin.zip文件中的bin目录下，libintl3.dll也在util-linux-ng-2.14.1-dep.zip文件的bin目录下，将这两个文件拷贝到msysgit安装目录的bin目录下。 然后打开“git Bash”输入下面的命令：1$ git clone --recursive git://github.com/nvie/gitflow.git 等下载完毕，打开windows下的命令行工具，进入到刚才下载的文件目录中，例如：如果刚才是在c盘下执行的git clone命令，则进入到F:\\Front-End\\gitflow目录，然后执行下面命令（可能需要管理员权限）F:\\Front-End\\gitflow&gt; contrib\\msysgit-install.cmd如下图：出现MsysGit installation directory not found不用管 执行完毕，打开“Git Bash”，输入命令 git flow，若安装成功，出现下图界面： 如果你看到这，恭喜，你完成了，接下来，享受gitflow吧。 2 clone项目并初始化git flow1234git clone https://github.com/Tours4Fun/yiifrontendtff.gitcd yiifrontendtffgit flow init#一路回车 #二、本地开发流程 ##1. 切换到develop分支1git checkout develop ##2. 更新develop分支1git pull origin develop ##3. 基于develop新建分支123git flow feature start proj&#123;项目ID&#125;_&#123;项目简要描述&#125; #假设项目2312: git flow feature start proj2312_update_sitemap ##4. 进行开发123git status #提交前最好先查看修改了哪些文 git add . #添加文件 git commit -m \"update sitemap.xml 注释\" #提交日志 ##5. 完成开发后把分支push到远程:1git push origin feature/proj2312_update_sitemap ##6. 工单上线后可以定义删除本地无用分支(可选):12git branch -d feature/proj2312_update_sitemap git branch -D feature/proj2312_update_sitemap #强制删除 ##7. 常用命令123456git branch #查看本地分支 git checkout branch-name #切换分支 git remote update -p #远程分支拉到本地 git branch -a | grep 关键字 #搜索分支 git branch -m #重命名分支名 git push origin :feature/feature/proj2312_update_sitemap #删除远端分支 ###8. 更多命令更多命令","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"python35安装的各种工具和库（不是模块）","date":"2017-07-31T09:50:33.000Z","path":"2017/07/31/python35安装的各种工具和库（不是模块）/","text":"2017/10/25 ImportError: No module named ‘h5py’ h5py文件是存放两类对象的容器，数据集(dataset)和组(group) ImportError: No module named ‘tf_utils’无此模块，待定 ImportError: No module named ‘Chromosome’2017/10/13 pip install matplotlib(出现问题) 解决方案：安装包的链接https://sourceforge.net/projects/matplotlib/files/matplotlib/matplotlib-1.5.2/matplotlib-1.5.0-cp35-none-win_amd64.whl 将下载的numpy包拷贝到D:\\路径\\Python35\\Scripts下（不知道怎么回事只有在这个目录下 pip安装命令才好使） pip install “[numpy包名称]” 12C:\\Users\\hasee\\AppData\\Local\\Programs\\Python\\Python35\\Scripts&gt;pip install &quot;matplotlib-1.5.0-cp35-none-win_amd64.whl&quot; 注意： ① numpy包名称要加英文双引号。② 下载的 numpy 包要拷贝到Python安装目录下的scripts文件夹下，如D:\\路径\\Python35\\Scripts下，因为只有在这个目录下 pip安装命令才好使。这样就成功了 pip install -U scikit-learn中-U是？？？pip install -h 就有说明了，就是 –upgrade，意思是如果已安装就升级到最新版。 Python是最为流行的，原因可能和它的快捷有关，而python常用的数值计算，特别是和矩阵操作、优化等有关的数值计算可以用numpy、scipy、theano等包实现。一个简单的在Linux下安装这些包的方法就是安装Anaconda了。使用方法 selenium pip install jupyter 安装完成后，默认安装在pythonXX/scripts 我的安装在C:\\Users\\hasee\\AppData\\Local\\Programs\\Python\\Python35\\Scripts 使用方法 pip install pandas安装完成后如何优雅的安装Python的pandas? scikit-learn 如果已经安装好numpy和scipy，最便捷的安装scikit-learn的方式就是通过pip:[站外图片上传中……(3)] scipy PyQuery pip install config pip install pymongo","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"4吴恩达Meachine-Learing之多变量线性回归(Linear-Regression-with-Multiple-Variables","date":"2017-07-31T09:50:33.000Z","path":"2017/07/31/4吴恩达Meachine-Learing之多变量线性回归(Linear-Regression-with-Multiple-Variables/","text":"4.1 多维特征（Multiple Features）目前为止，我们探讨了单变量/特征的回归模型，现在我们对房价模型增加更多的特征，例如房间数楼层等，构成一个含有多个变量的模型，模型中的特征为（x1,x2,…,xn）。 增添更多特征后，我们引入一系列新的注释： 此时模型中的参数是一个n+1 维的向量，任何一个训练实例也都是n+1 维的向量，特征矩阵X 的维度是 m*(n+1)。 因此公式可以简化为： 其中上标T代表矩阵转置 多变量梯度下降（Gradient Descent for Multiple Variables）与单变量线性回归类似，在多变量线性回归中，我们也构建一个代价函数，则这个代价函数是所有建模误差的平方和，即： 梯度下降法实践 1-特征缩放（Gradient Descent in Practice I - Feature Scaling）在我们面对多维特征问题的时候，我们要保证这些特征都具有相近的尺度，这将帮助梯度下降算法更快地收敛。以房价问题为例，假设我们使用两个特征，房屋的尺寸和房间的数量，尺寸的值为 0-2000 平方英尺，而房间数量的值则是 0-5，以两个参数分别为横纵坐标，绘制代价函数的等高线图能，看出图像会显得很扁，梯度下降算法需要非常多次的迭代才能收敛。 解决的方法是尝试将所有特征的尺度都尽量缩放到-1 到 1 之间。如图 4.4 梯度下降法实践 2-学习率（ 4 - 4 - Gradient Descent in Practice II - Learning Rate ） 4.5 特征和多项式回归（Features and Polynomial Regression）如房价预测问题， 通常我们需要先观察数据然后再决定准备尝试怎样的模型。 另外，我们可以令： 从而将模型转化为线性回归模型。根据函数图形特性，我们还可以使： 4.6 正规方程到目前为止，我们都在使用梯度下降算法，但是对于某些线性回归问题，正规方程方法是更好的解决方案。如： 即： 运用正规方程法求解参数： 总结一下，只要特征变量的数目并不大，标准方程是一个很好的计算参数 θ 的替代方法。具体地说，只要特征变量数量小于一万，我通常使用标准方程法，而不使用梯度下降法。随着我们要讲的学习算法越来越复杂，例如，当我们讲到分类算法，像逻辑回归算法，我们会看到， 实际上对于那些算法，并不能使用标准方程法。对于那些更复杂的学习算法，我们将不得不仍然使用梯度下降法。因此，梯度下降法是一个非常有用的算法，可以用在有大量特征变量的线性回归问题。或者我们以后在课程中，会讲到的一些其他的算法，因为标准方程法不适合或者不能用在它们上。但对于这个特定的线性回归模型，标准方程法是一个比梯度下降法更快的替代算法。所以，根据具体的问题，以及你的特征变量的数量，这两种算法都是值得学习的。 课程代码：https://github.com/HuangCongQing/MachineLearning_Ng本文参考自-黄海广博士 斯坦福大学 2014机器学习教程中文 笔记链接：http://pan.baidu.com/s/1dF2asvf 密码：1ewf 分享吴恩达机器学习视频 下载 链接：链接： http://pan.baidu.com/s/1pKLATJl 密码： xn4w 好看的人儿，点个喜欢❤ 你会更好看哦~~","tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"}]},{"title":"基于python3连接mysql，实现一个银行转账的小功能（shell中执行）","date":"2017-07-31T09:50:33.000Z","path":"2017/07/31/基于python3连接mysql，实现一个银行转账的小功能（shell中执行）/","text":"基于python3连接mysql，实现一个银行转账的小功能（shell中执行） 准备工作：首先我创建了 imooc的数据库 名字为account的表 表里面键值（acctid,money） 下面是代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# -*- coding: utf-8 -*-# @Author: hasee# @Date: 2017-11-02 21:30:11# @Last Modified by: 重庆# @Last Modified time: 2017-11-02 21:30:43#coding=utf-8import pymysql import sys class TransferMoney: def __init__(self,conn): self.conn = conn def check_acct_available(self, acctid): try: cursor = self.conn.cursor() sql = &quot;select * from account where acctid= %s &quot; % acctid cursor.execute(sql) print (&quot;check_acct_available:&quot; + sql) rs = cursor.fetchall() if len(rs) != 1: raise Exception(&quot;账号%s 不存在&quot; % acctid) finally: cursor.close() def has_enough_money(self, acctid, money): try: cursor = self.conn.cursor() sql = &quot;select * from account where acctid=%s and money&gt;=%s&quot; % (acctid,money) cursor.execute(sql) print (&quot;has_enough_money:&quot; + sql) rs = cursor.fetchall() if len(rs) != 1: raise Exception(&quot;账号%s余额不足 is not enough&quot; % acctid) finally: cursor.close() def reduce_money(self, acctid, money): try: cursor = self.conn.cursor() sql = &quot;update account set money= money-%s WHERE acctid=%s &quot; % (money,acctid) cursor.execute(sql) print (&quot;reduce_money:&quot; + sql) rs = cursor.rowcount if rs != 1: raise Exception(&quot;账号%s付款失败Eend is not enough&quot; % acctid) finally: cursor.close() def add_money(self, acctid, money): try: cursor = self.conn.cursor() sql = &quot;update account set money= money+%s WHERE acctid=%s &quot; % (money,acctid) cursor.execute(sql) print(&quot;add_money:&quot; + sql) rs = cursor.rowcount if rs != 1: raise Exception(&quot;账号%s收款失败(Payment failure)get is not enough&quot; % acctid) finally: cursor.close() def transfer(self, source_acctid, target_acctid, money): try: self.check_acct_available(source_acctid) self.check_acct_available(target_acctid) self.has_enough_money(source_acctid,money) self.reduce_money(source_acctid,money) self.add_money(target_acctid,money) self.conn.commit() except Exception as e: self.conn.rollback() raise e if __name__==&quot;__main__&quot;: ## print(&quot;sys.argv[1:]:&quot;,sys.argv[1:]) source_acctid = sys.argv[1] # 汇款发送账户 target_acctid = sys.argv[2] # 收款账户 money = sys.argv[3] conn = pymysql.connect( host = &apos;127.0.0.1&apos;, port = 3306, user = &apos;root&apos;, passwd = &apos;123456&apos;, db = &apos;imooc&apos;, charset = &apos;utf8&apos; ) tr_money = TransferMoney(conn) try: tr_money.transfer(source_acctid,target_acctid,money) except Exception as e: print(&quot;出现问题(There is a problem)：&quot; + str(e)) finally: conn.close() 注意此代码只能在shell命令行中运行，否则会报类似如下错误：sys.argv[3] IndexError: list index out of range 原因是：需要在命令行输入参数，否则，就会报错 下面是运行结果（账户1转给账户2一共3元钱）在XXX.py(mysqlAccount.py)文件目录下运行 python mysqlAccount.py 1 2 3 好看的人儿，点个喜欢❤ 你会更好看哦~~","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"五（七）层互联网协议（计算机网络）深入浅出，看完必懂【图文一】","date":"2017-07-31T09:50:33.000Z","path":"2017/07/31/五（七）层互联网协议（计算机网络）深入浅出，看完必懂【图文一】/","text":"我们每天使用互联网，你是否想过，它是如何实现的？ 全世界几十亿台电脑，连接在一起，两两通信。上海的某一块网卡送出信号，洛杉矶的另一块网卡居然就收到了，两者实际上根本不知道对方的物理位置，你不觉得这是很神奇的事情吗？ 互联网的核心是一系列协议，总称为”互联网协议”（Internet Protocol Suite）。它们对电脑如何连接和组网，做出了详尽的规定。理解了这些协议，就理解了互联网的原理。 下面就是我的学习笔记。因为这些协议实在太复杂、太庞大，我想整理一个简洁的框架，帮助自己从总体上把握它们。为了保证简单易懂，我做了大量的简化，有些地方并不全面和精确，但是应该能够说清楚互联网的原理。 互联网协议入门 一、概述 1.1 五层模型 互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。用户接触到的，只是最上面的一层，根本没有感觉到下面的层。要理解互联网，必须从最下层开始，自下而上理解每一层的功能。如何分层有不同的模型，有的模型分七层，有的分四层。我觉得，把互联网分成五层，比较容易解释。如上图所示，最底下的一层叫做”实体层”（Physical Layer），最上面的一层叫做”应用层”（Application Layer），中间的三层（自下而上）分别是”链接层”（Link Layer）、”网络层”（Network Layer）和”传输层”（Transport Layer）。越下面的层，越靠近硬件；越上面的层，越靠近用户。 它们叫什么名字，其实并不重要。只需要知道，互联网分成若干层就可以了。 1.2 层与协议 每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。 大家都遵守的规则，就叫做“协议”（protocol）。 互联网的每一层，都定义了很多协议。这些协议的总称，就叫做”互联网协议”（Internet Protocol Suite）。它们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。 二、实体层 我们从最底下的一层开始。电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。 这就叫做”实体层”，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。 三、链接层（以太网协议，MAC地址，广播） 3.1 定义 单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？这就是”链接层”的功能，它在”实体层”的上方，确定了0和1的分组方式。 3.2 以太网协议 早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做“以太网”（Ethernet）的协议，占据了主导地位。以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。 “标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。“标头”的长度，固定为18字节。“数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。 3.3 MAC地址 上面提到，以太网数据包的”标头”，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。 每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。 前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。 3.4 广播 定义地址只是第一步，后面还有更多的步骤。首先，一块网卡怎么会知道另一块网卡的MAC地址？ 回答是有一种ARP协议，可以解决这个问题。这个留到后面介绍，这里只需要知道，以太网数据包必须知道接收方的MAC地址，然后才能发送。 其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？ 回答是以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。 上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的”标头”，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做“广播”（broadcasting）。 有了数据包的定义、网卡的MAC地址、广播的发送方式，”链接层”就可以在多台计算机之间传送数据了。。。。 接下来是网络层，传输层和应用层，由于简书篇幅有限制，只能分为两篇文章来写了，不好意思哈！下篇链接：五（七）层互联网协议（计算机网络）深入浅出，看完必懂【图文二】 参考链接：互联网协议入门（一）-阮一峰 好看的人儿，点个喜欢❤ 你会更好看哦~~","tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://yoursite.com/tags/网络协议/"}]},{"title":"五（七）层互联网协议（计算机网络）深入浅出，看完必懂【图文二】","date":"2017-07-31T09:50:33.000Z","path":"2017/07/31/五（七）层互联网协议（计算机网络）深入浅出，看完必懂【图文二】/","text":"接上文：五（七）层互联网协议（计算机网络）深入浅出，看完必懂【图文一】 四、网络层 4.1 网络层的由来以太网协议，依靠MAC地址发送数据。理论上，单单依靠MAC地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。但是，这样做有一个重大的缺点。以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。互联网是无数子网络共同组成的一个巨型网络，很像想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。 因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。（”路由”的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文不涉及。）遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。 这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。 于是，”网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。 网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。 4.2 IP协议 规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。 互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。 但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。 那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数”子网掩码”（subnet mask）。 所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。 知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。 比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。 4.3 IP数据包 根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。但是前面说过，以太网数据包只包含MAC地址，并没有IP地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？回答是不需要，我们可以把IP数据包直接放进以太网数据包的”数据”部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。具体来说，IP数据包也分为”标头”和”数据”两个部分。“标头”部分主要包括版本、长度、IP地址等信息，”数据”部分则是IP数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样。IP数据包的”标头”部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的”数据”部分，最长为65,515字节。前面说过，以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。 4.4 ARP协议（得到对方的MAC地址） 关于”网络层”，还有最后一点需要说明。 因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。 所以，我们需要一种机制，能够从IP地址得到MAC地址。 这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。 第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。 总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。 五、传输层(UDP协议，TCP协议) 5.1 传输层的由来 有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？ 也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。“端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。“传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做”套接字”（socket）。有了它，就可以进行网络应用程序开发了。 5.2 UDP协议现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。UDP数据包，也是由”标头”和”数据”两部分组成。“标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的”数据”部分，而前面说过，IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样：[图片上传中。。。（6）]UDP数据包非常简单，”标头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。 5.3 TCP协议 UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。TCP数据包和UDP数据包一样，都是内嵌在IP数据包的”数据”部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。 六、应用层 应用程序收到”传输层”的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。“应用层”的作用，就是规定应用程序的数据格式。举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。这是最高的一层，直接面对用户。它的数据就放在TCP数据包的”数据”部分。因此，现在的以太网的数据包就变成下面这样。至此，整个互联网的五层结构，自下而上全部讲完了。这是从系统的角度，解释互联网是如何构成的。下一篇，我反过来，从用户的角度，自上而下看看这个结构是如何发挥作用，完成一次网络数据交换的。 参考链接：互联网协议入门（一）-阮一峰 好看的人儿，点个喜欢❤ 你会更好看哦~~","tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://yoursite.com/tags/网络协议/"}]},{"title":"五（七）层互联网协议（计算机网络）深入浅出，看完必懂【图文三】","date":"2017-07-31T09:50:33.000Z","path":"2017/07/31/五（七）层互联网协议（计算机网络）深入浅出，看完必懂【图文三】/","text":"五（七）层互联网协议（计算机网络）深入浅出，看完必懂【图文一】五（七）层互联网协议（计算机网络）深入浅出，看完必懂【图文二】 上两篇文章分析了互联网的总体构思，从下至上，每一层协议的设计思想。 这是从设计者的角度看问题，今天我想切换到用户的角度，看看用户是如何从上至下，与这些协议互动的。 （接上文） 七、一个小结先对前面的内容，做一个小结。我们已经知道，网络通信就是交换数据包。电脑A向电脑B发送一个数据包，后者收到了，回复一个数据包，从而实现两台电脑之间的通信。数据包的结构，基本上是下面这样：发送这个包，需要知道两个地址： 对方的MAC地址 对方的IP地址 有了这两个地址，数据包才能准确送到接收者手中。但是，前面说过，MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过网关（gateway）转发。上图中，1号电脑要向4号电脑发送一个数据包。它先判断4号电脑是否在同一个子网络，结果发现不是（后文介绍判断方法），于是就把这个数据包发到网关A。网关A通过路由协议，发现4号电脑位于子网络B，又把数据包发给网关B，网关B再转发到4号电脑。1号电脑把数据包发到网关A，必须知道网关A的MAC地址。所以，数据包的目标地址，实际上分成两种情况： 场景 数据包地址 同一个子网络 对方的MAC地址，对方的IP地址 非同一个子网络 网关的MAC地址，对方的IP地址 发送数据包之前，电脑必须判断对方是否在同一个子网络，然后选择相应的MAC地址。接下来，我们就来看，实际使用中，这个过程是怎么完成的。 八、用户的上网设置 8.1 静态IP地址 你买了一台新电脑，插上网线，开机，这时电脑能够上网吗？通常你必须做一些设置。有时，管理员（或者ISP）会告诉你下面四个参数，你把它们填入操作系统，计算机就能连上网了： 本机的IP地址 子网掩码 网关的IP地址 DNS的IP地址 下图是Windows系统的设置窗口。这四个参数缺一不可，后文会解释为什么需要知道它们才能上网。由于它们是给定的，计算机每次开机，都会分到同样的IP地址，所以这种情况被称作”静态IP地址上网”。但是，这样的设置很专业，普通用户望而生畏，而且如果一台电脑的IP地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用”动态IP地址上网”。 8.2 动态IP地址 所谓”动态IP地址”，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做DHCP协议。这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做”DHCP服务器”。新的计算机加入网络，必须向”DHCP服务器”发送一个”DHCP请求”数据包，申请IP地址和相关的网络参数。前面说过，如果两台计算机在同一个子网络，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？DHCP协议做了一些巧妙的规定。 8.3 DHCP协议 首先，它是一种应用层协议，建立在UDP协议之上，所以整个数据包是这样的： （1）最前面的”以太网标头”，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。 （2）后面的”IP标头”，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。 （3）最后的”UDP标头”，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。 接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。 8.4 上网设置：小结 这个部分，需要记住的就是一点：不管是”静态IP地址”还是”动态IP地址”，电脑上网的首要步骤，是确定四个参数。这四个值很重要，值得重复一遍： 本机的IP地址 子网掩码 网关的IP地址 DNS的IP地址 有了这几个数值，电脑就可以上网”冲浪”了。接下来，我们来看一个实例，当用户访问网页的时候，互联网协议是怎么运作的。 九、一个实例：访问网页 9.1 本机参数 我们假定，经过上一节的步骤，用户设置好了自己的网络参数： 本机的IP地址：192.168.1.100 子网掩码：255.255.255.0 网关的IP地址：192.168.1.1 DNS的IP地址：8.8.8.8 然后他打开浏览器，想要访问Google，在地址栏输入了网址：www.google.com。这意味着，浏览器要向Google发送一个网页请求的数据包。 9.2 DNS协议 我们知道，发送数据包，必须要知道对方的IP地址。但是，现在，我们只知道网址www.google.com，不知道它的IP地址。DNS协议可以帮助我们，将这个网址转换成IP地址。已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包（53端口）。然后，DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。于是，我们知道了对方的IP地址。 9.3 子网掩码 接下来，我们要判断，这个IP地址是不是在同一个子网络，这就要用到子网掩码。已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。这两个结果不相等，所以结论是，Google与本机不在同一个子网络。 因此，我们要向Google发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。 9.4 应用层协议 浏览网页用的是HTTP协议，它的整个数据包构造是这样的：HTTP部分的内容，类似于下面这样：123456789GET / HTTP/1.1 Host: www.google.com Connection: keep-alive User-Agent: Mozilla/5.0 (Windows NT 6.1) ...... Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Encoding: gzip,deflate,sdch Accept-Language: zh-CN,zh;q=0.8 Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3 Cookie: ... ... 我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。 9.5 TCP协议 TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。 9.6 IP协议 然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。 9.7 以太网协议 最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。 9.8 服务器端响应 经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的”HTTP请求”，接着做出”HTTP响应”，再用TCP协议发回来。本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。这个例子就到此为止，虽然经过了简化，但它大致上反映了互联网协议的整个通信过程。 参考链接：互联网协议入门（二）-阮一峰 好看的人儿，点个喜欢❤ 你会更好看哦~~","tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://yoursite.com/tags/网络协议/"}]},{"title":"1吴恩达Meachine-Learing之监督学习和非监督学习","date":"2017-07-31T09:50:33.000Z","path":"2017/07/31/1吴恩达Meachine-Learing之监督学习和非监督学习/","text":"监督学习（Supervised Learning）介绍监督学习。 其基本思想是，监督学习中，对于数据集中的每个数据， 都有相应的正确答案，（训练集） 算法就是基于这些来做出预测。 受监督的学习问题分为“回归”和“分类”问题。 回归（连续） 分类（离散） 在回归问题中，我们试图在连续输出中预测结果，这意味着我们正在尝试将输入变量映射到一些连续函数。在分类问题中，我们试图用离散输出来预测结果。换句话说，我们正在尝试将输入变量映射到离散类别。 后面介绍了回归问题。 即通过回归来预测一个连续值输出。 我们还谈到了分类问题， 目标是预测离散值输出。 示例2： （a）回归 - 鉴于一个人的照片，我们必须根据给定的图片来预测他们的年龄 （b）分类 - 鉴于肿瘤患者，我们必须预测肿瘤是恶性还是良性（非黑即白//0|1）。 注意： 在一些学习问题中，不希望只用3,5种特征，相反，想用无限多种特征，好让算法利用大量的特征来做推测。那你怎么处理无限特征，甚至怎么存储这些特征都存在问题，你的电脑内存肯定不够用。以后会讲一个算法，叫支持向量机，里面有一个巧妙的数学技巧，能让计算机处理无限多个特征 非监督学习（Unsupervised Learning） 无监督学习使我们能够很少或不知道我们的结果应该如何处理问题。我们可以从数据导出结构，我们不一定知道变量的影响。 在上一节中 我们已经讲过了监督学习 回想起上次的数据集 每个样本 都已经被标明为 正样本或者负样本 即良性或恶性肿瘤 。因此 对于监督学习中的每一个样本 我们已经被清楚地告知了 什么是所谓的正确答案 即它们是良性还是恶性 。在无监督学习中 我们用的数据会和监督学习里的看起来有些不一样在无监督学习中没有“属性或标签这一概念” 也就是说所有的数据 都是一样的 没有区别 我们可以通过基于数据中的变量之间的关系对数据进行聚类来导出该结构。 无监督学习算法 ，针对数据集，自动的找出数据中的结构，会把这些数据分成两个不同的簇，所以叫做聚类算法 无监督学习或聚类算法在其他领域也有着大量的应用 ，例如谷歌新闻每天手机非常多的新闻内容，然后把同一主题的放在一起 例：聚类：收集100万个不同的基因，并找到一种自动将这些基因组合成不同变量（如寿命，位置，作用等）相似或相关的组。 其实聚类只是无监督学习的一种，还有一种非聚类算法 非聚类：“鸡尾酒会算法”，让您在混乱的环境中找到结构。（即从鸡尾酒会的声音网格中识别个人的声音和音乐）。 以上就是监督学习和非监督学习的全部内容，大家有疑问的，欢迎提问！课程代码：https://github.com/HuangCongQing/MachineLearning_Ng本文参考自-黄海广博士 斯坦福大学 2014机器学习教程中文 笔记链接：http://pan.baidu.com/s/1dF2asvf 密码：1ewf 分享吴恩达机器学习视频 下载 链接： 链接： http://pan.baidu.com/s/1pKLATJl 密码： xn4w好看的人儿，点个喜欢❤ 你会更好看哦~~","tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"}]},{"title":"2吴恩达Meachine-Learing之单变量线性回归(Linear-Regression-with-One-Variable","date":"2017-07-31T09:50:33.000Z","path":"2017/07/31/2吴恩达Meachine-Learing之单变量线性回归(Linear-Regression-with-One-Variable/","text":"我们的第一个学习算法是线性回归算法。在这段视频中，你会看到这个算法的概况，更重要的是你将会了解监督学习过程完整的流程。 模型表示（Model Representation）让我们通过一个例子来开始：这个例子是预测住房价格的，我们要使用一个数据集，数据集包含俄勒冈州波特兰市的住房价格。比方说，如果你朋友的房子是 1250 平方尺大小，你要告诉他们这房子能卖多少钱。它被称作监督学习是因为对于每个数据来说，我们给出了“正确的答案”，即告诉我们：根据我们的数据来说，房子实际的价格是多少，而且，更具体来说，这是一个回归问题。回归一词指的是，我们根据之前的数据预测出一个准确的输出值，对于这个例子就是价格，同时，还有另一种最常见的监督学习方式，叫做分类问题，当我们想要预测离散的输出值，例如，我们正在寻找癌症肿瘤，并想要确定肿瘤是良性的还是恶性的，这就是 0/1 离散输出的问题。更进一步来说，在监督学习中我们有一个数据集，这个数据集被称训练集。 我将在整个课程中用小写的 m 来表示训练样本的数目。 以之前的房屋交易问题为例，假使我们回归问题的训练集（Training Set）如下表所示： m 代表训练集中实例的数量 x 代表特征/输入变量 y 代表目标变量/输出变量 (x,y) 代表训练集中的实例 ( x(i),y(i) ) 代表第 i 个观察实例 h 代表学习算法的解决方案或函数也称为假设（hypothesis） 我将选择最初的使用规则 h 代表 hypothesis，因而，要解决房价预测问题，我们实际上是要将训练集“喂”给我们的学习算法，进而学习得到一个假设 h，然后将我们要预测的房屋的尺寸作为输入变量输入给 h，预测出该房屋的交易价格作为输出变量输出为结果。那么，对于我们的房价预测问题，我们该如何表达 h？ 一种可能的表达方式为： 因为只含有一个特征/输入变量，因此这样的问题叫作单变量线性回归问题。 代价函数在这段视频中我们将定义代价函数的概念，这有助于我们弄清楚如何把最有可能的直线与我们的数据相拟合。如图 在线性回归中我们有一个像这样的训练集，m 代表了训练样本的数量，比如 m = 47。而我们的假设函数，也就是用来进行预测的函数，是这样的线性函数形式： 接下来我们会引入一些术语我们现在要做的便是为我们的模型选择合适的参数（parameters）θ0 和 θ1，在房价问题这个例子中便是直线的斜率和在 y 轴上的截距。 我们选择的参数决定了我们得到的直线相对于我们的训练集的准确程度，模型所预测的值与训练集中实际值之间的差距（下图中蓝线所指）就是建模误差（modeling error）。 我们的目标便是选择出可以使得建模误差的平方和能够最小的模型参数。 即使得代价函数 最小。 我们绘制一个等高线图，三个坐标分别为 θ0 和 θ1 和 J(θ0,θ1)： 则可以看出在三维空间中存在一个使得 J(θ0,θ1)最小的点。代价函数也被称作平方误差函数，有时也被称为平方误差代价函数。我们之所以要求出误差的平方和，是因为误差平方代价函数，对于大多数问题，特别是回归问题，都是一个合理的选择。还有其他的代价函数也能很好地发挥作用，但是平方误差代价函数可能是解决回归问题最常用的手段了。 也许这个函数J(θ0,θ1)有点抽象，可能你仍然不知道它的内涵，在接下来的几个视频里，我们要更进一步解释代价函数J 的工作原理 ，并尝试更直观地解释它在计算什么，以及我们使用它的目的。 代价函数的直观理解在上一个视频中，我们给了代价函数一个数学上的定义。在这个视频里，让我们通过一些例子来获取一些直观的感受，看看代价函数到底是在干什么。 当然，我们真正需要的是一种有效的算法，能够自动地找出这些使代价函数 J 取最小值的参数 θ0 和 θ1 来。我们也不希望编个程序把这些点画出来，然后人工的方法来读出这些点的数值，这很明显不是一个好办法。我们会遇到更复杂、更高维度、更多参数的情况，而这些情况是很难画出图的，因此更无法将其可视化，因此我们真正需要的是编写程序来找出这些最小化代价函数的 θ0 和 θ1 的值，在下一节视频中，我们将介绍一种算法，能够自动地找出能使代价函数J 最小化的参数 θ0 和 θ1 的值。 梯度下降Gradient Descent（自动地找出能使代价函数J 最小化的参数 θ0 和 θ1 的值）梯度下降是一个用来求函数最小值的算法，我们将使用梯度下降算法来求出代价函数J(θ0,θ1) 的最小值。 梯度下降背后的思想是：开始时我们随机选择一个参数的组合（θ0,θ1,…,θn），计算代价函数，然后我们寻找下一个能让代价函数值下降最多的参数组合。我们持续这么做直到到到一个局部最小值（local minimum），因为我们并没有尝试完所有的参数组合，所以不能确定我们得到的局部最小值是否便是全局最小值（global minimum），选择不同的初始参数组合，可能会找到不同的局部最小值。 想象一下你正站立在山的这一点上，站立在你想象的公园这座红色山上，在梯度下降算法中，我们要做的就是旋转 360 度，看看我们的周围，并问自己要在某个方向上，用小碎步尽快下山。这些小碎步需要朝什么方向？如果我们站在山坡上的这一点，你看一下周围，你会发现最佳的下山方向，你再看看周围，然后再一次想想，我应该从什么方向迈着小碎步下山？然后你按照自己的判断又迈出一步，重复上面的步骤，从这个新的点，你环顾四周，并决定从什么方向将会最快下山，然后又迈进了一小步，并依此类推，直到你接近局部最低点的位置。 批量梯度下降（batch gradient descent）算法的公式为： 其中 α 是学习率（learning rate），它决定了我们沿着能让代价函数下降程度最大的方向向下迈出的步子有多大，在批量梯度下降中，我们每一次都同时让所有的参数减去学习速率乘以代价函数的导数。 在梯度下降算法中，还有一个更微妙的问题，梯度下降中，我们要更新 θ0 和 θ1 ，当 j=0和 j=1 时，会产生更新，所以你将更新 Jθ0 和 Jθ1。实现梯度下降算法的微妙之处是，在这个表达式中，如果你要更新这个等式，你需要同时更新 θ0 和 θ1，我的意思是在这个等式中，我们要这样更新：θ0:= θ0 ，并更新 θ1:= θ1。实现方法是：你应该计算公式右边的部分，通过那一部分计算出 θ0 和 θ1 的值，然后同时更新 θ0 和 θ1。让我进一步阐述这个过程： 在梯度下降算法中，这是正确实现同时更新的方法。我不打算解释为什么你需要同时更新，同时更新是梯度下降中的一种常用方法。我们之后会讲到，同步更新是更自然的实现方法。当人们谈到梯度下降时，他们的意思就是同步更新。在接下来的视频中，我们要进入这个微分项的细节之中。我已经写了出来但没有真正定义，如果你已经修过微积分课程，如果你熟悉偏导数和导数，这其实就是这个微分项： 如果你不熟悉微积分，不用担心，即使你之前没有看过微积分，或者没有接触过偏导数在接下来的视频中，你会得到一切你需要知道，如何计算这个微分项的知识。下一个视频中，希望我们能够给出实现梯度下降算法的所有知识 。 梯度下降的直观理解在之前的视频中，我们给出了一个数学上关于梯度下降的定义，本次视频我们更深入研究一下，更直观地感受一下这个算法是做什么的，以及梯度下降算法的更新过程有什么意义。梯度下降算法如下图： 描述：对 θ 赋值，使得 J(θ)按梯度下降最快方向进行，一直迭代下去，最终得到局部最小值。其中 α 是学习率（learning rate），它决定了我们沿着能让代价函数下降程度最大的方向向下迈出的步子有多大。 对于这个问题，求导的目的，基本上可以说取这个红点的切线，就是这样一条红色的直线，刚好与函数相切于这一点，让我们看看这条红色直线的斜率，就是这条刚好与函数曲线相切的这条直线，这条直线的斜率正好是这个三角形的高度除以这个水平长度，现在，这条线有一个正斜率，也就是说它有正导数，因此，我得到的新的 θ1，θ1 更新后等于 θ1 减去一个正数乘以 α。这就是我梯度下降法的更新规则： 让我们来看看如果 α 太小或 α 太大会出现什么情况：如果 α 太小了，即我的学习速率太小，结果就是只能这样像小宝宝一样一点点地挪动，去努力接近最低点，这样就需要很多步才能到达最低点，所以如果 α 太小的话，可能会很慢因为它会一点点挪动，它会需要很多步才能到达全局最低点。 如果 α 太大，那么梯度下降法可能会越过最低点，甚至可能无法收敛，下一次迭代又移动了一大步，越过一次，又越过一次，一次次越过最低点，直到你发现实际上离最低点越来越远，所以，如果 α 太大，它会导致无法收敛，甚至发散。 现在，我还有一个问题，当我第一次学习这个地方时，我花了很长一段时间才理解这个问题，如果我们预先把 θ1放在一个局部的最低点，你认为下一步梯度下降法会怎样工作？ 假设你将 θ1初始化在局部最低点，在这儿，它已经在一个局部的最优处或局部最低点。结果是局部最优点的导数将等于零，因为它是那条切线的斜率。这意味着你已经在局部最优点，它使得 θ1不再改变，也就是新的 θ1等于原来的 θ1，因此，如果你的参数已经处于局部最低点，那么梯度下降法更新其实什么都没做，它不会改变参数的值。这也解释了为什么即使学习速率 α 保持不变时，梯度下降也可以收敛到局部最低点。 在接下来的视频中，我们要用代价函数 J，回到它的本质，线性回归中的代价函数。也就是我们前面得出的平方误差函数，结合梯度下降法，以及平方代价函数，我们会得出第一个机器学习算法，即线性回归算法。 梯度下降的线性回归在以前的视频中我们谈到关于梯度下降算法，梯度下降是很常用的算法，它不仅被用在线性回归上和线性回归模型、平方误差代价函数。在这段视频中，我们要将梯度下降和代价函数结合。我们将用到此算法，并将其应用于具体的拟合直线的线性回归算法里。 梯度下降算法和线性回归算法比较如图： 对我们之前的线性回归问题运用梯度下降法，关键在于求出代价函数的导数，即： 则算法改写成： 我们刚刚使用的算法，有时也称为批量梯度下降。实际上，在机器学习中，通常不太会给算法起名字，但这个名字”批量梯度下降”，指的是在梯度下降的每一步中，我们都用到了所有的训练样本，在梯度下降中，在计算微分求导项时，我们需要进行求和运算，所以，在每一个单独的梯度下降中，我们最终都要计算这样一个东西，这个项需要对所有 m 个训练样本求和。因此，批量梯度下降法这个名字说明了我们需要考虑所有这一”批”训练样本，而事实上，有时也有其他类型的梯度下降法，不是这种”批量”型的，不考虑整个的训练集，而是每次只关注训练集中的一些小的子集。在后面的课程中，我们也将介绍这些方法。但就目前而言，应用刚刚学到的算法，你应该已经掌握了批量梯度算法，并且能把它应用到线性回归中了，这就是用于线性回归的梯度下降法。 课程代码：https://github.com/HuangCongQing/MachineLearning_Ng本文参考自-黄海广博士 斯坦福大学 2014机器学习教程中文 笔记链接：http://pan.baidu.com/s/1dF2asvf 密码：1ewf 分享吴恩达机器学习视频 下载 链接： 链接： http://pan.baidu.com/s/1pKLATJl 密码： xn4w好看的人儿，点个喜欢❤ 你会更好看哦~~","tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"}]},{"title":"各种邮箱pop，SMTP设置","date":"2017-07-31T09:50:33.000Z","path":"2017/07/31/各种邮箱pop，SMTP设置/","text":"看到很多用户在绑定邮箱时出现各种各样的问题，特将主流邮箱的配置问题汇总,供大家参考也供自己参考 首先向大家简单介绍一下尚邮绑定邮箱的注意事项： 1、请先确认您的邮箱支持pop3只要支持pop3或者imap4协议的公众邮箱和企业邮箱都可以使用尚邮。 目前大多数免费公众邮箱都支持pop功能，但是部分需要要手动开启（在本文的后面我们会针对几个常见的公众邮箱开通POP服务以及服务器配置方式进行介绍）。确认您的邮箱支持pop3或者imap4协议后您就可以绑定邮箱了 新浪(sina)邮箱配置方法及介绍新浪邮箱自今年（08年）6月分服务器被攻击后开始对pop取件频率进行了严格限制，同时新注册的用户需要手动才能开通pop功能（老用户不需要）。 手动开通pop的方法：登录新浪邮箱后点击“邮箱设置”-“帐户”-“pop-smtp设置”勾选“开启”后“保存”，如图所示：服务器配置方法： 类型： POP3接收邮件服务器： pop.sina.com 接收端口： 110 SSL 否发送邮件服务器： smtp.sina.com 发送端口： 25 SSL 否 QQ邮箱配置方法及介绍登陆您的QQ邮箱页面后点击页面上方的“设置”-“账号”-“POP3/SMTP服务”勾选“开启POP3/SMTP服务”后“保存修改”服务器配置方法：类型： POP3接收邮件服务器： pop.qq.com 接收端口： 110 SSL 否发送邮件服务器： smtp.qq.com发送端口： 25 SSL 否补充说明：由于QQ邮箱服务器与尚邮服务器之间的通讯速度受到网通与电信间冲突的影响，经常出现通讯超时的情况，因此即便绑定成功也会延迟较为严重。另外，QQ邮箱服务器也开始对pop频次进行限制，一旦超过会被拖入黑名单。由于尚邮的腾讯用户非常多，为解决此问题已与腾讯进行协商，将pop频次上线提高，但若添加人数很多仍会超限。因此如果您的QQ邮箱已开通pop功能但仍添加失败，很可能是pop超限导致的。基于如上几点因素，QQ邮箱在尚邮上的用户体验不是很好，不推荐您使用。建议您将QQ邮箱邮件转发至其他支持pop的邮箱上代收。 网易(126/163/yeah.net)邮箱配置方法及介绍 网易免费邮箱对pop取信频率有严格的限制，因此相对取信速度比较慢。网易免费邮箱中126和163邮箱06年后注册的以及yeah.net邮箱07年后的注册用户不再支持pop功能，需要定制其“随身邮服务”方可开通，老用户本身就是支持pop功能的，无需定制。 126邮箱配置方法：类型： POP3接收邮件服务器： pop.126.com接收端口： 110 SSL 否发送邮件服务器： smtp.126.com发送端口： 25 SSL 否特别说明：如果您确认您的126邮箱开通了POP功能，但还是不能绑定成功，可以尝试在邮箱用户名处填写126邮箱地址全称，再看是否能绑定成功。通常，126邮箱无论使用@符号前内容或者用邮箱全称来填写“邮箱用户名”都可以成功绑定。您可以多尝试下。163邮箱配置方法：类型： POP3接收邮件服务器： pop.163.com接收端口： 110 SSL 否发送邮件服务器： smtp.163.com发送端口： 25 SSL 否 Gmail邮箱配置方法及介绍Gmail邮箱也需要手动配置pop或者imap功能。 配置方法如下： 登录Gmail邮箱后点击“设置”-“转发和pop smtp”-“pop下载”下勾选“对从现在起所收到的邮件启用pop”或者“IMAP访问”中勾选“启用IMAP”然后“保存更改”POP3配置方法：类型： POP3接收邮件服务器： pop.gmail.com接收端口： 995 SSL 是发送邮件服务器： smtp.gmail.com发送端口：： 587 /25 SSL 是 （465说是可以但是测试总是超时）IMAP配置方法：类型： IMAP4接收邮件服务器： imap.gmail.com接收端口： 993 SSL 是 发送邮件服务器： smtp.gmail.com发送端口： 587 /25 SSL 是 （465说是可以但是测试总是超时 25推荐）补充说明：由于Gmail邮箱服务器本身设置的原因，Gmail邮箱邮件只允许邮件客户端软件pop收取一次，因此尚邮取过的邮件，pc客户端如outlook将收不到，反之亦然。解决方案可以参考二楼“Gmail邮件只POP一次怎么办？ ”贴。另外，Gmail邮箱是将已发送邮件和收到的邮件存放在一起的，所以使用客户端软件收Gmail的邮件会将已发送的邮件一同收取下来。 腾讯企业邮箱POP,SMTP分别是什么我今天想用QQ邮箱代收我的腾讯企业邮箱就遇到这个问题， 上图中如果是腾讯企业邮箱的话：POP地址应填：pop.exmail.qq.com 腾讯企业邮箱POP3/SMTP协议接收邮件服务器：pop.exmail.qq.com (端口 110)，使用SSL，端口号995发送邮件服务器：smtp.exmail.qq.com (端口 25)，使用SSL，端口号465 海外用户可使用以下服务器接收邮件服务器：hwpop.exmail.qq.com (端口 110)，使用SSL，端口号995发送邮件服务器：hwsmtp.exmail.qq.com (端口 25)，使用SSL，端口号465 腾讯企业邮箱IMAP协议接收邮件服务器：imap.exmail.qq.com (端口 143)，使用SSL，端口号993发送邮件服务器：smtp.exmail.qq.com (端口 25)，使用SSL，端口号465 海外用户可使用以下服务器接收邮件服务器：hwimap.exmail.qq.com (端口 143)，使用SSL，端口号993发送邮件服务器：hwsmtp.exmail.qq.com (端口 25)，使用SSL，端口号465 QQ还开发了邮我功能： 我的博客即将搬运同步至腾讯云+社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=v7lccogb0nze","tags":[{"name":"邮箱","slug":"邮箱","permalink":"http://yoursite.com/tags/邮箱/"}]},{"title":"域名解析后主机记录和记录值怎么填写？都是什么意思？","date":"2017-07-31T09:50:33.000Z","path":"2017/07/31/域名解析后主机记录和记录值怎么填写？都是什么意思？/","text":"&gt;之前我买的域名在腾讯云解析之后，需要添加记录，开始一脸懵啊，在网上搜查了一些资料，整理了一下，希望为大家解点惑吧！ 主机记录：主机记录就是域名前缀，常见用法有： www：解析后的域名为 www.1756260160.com @：直接解析主域名 1756260160.com ：泛解析，匹配其他所有域名 *.1756260160.com 记录类型：要指向空间商提供的 IP 地址，选择「类型 A」，要指向一个域名，选择「类型 CNAME」 A记录：地址记录，用来指定域名的IPv4地址（如：8.8.8.8），如果需要将域名指向一个IP地址，就需要添加A记录。 CNAME： 如果需要将域名指向另一个域名，再由另一个域名提供ip地址，就需要添加CNAME记录。 NS：域名服务器记录，如果需要把子域名交给其他DNS服务商解析，就需要添加NS记录。 AAA：用来指定主机名（或域名）对应的IPv6地址（例如：ff06:0:0:0:0:0:0:c3）记录。 MX：如果需要设置邮箱，让邮箱能收到邮件，就需要添加MX记录。 线路：让指定线路的用户访问这个IP常见用法有： 默认：必须添加，否则只有单独指定的线路才能访问您的网站。如果双线解析，建议「默认」线路填写「电信IP」 联通：单独为「联通用户」指定服务器 IP，其他用户依然访问「默认」 搜索引擎：指定一个服务器 IP 让抓取 记录值：最常见的是将空间商提供的「IP地址」填写在这里哦～比如我用的就是github上的IP各类型的记录值一般是这样的：A记录：填写您服务器 IP，如果您不知道，请咨询您的空间商CNAME记录：填写空间商给您提供的域名，例如：2.comMX记录：填写您邮件服务器的IP地址或企业邮局给您提供的域名，如果您不知道，请咨询您的邮件服务提供商AAAA：不常用。解析到 IPv6 的地址。NS记录：不常用。系统默认添加的两个NS记录请不要修改。NS向下授权，填写dns域名，例如：ns3.dnsv3.comTTL: 我们默认的 600 秒是最常用的，不用修改即 Time To Live，缓存的生存时间。指地方dns缓存您域名记录信息的时间，缓存失效后会再次到DNSPod获取记录值。600（10分钟）：建议正常情况下使用 600。60（1分钟）：如果您经常修改IP，修改记录一分钟即可生效。长期使用 60，解析速度会略受影响。 3600（1小时）：如果您IP极少变动（一年几次），建议选择 3600，解析速度快。如果要修改IP，提前一天改为 60，即可快速生效。","tags":[{"name":"域名","slug":"域名","permalink":"http://yoursite.com/tags/域名/"}]},{"title":"3吴恩达Meachine-Learing之线性代数回顾-(Linear-Algebra-Review)","date":"2017-07-31T09:50:33.000Z","path":"2017/07/31/3吴恩达Meachine-Learing之线性代数回顾-(Linear-Algebra-Review)/","text":"本文主要讨论神魔是矩阵和向量，谈谈如何加减乘矩阵及向量，讨论逆矩阵和转置矩阵的概念！！如果十分熟悉这些概念，可以很快的浏览一遍，如果对这些概念有些许的不确定，可以细看一下，慢慢咀嚼！ ##3.1 矩阵和向量 如图 ：这个 ：这个 是 4×2矩阵 ，即 4行 2列，如 m为行， 为行， n为列，那么 为列，那么 为列，那么 m×n即 4×2 矩阵的维数即行数×列数矩阵元素（矩阵项）： ##3.2 加法 和标量乘加法矩阵的加法：行列数相等的可以加。 矩阵的乘法：每个元素都要乘 组合算法也类似。 3.3 矩阵向量乘法矩阵和向量的乘法如图：m×n 的矩阵乘以 n×1 的向量，得到的是 m×1 的向量 算法 举例： 3.4 矩阵乘法矩阵乘法：m×n 矩阵乘以 n×o 矩阵，变成 m×o 矩阵。如果这样说不好理解的话就举一个例子来说明一下，比如说现在有两个矩阵 A 和 B，那么它们的乘积就可以表示为图中所示的形式。 3.5 矩阵乘法的性质矩阵乘法的性质： 矩阵的乘法不满足交换律：A×B≠B×A 矩阵的乘法满足结合律。即：A×（B×C）=（A×B）×C 单位矩阵：在矩阵的乘法中，有一种矩阵起着特殊的作用，如同数的乘法中的 1,我们称这种矩阵为单位矩阵．它是个方阵，一般用 I 或者 E 表示，本讲义都用 I 代表单位矩阵，从左上角到右下角的对角线（称为主对角线）上的元素均为 1 以外全都为 0。如： 对于单位矩阵，有 AI=IA=A3.6 逆、转置矩阵的逆：如矩阵 A 是一个 m×m 矩阵（方阵），如果有逆矩阵，则： 我们一般在 OCTAVE 或者 MATLAB 中进行计算矩阵的逆矩阵。矩阵的转置：设 A 为 m×n 阶矩阵（即 m 行 n 列），第 i 行 j 列的元素是 a(i,j)，即：A=a(i,j)定义 A 的转置为这样一个 n×m 阶矩阵 B，满足 B=a(j,i)，即 b (i,j)=a (j,i)（B 的第 i 行第j 列元素是 A 的第 j 行第 i 列元素），记 AT=B。(有些书记为 A’=B）直观来看，将 A 的所有元素绕着一条从第 1 行第 1 列元素出发的右下方 45 度的射线作镜面反转，即得到 A 的转置。 矩阵的转置基本性质: matlab 中矩阵转置：直接打一撇，x=y’。 课程代码：https://github.com/HuangCongQing/MachineLearning_Ng本文参考自-黄海广博士 斯坦福大学 2014机器学习教程中文 笔记链接：http://pan.baidu.com/s/1dF2asvf 密码：1ewf 分享吴恩达机器学习视频 下载 链接：链接： http://pan.baidu.com/s/1pKLATJl 密码： xn4w 好看的人儿，点个喜欢❤ 你会更好看哦~~","tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"}]},{"title":"在腾讯企业邮箱设置自己的域名邮箱？","date":"2017-07-30T09:50:33.000Z","path":"2017/07/30/在腾讯企业邮箱设置自己的域名邮箱/","text":"第一步 买域名 这一步网上有很多的相关教程，大家可以查阅，自己亦可摸索，增加实践的机会。 如果是大学生，建议大家可以在阿里云或腾讯云里买，有学生优惠， 第二步 注册腾讯企业邮箱账号1.打开浏览器.输入”exmail.qq.com/” 新用户注册 点击立即开通 按域名–填写管理员信息–添加企业邮箱–一步步来就行因为我买的腾讯云的域名，所以方法一直接就能自动设置手动设置也行 上图片自动设置成功 设置基本完成，然后进入你的企业邮箱，就可以添加成员了 好了，这样就大功告成了，好好耍耍吧","tags":[{"name":"邮箱","slug":"邮箱","permalink":"http://yoursite.com/tags/邮箱/"},{"name":"域名","slug":"域名","permalink":"http://yoursite.com/tags/域名/"}]},{"title":"Github自身踩到的坑","date":"2017-07-28T15:36:05.000Z","path":"2017/07/28/Github自身踩到的坑/","text":"用Github有一两年了，是时候总结一下以前踩得坑了，这些坑开始时还真把自己摔得不轻！！！！！小插曲：自己以前用hexo搭建的博客，每次写博客都要新建.md文件等初始化步骤,然后提交，有些繁琐，再加上自己又换了台电脑，又要部署hexo（虽然不需要重新部署），但还是有些步骤，索性用简书写，方便快捷些！ git pull时ssh: Could not resolve hostname github.com: Name or service not known, fatal: Could not read from remote repository.123456$ git pullssh: Could not resolve hostname github.com: Name or service not knownfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 这个错误好醉，是因为没网了，就很皮 git本地仓库首次push到远程仓库出现错误 ! [rejected] master -&gt; master (fetch first)新建好本地的仓库和远程仓库之后， 经过git add .然后git commit -m &quot;......&quot;最后想推送到远程仓库的时候 git push -u origin master出现下图错误 解决很简单，使用强制推送使用下面的命令git push -f origin master 附上git push 的说明12345678910111213141516171819NAMEgit-push - Update remote refs along with associated objectsSYNOPSISgit push [--all | --mirror | --tags] [--follow-tags] [--atomic] [-n | --dry-run] [--receive-pack=&lt;git-receive-pack&gt;] [--repo=&lt;repository&gt;] [-f | --force] [--prune] [-v | --verbose] [-u | --set-upstream] [--[no-]signed|--sign=(true|false|if-asked)] [--force-with-lease[=&lt;refname&gt;[:&lt;expect&gt;]]] [--no-verify] [&lt;repository&gt; [&lt;refspec&gt;…​]]-f --forceUsually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. Also, when --force-with-lease option is used, the command refuses to update a remote ref whose current value does not match what is expected.This flag disables these checks, and can cause the remote repository to lose commits; use it with care.Note that --force applies to all the refs that are pushed, hence using it with push.default set to matching or with multiple push destinations configured with remote.*.push may overwrite refs other than the current branch (including local refs that are strictly behind their remote counterpart). To force a push to only one branch, use a + in front of the refspec to push (e.g git push origin +master to force a push to the master branch). See the&lt;refspec&gt;... section above for details. github上传时出现error: src refspec master does not match any如下： 引起该错误的原因是，目录中没有文件，空目录是不能提交上去的 解决方法:先提交文件git add . git commit -m &quot;&quot;例如下：1234touch READMEgit add README git commit -m &apos;first commit&apos;git push origin master fatal： unable to create ‘../../.git/index.lock’:File exists 解决方法：把文件index.lock删掉 ###Permission denied (publickey).fatal: The remote end hung up unexpectedly 错误原因：github上没有配置公钥解决方法：配置公钥，并放到github上GitHub设置公钥在windows下面 安装git，从程序目录打开 “Git Bash” 键入命令：ssh-keygen -t rsa -C “email@email.com”“email@email.com”是github账号 提醒你输入key的名称，输入如id_rsa如果执行成功。返回 Generating public/private rsa key pair.Enter file in which to save the key (/home/forwhat.cn/.ssh/id_rsa):在这里就是设置存储地址了.反正我是直接按的回车，一直回车 在C:\\Documents and Settings\\Administrator\\下产生两个文件：id_rsa和id_rsa.pub 把4中生成的密钥文件复制到C:\\Documents and Settings\\Administrator.ssh\\ 目 录下。 用记事本打开id_rsa.pub文件，复制内容，在github.com的网站上到ssh密钥管理页面，添加新公钥，随便取个名字例如你的电脑名 需要注意步骤2中产生的密钥文件在当前用户的根目录，必须把这两个文件放到当前用户目录的“.ssh”目录下才能生效。 ————2017/8/14 There is no tracking information for the current branch. Please specify which branch you want to merge with. 是因为本地分支和远程分支没有建立联系 (使用git branch -vv 可以查看本地分支和远程分支的关联关系) .根据命令行提示只需要执行以下命令即可 如果不想新建分支git branch --set-upstream master origin/master 如果想新建分支git branch --set-upstream-to=origin/远程分支的名字 本地分支的名字 git branch –set-upstream-to=origin/develop develop或git branch --set-upstream develop origin/develop（develop为新建分支name）同时推荐大家看一下下面这篇–创建于合并分支https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840038939c291467cc7c747b1810aab2fb8863508000 2018-2-26关闭 pull request（Closing a pull request）因为pull request错了，所以想取消pull request，怎么做呢？看图吧 坑不会踩完的，但会一直进步着，大家加油……","tags":[]},{"title":"Sublime侧边栏[SideBar]字体变大","date":"2017-01-15T08:05:40.000Z","path":"2017/01/15/Sublime侧边栏字体变大/","text":"","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}]},{"title":"MPic神器-上传照片直接生成外链","date":"2017-01-12T06:31:40.000Z","path":"2017/01/12/Mpic神器/","text":"一直以来写博文，上传本地照片是一个特别麻烦的事，一来webstorm收费，其次cmd Markdown上传照片只支持外联，而上传照片到七牛云不失为一个好方法，但操作过程复杂，正在我愁眉不展时，上网一搜，搜到了一神器Mpic-图床神器。可以和七牛云绑定一起发挥威力。下载链接经过自己的一番折腾，最终发现MPic果然省时省事不少，目前我知道的上传方式有2种： 截图上传（QQ截图个人感觉不错） 拖拽本地图片上传下载之后的界面：下面介绍一下下载软件之后的操作步骤： 下载之后首先就是注册账号注意几个问题： 首先你用默认域名时，账户余额应不少于10元; 申请存储空间七牛云自己会带个域名，用这个自带的域名就可以，如下图，当然，用自己绑定的域名也可以，不过域名必须是注册过的，注册很麻烦耗时，不嫌麻烦的也可以试试。 在我的上传中，可查看和删除自己之前上传过的照片 好，大功告成，终于可以好好地写自己的博客，顺带肆意的上传自已的照片了！！哈哈哈","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}]},{"title":"HTML5-canvas之绘制圆弧和贝塞尔曲线(3)","date":"2017-01-01T09:50:33.000Z","path":"2017/01/01/HTML5-canvas之绘制圆弧和贝塞尔曲线/","text":"今天我们主要是学习如何绘制圆弧和贝塞尔曲线。 圆弧的绘制圆弧可以理解为一个圆上的某部分线段，在canvas中，绘制一条圆弧的语法如下：1ctx.arc( 圆心x坐标, 圆心y坐标, 圆的半径r , 开始角度, 结束角度 ); 其中的 “开始角度” 和 “结束角度” 是相对360度的 顺时针 的极坐标而言的，可配合下图理解： 我们来一个例子，绘制一个圆心坐标为(80,80)，半径为40，开始角度为30度，结束角度为90度，那么可以这样绘制：12345678910&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.arc( 80, 80, 40, 1/6*Math.PI, 1/2*Math.PI);ctx.stroke(); //描边&lt;/script&gt; 其中开始角和结束角我们分别设定为“1/6Math.PI”和“1/2Math.PI”，是因为canvas里的角度是以PI（π）为单位的，在js中写作Math.PI，你可以把一个PI理解为180度，那么30度便是1/6个PI。上述代码效果如下： 开始角和结束角也可以是负值，则角度从0度开始以逆时针方式获取：1234var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.arc( 80, 80, 40, -1/6*Math.PI, -1/2*Math.PI);ctx.stroke(); //描边 我们可以很轻松地来绘制一个完整的圆，将起始角设为0度，结束角设为360度（2*Math.PI）即可： 123456789var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.arc( 80, 80, 40, 0, 2*Math.PI);ctx.lineWidth = 3; //描边宽度为3pxctx.strokeStyle = &quot;yellow&quot;;ctx.stroke(); //描边ctx.fillStyle = &quot;#4DA6FF&quot;;ctx.fill(); //填充颜色 注意给圆填充颜色我们使用的是 .fill() 方法，和多边形的填充方式一样。 接着说说 arc() 的好兄弟 arcTo() 方法，它可以在两条线段之间连接起一条弧线，其语法如下 ctx.arcTo( 起点切线末端x坐标, 起点切线末端y坐标, 终点x坐标, 终点y坐标, 圆的半径r ); 可以配合下图理解： 我们先不管什么“连接两条线段”的事情，单纯看下arcTo()绘制了怎样的一条圆弧：1234567891011&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.moveTo(20,20); // 创建开始点ctx.arcTo(60,20,60,60,40); // 创建圆弧路径ctx.stroke(); &lt;/script&gt; 那么我们利用arcTo()方法来连接两条直线吧： 12345678910111213&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.moveTo(20,20);ctx.lineTo(60,20);ctx.arcTo(100,20,100,60,40); // 创建圆弧路径ctx.lineTo(100,100);ctx.stroke(); &lt;/script&gt; 需要知道的是 arc() 不会影响画笔的位置，而 arcTo() 会把画笔移到圆弧线的终点位置。 曲线的绘制无论是arc()抑或arcTo()，均是绘制了一个正圆上的部分圆弧线段，下面讲讲更灵活的曲线的绘制。 首先介绍的是canvas中贝塞尔曲线的绘制。使用过AI等专业矢量制图软件的朋友相信能很好地理解这一部分。我们先看下在制图软件中用钢笔工具绘制一条贝塞尔曲线的过程： 可以看到每两点可以连成一条贝塞尔路径，且每一个点都有一条方位控制线来控制曲线的弯曲程度和走向，在canvas中也是以类似形式控制贝塞尔曲线的形状。 我们先来看看bezierCurveTo()的实现方式，它称作“三次方贝塞尔曲线”，其语法为：1ctx.bezierCurveTo( CSx, CSy, CEx, CEy, Ex, Ey ); 其中CSx、CSy表示贝塞尔曲线起点方向控制线末端的x坐标和y坐标。CEx、CEy表示贝塞尔曲线终点方向控制线末端的x坐标和y坐标。Ex、Ey表示贝塞尔曲线终点坐标。 参考图如下，图中的贝塞尔曲线起点坐标为（20,20），终点坐标为（200,20），起点的方向控制线末端坐标为（20,100），终点的方向控制线末端坐标为（200,100）： 有的朋友可能会问为何bezierCurveTo()方法没有起始点的参数，答案是起始点默认为bezierCurveTo()方法执行之前画笔所在的位置，我们可以通过ctx.moveTo(x,y)来确定起始点的位置。 如上图所示的贝塞尔曲线我们可以这样绘制：1234567891011&lt;canvas id=&quot;myCanvas&quot; width=&quot;300&quot; height=&quot;150&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.moveTo(20,20); //确定起始点ctx.bezierCurveTo( 20, 100, 200, 100, 200, 20 );ctx.stroke(); //描边&lt;/script&gt; 我们可以绘制两条或者多条连在一起的贝塞尔曲线，从而塑造我们想要的曲线： 123456789101112&lt;canvas id=&quot;myCanvas&quot; width=&quot;400&quot; height=&quot;250&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.moveTo(20,120); //确定起始点ctx.bezierCurveTo( 20, 200, 200, 200, 200, 120 ); //绘制第一条贝塞尔曲线ctx.bezierCurveTo( 200, 20, 380, 20, 380, 120 ); //绘制第二条贝塞尔曲线，该曲线起点为上一条曲线终点（200，120）ctx.stroke(); //描边&lt;/script&gt; 使用过矢量制图软件的朋友可能有个地方会困惑，那就是我们很多时候开始绘制一条曲线时（起点不做拉伸），该曲线的起点是没有任何方向控制线的，如下图： 如果我们要绘制一条起点不做方向控制的曲线，那么bezierCurveTo()方法就不再适用了。 针对这种情况，可以通过 quadraticCurveTo() 方法来解决，它称作“二次方贝塞尔曲线”，语法为 ctx.quadraticCurveTo( CEx, CEy, Ex, Ey ); 其中CEx、CEy表示曲线终点方向控制线末端的x坐标和y坐标。Ex、Ey表示曲线终点坐标。至于曲线起点则跟bezierCurveTo()一样，为该方法执行前画笔所在的位置。 我们试着来绘制一条这样的曲线，它是我在AI中用钢笔工具绘制出来的： 它的矢量轮廓是这样的： 由于起点是没有方向控制线的，我们很容易知道得先绘制一条quadraticCurve，然后再紧接着绘制一条bezierCurve来完成这条曲线。 我们先确定下各点的坐标： 然后轻松写出代码： 123456789101112&lt;canvas id=&quot;myCanvas&quot; width=&quot;490&quot; height=&quot;270&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.moveTo(52,37); //确定起始点ctx.quadraticCurveTo( 45, 175, 172, 157 ); //绘制第一条曲线ctx.bezierCurveTo( 298, 140, 337, 201, 312, 236 ); //绘制第二条曲线ctx.stroke(); //描边&lt;/script&gt; 效果杠杠的 建议有兴趣的朋友多实践，其中贝塞尔曲线部分的知识点可以通过AI等矢量设计软件来加深理解。共勉~ 啦啦啦还有，大家元旦快乐啊！ 有关链接 http://www.cnblogs.com/vajoy/p/3925190.html","tags":[{"name":"html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"MySQL在windows下的安装与配置（小白操作图文新）","date":"2016-12-25T09:50:33.000Z","path":"2016/12/25/MySQL在windows下的安装与配置（小白操作图文新）/","text":"MySQL安装官网版本： https://dev.mysql.com/downloads/mysql/5.6.html#downloads 有msi和zip两种下载形式，推荐下载msi这种形式，安装简单我下载的是mysql-5.5.44-winx64.msi 如下图，自己可随意选择对应版本 安装过程注意几点： 安装类型选择Typical-典型安装 安装最后，会有个复选框，询问是否进行MySQL配置操作，可以先不配置，因为等额下我们自己可以进行额外的配置。结果和它是一样的，只需单击finish按钮，如下图 MySQL配置接下来，我们就要进行配置，那么我们要到那个地方进行配置呢？ 首先，我们要找到，配置向导文件，然后点击进入一般情况下，典型安装都是讲文件安装在C:\\Program Files\\MySQL\\MySQL Server 5.5\\bin， 选择配置类型详细配置对于初学者配置特别多，难以掌握，最好选择标准配置，点击Next按钮 是否安装windows服务之后询问是否安装windows服务和配置环境变量，一般情况下是都要勾选的 设置root用户和密码 准备执行设置选项觉得哪一步需要修改，可以back回去修改，各方面确认好之后，就可以点击Execute按钮 配置完成 上图中，第二个选项Write configuration file，写入配置文件，存储在安装目录下my.ini第三个选项，Start Service，当前启动你的服务，因为刚才已经设置为windows的一个服务 下面验证一下 配置文件my.ini存不存在, windows服务中是否存在MySQL的一个服务 右键点击“我的电脑”，在弹出的快捷菜单中选择“管理”，打开“计算机管理” 可以看到MySQL服务已启动 到此为止，我们已经完成了最简单的配置,如果要进行其他的配置，我们就需要了解MySQL目录结构了， 下图就很好地表示各目录的功能： 除了通过配置向导的图形化界面来配置，我们还可以来修改配置文件来实现 标准配置当中没有的编码方式配置文件在哪呢？ 就是我们刚才提到的bin文件夹下的my.ini 在my.ini文件中，我们发现有几个选项比较重要： client–指的MySQL客户端 port–指的MySQL的端口号（默认3306） default-character-set默认编码方式（默认的是latin1，要修改为utf8，不是utf-8哈） mysqld主要是进行MySQL服务器端的配置 注意修改了MLSQL的配置，要进行重新启动才行 启动关闭MySQL服务 运行cmd，输入net stop mysql(其实在服务列表中，所有的服务都可以通过net stop XX来停止) 运行cmd，输入net start mysql(其实在服务列表中，所有的服务都可以通过net start XX来启动)如下图 关于cmd界面无法启动mysql： 必须要使用管理员身份运行cmd程序 如果下载MySQL5.7版本的，在windows服务上Mysql的名字默认是MySQL57，因此在cmd运行 net start/stop mysql 是无效的，必须改成 net start/stop mysql57才行 或者 在dos下运行net start mysql 不能启动mysql！提示发生系统错误 5；拒绝访问！切换到管理员模式就可以启动了。所以我们要以管理员身份来运行cmd程序来启动mysql。 那么如何用管理员身份来运行cmd程序呢？ 1.在开始菜单的搜索框张收入cmd，然后右键单击，并选择以管理员身份运行！ 如果每天都要启动mysql服务，这样不很麻烦？所以： 2.右键单击cmd选择“附到【开始】菜单(U)”;这是就可以到开始菜单上找到cmd了， 3.右击选择属性，选择快捷方式，选择高级，选择以管理员身份运行，单击确定 这样再输入net start mysql就不会出错了！ 这样修改配置就成功了","tags":[{"name":"html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"},{"name":"JavaScript，canvas","slug":"JavaScript，canvas","permalink":"http://yoursite.com/tags/JavaScript，canvas/"}]},{"title":"HTML5-Canvas之矩阵和多边形的绘制（2）","date":"2016-12-25T09:50:33.000Z","path":"2016/12/25/HTML5-Canvas之矩阵和多边形的绘制/","text":"上篇文章我们了解了canvas的定义、获取和基础的绘图操作，其中的绘图功能我们讲解了线段绘制、上色、描边等方面知识点。 今天我们来讲讲矩形（Rectangle）和多边形的绘制。 矩形的绘制一共有两个口令，分别是 ctx.fillRect(x, y, width, height) 和 ctx.strokeRect(x, y, width, height) ，参数中的 x 和 y 依旧表示需绘制的矩形的起始点坐标（相对canvas原点），width 和 height表示需绘制的矩形宽高。而 fillRect 表示绘制一个实心矩形，strokeRect 表示绘制一个描边矩形，我们来一个简单的例子：12345678910&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.fillRect(10,10,50,50); //从画布上的(10,10)坐标点为起始点，绘制一个宽高均为50px的实心矩形ctx.strokeRect(70,10,50,50); //从画布上的(70,10)坐标点为起始点，绘制一个宽高均为50px的描边矩形&lt;/script&gt; 效果如下 你也可以使用 Rect( x, y, width, height ) 的方法创建矩形路径，之后再通过 .stroke() 或 .fill() 方法来给矩形上色： 1234567var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.rect(20,20,150,100); //创建矩形路径ctx.stroke(); //描边ctx.beginPath(); //重置画笔，避免污染ctx.rect(50,90,50,50); //创建矩形路径ctx.fill(); //填充 效果如下 上方我们绘制了两个默认黑色的实心和描边矩形，相信你也联想到上一章我们绘制线段时，若没有定义strokeStyle，则线段也是默认为黑色的事情。那么我们要给这俩矩形上色，或许你也会联想到应当使用 *Style 来处理，而这想法也是正确的。 在canvas上，给实心对象上色可以用 fillStyle 来定义，给描边对象上色我们可以用 strokeStyle来定义，它们的赋值均为 color|gradient|pattern ，在上章我们已经细说过，这里不再赘述。 那么我们来给上方绘制了的实心矩形填充一个放射状渐变（黄-蓝-红），将描边矩形的描边设为绿色。我们可以这样做： 12345678910111213141516171819&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象var grd = ctx.createRadialGradient(35,35,0,35,35,36); //定义放射状渐变对象，设定渐变线起始点和结束点坐标，坐标格式为(起始点x,起始点y,结束点x,结束点y)grd.addColorStop(0,&quot;yellow&quot;); //定义渐变线起点颜色grd.addColorStop(0.5,&quot;blue&quot;); //定义渐变线中间点的颜色grd.addColorStop(1,&quot;red&quot;); //定义渐变线结束点的颜色ctx.fillStyle = grd; //将放射状渐变对象赋值给fillStylectx.fillRect(10,10,50,50); //从画布上的(10,10)坐标点为起始点，绘制一个宽高均为50px的实心矩形ctx.beginPath(); //重置画笔，这是个好习惯ctx.strokeStyle = &quot;green&quot;; //定义描边颜色为绿色ctx.strokeRect(70,10,50,50); //从画布上的(70,10)坐标点为起始点，绘制一个宽高均为50px的描边矩形&lt;/script&gt; 效果如下 这里要提到的是上一次没有仔细介绍过的放射状渐变方法 createRadialGradient ，其语法为 ctx.createRadialGradient( Xstart, Ystart, Radiusstart, Xend, Yend, Radiusend ) 其中前三个参数表示渐变起始圆形的中心坐标和半径，后三个参数表示渐变结束圆形的中点坐标和半径。 或许你会被这里的“半径”迷惑，回顾我们上章学习的createLinearGradient，它的参数并没有“半径”的概念，如果你是一名平面设计师，你更可能觉得放射状渐变只需要起始点和结束点坐标就可以了（毕竟PS/AI中的径向渐变只需要这两个点）。 但canvas在这里加入的“半径”参数还是有一定作用的，可以创造出比PS中径向渐变稍微复杂一些的效果。 ⑴ 我们先来一个最简单最好理解的例子：123456789var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象var grd = ctx.createRadialGradient(70,70,0,70,70,100); //定义放射状渐变对象，设定起始圆和结束圆中点重叠，且起始圆半径为0grd.addColorStop(0,&quot;yellow&quot;); //定义渐变线起点颜色grd.addColorStop(0.5,&quot;blue&quot;); //定义渐变线中间点的颜色grd.addColorStop(1,&quot;rgba(255,0,0,0)&quot;); //定义渐变线结束点的颜色，其中颜色透明度为0ctx.fillStyle = grd; //将放射状渐变对象赋值给fillStylectx.fillRect(0,0,c.width,c.height); //绘制一个跟画布大小一样的实心矩形 我们设置起始圆和结束圆中点相同，且起始圆半径为0，那么它的渐变线就是从两圆的中点开始到结束圆的边缘结束。我们设置渐变线结束点颜色透明度为0是为了方便查看结束圆的边界。效果如下： ⑵ 我们在⑴的基础上将起始圆的半径设为20，代码和效果图如下：123456789var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象var grd = ctx.createRadialGradient(70,70,20,70,70,100); //定义放射状渐变对象，设定起始圆和结束圆中点重叠，且起始圆半径为20grd.addColorStop(0,&quot;yellow&quot;); grd.addColorStop(0.5,&quot;blue&quot;); grd.addColorStop(1,&quot;rgba(255,0,0,0)&quot;); ctx.fillStyle = grd; ctx.fillRect(0,0,c.width,c.height); ⑶ 我们在⑵的基础上挪动起始圆的中点，不要让它跟结束圆的中点重叠，代码和效果图如下： 123456789var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象var grd = ctx.createRadialGradient(60,40,20,70,70,100); //起始圆不仅有半径，而且中点跟结束圆中点不相同grd.addColorStop(0,&quot;yellow&quot;); grd.addColorStop(0.5,&quot;blue&quot;); grd.addColorStop(1,&quot;rgba(255,0,0,0)&quot;); ctx.fillStyle = grd; ctx.fillRect(0,0,c.width,c.height); 注意我们在定义RadialGradient时，要尽量避免起始圆的范围超出结束圆的范围（起始圆最好是结束圆内部的一个真子集），否则绘制出来的效果会出现无法预知的错误，例如下面的代码：123456789var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象var grd = ctx.createRadialGradient(60,60,50,70,70,50); //起始圆的左边超出了结束圆内部区域grd.addColorStop(0,&quot;yellow&quot;); grd.addColorStop(0.5,&quot;blue&quot;); grd.addColorStop(1,&quot;rgba(255,0,0,0)&quot;); ctx.fillStyle = grd; ctx.fillRect(0,0,c.width,c.height); 不过如果你掌握了RadialGradient上色原理，倒是可以随意定位起始圆和结束圆的方位和大小。我从TimeLangoliers的博客（点击查看出处）看到这张原理图：他还依照此原理图写了一个例子：12345678910var canvas = document.getElementById(id); if (canvas == null) return false; var context = canvas.getContext(&apos;2d&apos;); var g1 = context.createRadialGradient(100, 150, 10, 300, 150, 50); g1.addColorStop(0.1, &apos;rgb(255,0,0)&apos;); g1.addColorStop(0.5, &apos;rgb(0,255,0)&apos;); g1.addColorStop(1, &apos;rgb(0,0,255)&apos;); context.fillStyle = g1; context.fillRect(0, 0, 400, 300); 至此我们学习了通过 fillRect 和 strokeRect 来绘制矩形，下面再讲一个Rect相关的功能——clearRect。 clearRect类似PS中的方块橡皮擦，可以擦除画布上任意一块矩形区域的内容，其语法如下： ctx.clearRect( x, y, width, height ); 其中 x 和 y 表示起始点坐标，width 和 height 表示这块“橡皮擦”的宽高。举个例子：123456789var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.fillStyle = &quot;red&quot;; ctx.fillRect(0,0,c.width,c.height); ctx.beginPath();ctx.fillStyle = &quot;blue&quot;; ctx.fillRect(10,20,60,60); ctx.clearRect(20,20,80,50); //擦除以（20,20）坐标为起点，宽高为80*50的区域 注意clearRect不会清除掉之前定义过的样式、画笔位置等绘制信息，打个比方，有时候我们需要清空整个画布，我们可以这样做：12345678910var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.fillStyle = &quot;blue&quot;; ctx.fillRect(10,20,60,60); //下面重置画布大小，从而清空画布c.width = c.width; //在jQ中可以写为 c.attr(&quot;width&quot;, c.width()); c.height = c.height; //在jQ中可以写为 c.attr(&quot;height&quot;, c.height()); //重新绘制一个矩形ctx.fillRect(10,20,60,60); 这个方法是通过重置画布大小，从而触发清空画布事件，但前面定义的 fillStyle=”blue” 也被清空掉了，从而绘制了一个黑色的矩形： 如果不想清除掉之前定义的样式，我们可以通过clearRect来实现：123456789var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.fillStyle = &quot;blue&quot;; ctx.fillRect(10,20,60,60); //下面通过clearRect来擦除画布ctx.clearRect(0,0,c.width,c.height);//重新绘制一个矩形ctx.fillRect(10,20,60,60); 执行结果如下： 最后聊一下多边形的绘制，其实现非常简单，先来个例子：123456789101112131415161718var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象//定义样式ctx.fillStyle = &quot;blue&quot;; ctx.strokeStyle = &quot;red&quot;;ctx.lineWidth = &quot;8&quot;;ctx.lineJoin = &quot;round&quot;;//绘制多边形ctx.moveTo(10,10);ctx.lineTo(100,30);ctx.lineTo(120,80);ctx.lineTo(60,60);ctx.lineTo(10,10);ctx.stroke(); //描边ctx.fill(); //填充 可见我们这里通过lineTo绘制了多边形的每条边（注意起点跟终点是同一个坐标），然后通过 stroke() 来描边、fill() 来填充，其执行效果如下： 眼尖的朋友会发现该多边形左上角的俩条描边没有接在一起，这是因为我们没有把这个多边形路径闭合起来，我们可以通过 ctx.closePath() 来解决这个问题： 眼尖的朋友会发现该多边形左上角的俩条描边没有接在一起，这是因为我们没有把这个多边形路径闭合起来，我们可以通过 ctx.closePath() 来解决这个问题：123456789101112131415161718var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象//定义样式ctx.fillStyle = &quot;blue&quot;; ctx.strokeStyle = &quot;red&quot;;ctx.lineWidth = &quot;8&quot;;ctx.lineJoin = &quot;round&quot;;//绘制多边形ctx.moveTo(10,10);ctx.lineTo(100,30);ctx.lineTo(120,80);ctx.lineTo(60,60);ctx.lineTo(10,10);ctx.closePath(); //闭合多边形路径ctx.stroke(); //描边ctx.fill(); //填充 这次就到这里，下次再见了！、 学习链接 canvas学习笔记HTML5- Canvas入门（二）玩转html5画图","tags":[{"name":"html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"HTML5-Canvas初探（1）","date":"2016-12-18T09:50:33.000Z","path":"2016/12/18/HTML5-Canvas初探/","text":"canvas其实没有那么玄乎，它不外乎是一个H5的标签，跟其它HTML标签如出一辙：1&lt;canvas&gt;&lt;/canvas&gt; canvas 元素用于在网页上绘制图形。 那么什么是 Canvas？ HTML5 的 canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，您可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 canvas本身没有任何的绘图能力，所有的绘图工作都是通过js来实现的。通常我们在js通过getElementById来获取要操作的canvas（这意味着咱得给canvas设个id）：123456&lt;canvas id=&quot;myCanvas&quot;&gt;&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;); //获取要操作的canvas//操作canvas的代码...&lt;/script&gt; 注意最好在一开始的时候就给canvas设置好其宽高（若不设定宽高，浏览器会默认设置canvas大小为宽300、高100像素），而且不能使用css来设置（会被拉伸），建议直接写于canvas标签内部： &lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt; 也可以在js脚本中设置： 1234567&lt;canvas id=&quot;myCanvas&quot;&gt;&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);c.width=200;c.height=200;&lt;/script&gt; 为什么不能用css来设置呢？这是因为 canvas 元素有元素本身大小与元素绘图表面大小两套尺寸。 设置 width 和 height 时，实际上是同时修改了该元素本身大小和元素绘图表面大小； 而设置 css，只会改变元素本身大小，并不会改变元素绘图表面大小。 关于canvas大小需要知道的一点是，后续咱们对canvas所做的全部绘图操作，超出此大小范围的部分是不可见的。顾名思义，可以把canvas看成一块画布，其大小是咱设定好的宽高，那么无论你怎么画，画布外的地方自然是画不到的。 对于有些浏览器是不支持canvas功能的，我们可以直接在canvas标签中写一些替换内容，在浏览器不支持canvas时显示：123&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt; 接着在聊如何在canvas上绘图前，咱得先说说.getContext(“2d”)这东西。.getContext() 是canvas的绘图对象/方法，要让canvas执行绘图工作必须先获取canvas的.getContext()对象来执行。 .getContext()只接受一个参数，该参数用于获取canvas的绘图环境，例如.getContext(“2d”)表示该canvas的绘图环境为2D平面（可以绘制文本、直线、弧线、矩形、圆形等）。当前H5只支持2D环境，在不久的将来会开放3D绘图功能。（故咱可将“getContext”翻译为“获取绘图环境”） 接下来：主要是对canvas线段绘制功能的介绍理论不多说，我们先来个小例子，从最简单的绘制直线开始： 1234567891011&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.moveTo(10,10); //定义绘画开始的位置ctx.lineTo(150,50); //画一条直线，结束点坐标是x=150,y=50ctx.stroke(); //描边&lt;/script&gt; 效果如下：在这里我们使用了3个getContext(“2d”)对象的绘图方法： .moveTo(x坐标 , y坐标) 可以理解为定位画笔在画布上的位置（注意所有绘图方法所定义的坐标是相对canvas而言的而不是浏览器窗口，对canvas来说，最左上角的点的坐标是(0,0)） .lineTo(x坐标 , y坐标) 顾名思义，就是画一条直线到某个点，很好理解。需要知道的是此方法仅仅做路径运动，而不存在任何视觉上的绘图效果（上色、描边） .stroke() 描边方法，有玩过AfterEffect的朋友会很清楚，不给运动路径加stroke特效的画是不存在描边效果的，canvas也一样，想要运动路径轨迹能有视觉效果，需要使用相应的上色/描边方法 自此我们很轻松地绘制了一条黑色的直线，但如果我们想要绘制一条红色的或者其它颜色的线段，该怎么做呢？ 答案很简单，使用ctx.strokeStyle来设定描边的颜色即可。我们画三条红色的线段吧： 123456789&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:solid 1px #CCC; margin:30px;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.moveTo(0,0); //咱把“画笔”移到坐标(0,0)ctx.line 注释都说的很清楚了，故不再赘述实现原理，其效果如下： 注意在开始绘制路径的时候，一定要加上moveTo(x,y)，否则第一个lineTo()的运动轨迹将不计入绘图中（浏览器会认为没获取到该运动轨迹的起始点，故忽略此线段）。 另外有一个问题，如果上方我们会出来的两条线段（嗯，一条折线，一条直线），我们希望第一条折线是蓝色的，第二条直线是红色的，应当怎么做？ 你会很自然地做如下处理：1234567891011121314&lt;script&gt; var c = document.getElementById(&quot;myCanvas&quot;); var ctx = c.getContext(&quot;2d&quot;); ctx.moveTo(0,0); ctx.lineTo(150,50); ctx.lineTo(20,100); ctx.strokeStyle = &quot;blue&quot;; //设定描边颜色为蓝色 ctx.stroke(); ctx.moveTo(90,90); ctx.lineTo(80,150); ctx.strokeStyle = &quot;red&quot;; //设定描边颜色为红色 ctx.stroke(); &lt;/script&gt; 但运行脚本会发现，折线除了被描了一遍蓝色，也被描了一遍红色：这是因为canvas在第二次给路径上色时，是把之前的所有路径轨迹合在一起来上色的，除非咱们让canvas知道那折线和直线应该是独立开来的俩路径。 我们可以使用.beginPath()来解决： 123456789101112131415&lt;script&gt; var c = document.getElementById(&quot;myCanvas&quot;); var ctx = c.getContext(&quot;2d&quot;); ctx.moveTo(0,0); ctx.lineTo(150,50); ctx.lineTo(20,100); ctx.strokeStyle = &quot;blue&quot;; //设定描边颜色为蓝色 ctx.stroke(); ctx.beginPath(); //告诉canvas咱们要重新绘制一条全新的路径了，之前画的东西从此再无关系 ctx.moveTo(90,90); ctx.lineTo(80,150); ctx.strokeStyle = &quot;red&quot;; //设定描边颜色为红色 ctx.stroke(); &lt;/script&gt; 有的朋友一开始会搞不清楚beginPath()的用途，觉得有moveTo()就可以了，其实beginPath()可以做到上述的隔离路径绘制效果的作用，防止之前的效果被污染。 接着唠嗑.strokeStyle的赋值方式，咱们上方是直接用了 ctx.strokeStyle=”red” 来定义描边颜色为红色，不过ctx.strokeStyle可获值的形式有三种： ctx.strokeStyle=color|gradient|pattern; //即支持 “颜色/渐变/图案笔刷” 的赋值 先看看color赋值方式，和我们常规的css赋值是一样的，支持css3颜色值标准，如下例：12345//下面四种形式都是一样的，表示描边颜色为“橙色”ctx.strokeStyle = &quot;orange&quot;;ctx.strokeStyle = &quot;#FFA500&quot;; //#rrggbb形式ctx.strokeStyle = &quot;rgb(255,165,0)&quot;; //RGB形式ctx.strokeStyle = &quot;rgba(255,165,0,1)&quot;; //比上面的rgb多了个a（Alpha），即透明度 2 . 再看下渐变gradient，这个稍有复杂： 12345678910111213var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); ctx.moveTo(0,0); ctx.lineTo(150,50); ctx.lineTo(20,100); var grd = ctx.createLinearGradient(0,0,170,0); //定义线性渐变对象，设定渐变线起始点和结束点坐标，坐标格式为(起始点x,起始点y,结束点x,结束点y)grd.addColorStop(0,&quot;black&quot;); //定义渐变线起点颜色grd.addColorStop(0.5,&quot;red&quot;); //定义渐变线中间点的颜色grd.addColorStop(1,&quot;yellow&quot;); //定义渐变线结束点的颜色ctx.strokeStyle = grd; //将渐变对象赋值给strokeStylectx.stroke(); //描边 效果如下： 这里我们提到了一个概念叫“渐变线”，没有玩过设计的朋友需要了解下渐变的知识点，我们可以把LinearGradient（线性渐变，另有放射状/圆形渐变RadialGradient）范围看成一个矩形（你可以通过Illustator、Photoshop等专业设计软件来辅助你理解这点）：我们一开始定义线性渐变对象的代码 var grd = ctx.createLinearGradient(0,0,170,0) 不外乎就是设定了线性渐变线起始点为(0,0)，结束点为(170,0)。 紧接着我们通过 addColorStop( 渐变线位置, 颜色 ) 来设定了渐变色值，分别在渐变线0、0.5、1的位置设置了黑色、红色、黄色，其渐变效果如下：通过 ctx.strokeStyle = grd 将渐变赋值给描边方法，最终描边得到了我们想要的渐变效果。 3 . 最后看看pattern描边方式，strokeStyle之所以不叫strokeColor是因为它除了支持颜色描边还支持图案描边（搞设计的朋友或许称作笔触描边会更有feel）。 线性渐变描边需要先createLinerGradient(xstart,ystart,xend,yend)，那么设置图案描边自然也要先新建一个canvasPattern对象：1createPattern(image, repetitionStyle) 其中参数 image 代表图案对象，一般通过 document.createElement(‘img’) 或者 new Image() ，再定义其src值来创建该对象。而repetitionStyle参数很好理解，即图案重复形式，其可选值有”repeat” 、”repeat-x”、”repeat-y” 和”no-repeat” （和css的background-repeat可选值一样，不赘述）。 我们这样写1234567891011121314151617&lt;body&gt;&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:solid 1px #CCC; margin:30px;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt; var c = document.getElementById(&quot;myCanvas&quot;); var ctx = c.getContext(&quot;2d&quot;); pic = new Image(); //创建图片对象，或者 pic = document.createElement(&apos;img&apos;) pic.src = &quot;http://images.cnblogs.com/cnblogs_com/vajoy/558870/o_5.jpg&quot;; //定义图片的映射地址 var redTexture = ctx.createPattern(pic, &quot;repeat&quot;); //定义Pattern对象，设定填充图案为pic图片，填充形式为平铺 ctx.strokeStyle = redTexture; //定义描边样式为上一行设定的Pattern描边 ctx.moveTo(80,10); ctx.lineTo(10,90); ctx.stroke();&lt;/script&gt; 效果如下：注意这里我还加了个 ctx.lineWidth = 8 来设定线段的粗度。 自此我们学习了strokeStyle的三个赋值方式，也学习了上述的通过 ctx.lineWidth = lineWeight 的形式来给线段设定粗度。 咱们再学习两个很简单的线段属性 lineCap 和 lineJoin。 ⑴ lineCap是设定线段端点的形状（线帽），其值可以是 butt 默认，即线条端点为平直的边缘round 线条端点为圆角线帽square 为线条端点添加正方形线帽 1234567891011121314151617181920212223242526272829&lt;canvas id=&quot;myCanvas&quot; width=&quot;250&quot; height=&quot;120&quot; style=&quot;border:1px solid #DDD;&quot;&gt;&lt;/canvas&gt;&lt;script&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.lineWidth=10;ctx.beginPath();ctx.lineCap=&quot;butt&quot;;ctx.moveTo(20,10);ctx.lineTo(200,60);ctx.strokeStyle=&quot;red&quot;;ctx.stroke();ctx.beginPath();ctx.lineCap=&quot;round&quot;;ctx.moveTo(30,90);ctx.lineTo(200,40);ctx.strokeStyle=&quot;blue&quot;;ctx.stroke();ctx.beginPath();ctx.lineCap=&quot;square&quot;;ctx.moveTo(10,30);ctx.lineTo(200,80);ctx.strokeStyle=&quot;green&quot;;ctx.stroke();&lt;/script&gt; 效果如下： 光看此图可能看不太出“butt”和”square”的区别，但懂得使用AI绘制矢量的同学们应该比较了解： ⑵ lineJoin则是设定折线的交接处的外角类型，其值可为： miter 默认，折线交接处为尖角round 折线交接处为圆角bevel 折线交接处为斜角 12345678910111213141516171819202122232425262728293031&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;220&quot; style=&quot;border:1px solid #DDD;&quot;&gt;&lt;/canvas&gt;&lt;script&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.lineWidth=13;ctx.lineJoin=&quot;bevel&quot;;ctx.moveTo(20,20);ctx.lineTo(100,50);ctx.lineTo(20,80);ctx.strokeStyle=&quot;red&quot;;ctx.stroke();ctx.beginPath();ctx.lineJoin=&quot;round&quot;;ctx.moveTo(20,60);ctx.lineTo(100,90);ctx.lineTo(20,150);ctx.strokeStyle=&quot;green&quot;;ctx.stroke();ctx.beginPath();ctx.lineJoin=&quot;miter&quot;;ctx.moveTo(20,90);ctx.lineTo(100,150);ctx.lineTo(20,200);ctx.strokeStyle=&quot;blue&quot;;ctx.stroke();&lt;/script&gt; 效果如下 需要了解的是，miter还受到了属性miterLimit的影响（点此查看详细），但个人觉得它跟bevel实现的效果是一致的，故在此不做介绍。这次就到这里了，下次再见了啦！ 下面推荐一下其他很好的博文HTML5- Canvas入门（一）玩转html5&lt;canvas&gt;画图","tags":[{"name":"html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"项目常用的less语法详解","date":"2016-12-10T09:50:33.000Z","path":"2016/12/10/项目常用的less语法详解/","text":"什么是less？ less是一种动态样式语言，属于css预处理语言的一种，类似于css的语法，为css赋予了动态语言的特性，如变量、继承，运算，函数等，更方便css的编写和维护 编译工具 Koala编译 国人开发的less/sass编译工具、 下载地址： http://koala-app.com/index-zh.html 常用： 输出方式compress(进行压缩) Node.js库 浏览器端使用Koala配置及使用 新建后缀为.less文件：index.less头部写上：@charset “utf-8”; //设定字符集 把文件夹拖到koala中，设置输出路径为style下的index.css使用koala进行编译，然后就生成了一个index.css文件。 之后我们只要编辑index.less文件即可。 项目中常用的语言特性注释 less有两种注释 //*会在css中编译出来/*/ //不会在css中编译出来第一种的注释会在css中编译出来，第二种不会 变量： 变量允许我们单独定义一系列通用的样式，然后在需要的时候去调用。所以在做全局样式调整的时候我们可能只需要修改几行代码就可以了。 less中声明变量用@开头，例：@变量名：值；less源码： 12@margin-left:30px;box&#123;margin: margin-left;&#125; 编译后的css1box&#123;margin:30px;&#125; 混合模式（Mixins） 混合可以将一个定义好的class A轻松的引入到另一个class B中，从而简单实现class B继承class A中的所有属性。我们还可以带参数地调用，就像使用函数一样。 123456789101112131415161718192021222324252627282930313233343536373839404142//混合.box&#123; width: @text_width; height: 100px; background: green; .border;&#125;.border&#123; border:solid 1px pink;&#125;//混合，可带参数.border_02(@border_width)&#123; border:solid yellow @border_width;&#125;.test_mix2&#123; .border_02(30px); //注意：参数不初始化，括号里必须要有个值，&#125;//混合默认带值.border_03(@border_width:10px)&#123; border:solid yellow @border_width;&#125;.test_mix3&#123; .border_03();&#125;//混合好例子（适用多个浏览器）.border_radius(@radius:5px)&#123; -webkit-border-radius:@radius; -moz-border-radius:@radius; border-radius:@radius;&#125;.radius_test&#123; width: 100px; height: 100px; background: pink; .border_radius(30px);&#125; 匹配模式： 有点像switch或者if 判断满足哪个条件就用哪一个。 其他的就是混合。 @_ ： ,这个很强大：无论匹配到什么值，均会运行，类似于成全局了（函数名一致） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465.float(left)&#123; float:left; &#125;//调用匹配模式：那么就是： .setFloat&#123; .float(left); &#125; //举个三角例子//匹配模式(原始)// .tri_test&#123; // width: 0; // height: 0 // overflow: hidden;// border-width: 150px;// border-color: red transparent transparent transparent;// border-style: solid dashed dashed dashed ;//dashed 虚线// &#125;//匹配模式.triangle(top, @w: 5px, @c:#ccc)&#123; //朝上 border-width: @w; border-color: transparent transparent #ccc transparent; border-style: dashed dashed solid dashed ;//dashed 虚线&#125;.triangle(bottom, @w: 5px, @c:#ccc)&#123; //朝下 border-width: @w; border-color: @c transparent transparent transparent; border-style: solid dashed dashed dashed ;//dashed 虚线&#125;.triangle(left, @w: 5px, @c:#ccc)&#123; //朝左 border-width: @w; border-color: transparent @c transparent transparent; border-style: dashed solid dashed dashed ;//dashed 虚线&#125;.triangle(right, @w: 5px, @c:#ccc)&#123; //朝右 border-width: @w; border-color: transparent transparent transparent @c ; border-style: dashed dashed dashed solid ;//dashed 虚线&#125;.triangle(@_, @w: 5px, @c:#ccc)&#123; //@_ 强大：无论匹配到什么值，均会运行这个函数 width: 0; height: 0; overflow: hidden;&#125;.tri_test&#123; .triangle(top, 100px);&#125;//好例子：：匹配：定位.pos(r)&#123; position:relative;&#125;.pos(a)&#123; position:absolute;&#125;.pos(f)&#123; position:fixed;&#125;.match&#123; width: 100px; height: 150px; background-color: green; .pos(r);&#125; 运算 任何数字，颜色或者变量都可以参与运算，运算应该包裹在括号里 例如+ - * / 12345@val:300px;.box&#123; width: @val + 20;/*less没有强制要求必须加单位，只要有一个有单位即可*/ height: (@val - 20) * 5; color: #ccc - 10 ;/*less会把颜色转成 255 的数值，然后进行计算，输出颜色值对应的颜色，工作中很少用到*/ 嵌套规则 &amp; 代表上一层选择器 用处1：123a&#123; &amp;:hover&#123;&#125; &#125;； 用处2：123.content&#123; &amp;_item1&#123; &#125; &#125; //&amp;_item1就相当于。content_item1 1234567891011121314151617181920212223242526272829303132//嵌套例子/*.list&#123;&#125;.list li&#123;&#125;.list a&#123;&#125;.list span&#123;&#125;*/下面所属关系，一层套一层，省去了重复的东西.list&#123; width: 600px; margin:30px auto; padding: 0; list-style: none; li&#123; height: 30px; line-height: 30px; background-color: pink; margin-bottom: 5px; &#125; a&#123; float: left; //&amp; 代表上一层选择器 &amp;:hover&#123; color: red; &#125; &#125; span&#123; float: right; &#125;&#125; &amp; 代表他的上一层选择器 12345678//&amp; 代表他的上一层选择器a&#123; float: left; //&amp; 代表上一层选择器 &amp;:hover&#123; color: red; &#125; &#125; &amp;同样代表他的上一层选择器，起连接作用 123456789101112131415161718//嵌套小例子//HTML&lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;content_item1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;content_item2&quot;&gt;&lt;/div&gt; &lt;/div&gt;//LESS.content&#123; width: 40px; height: 40px; background: #ccc; &amp;_item1&#123; //&amp;_item1就相当于。content_item1 width: 20px; height: 20px; background: pink; &#125;&#125; @arguments变量（用的不是很多）懒人必备 @arguments包含了所有传递进来的参数。 123456789101112 @border（@w：30px，@c：red，@s：solid）&#123; border：@w @c @s&#125;//如果你不想单独处理每一个参数的话就可以像这样写：.border_arg(@w:30px,@c:red,@ww:solid)&#123;border:@arguments;//这个@arguments就相当于@w,@c,@s 包含所有参数&#125;//调用.test_arguments&#123;.border_arg(40px);&#125; 封装 可以把封装的东西放到一个单独的 less里面，只需要在main.less主文件里面 @import 加文件名 xx 可以省略后缀名. 加载css需要 @import(less) “xxx.css”换汤不换药 其中“”前面有一个空格 还是css那一套加载方式，放到哪里就在哪里加载，样式表！123//引入a.less和a.css例子@import &quot;a.less&quot;; //引入其他的less样式表,其中.less可写可不写@import (less) &quot;a.css&quot; //引入css样式表，注意（less）和“a.css”中间有个空格 less 也有作用域1234567.content1&#123;@w:100px;width:@w;&#125;.content2&#123;width:@w;//错误，这个@w引用不了，因为他在.content1中&#125; 欲知更多，请戳less-中文官网可学习视频：less即学即用-慕课","tags":[{"name":"less","slug":"less","permalink":"http://yoursite.com/tags/less/"}]},{"title":"AngularJs指令解密","date":"2016-12-04T09:50:33.000Z","path":"2016/12/04/AngularJs指令解密/","text":"指令定义在《AngularJs权威教程》中，指令可以简单理解成特定的DOM元素上运行的函数；我认为还可以理解成将将自定义的HTML标签解析成原始的标签，然后为其加入一些扩展的功能（函数）.angularjs 提供了一个强大的扩展系统，通过指令机制，我们可以通过自定义指令来扩展自己的指令系统。 在AngularJS的核心里，指令可以绑定元素的属性（例如可见性，class列表，内部文本，内部HTML或者值）到scope的属性或表达式。最值得注意的是，一旦监测到scope中的变化被标记，这些绑定就会被更新。反过来也是相似的，使用$observe函数能够监测DOM属性，当监测到属性变化时会触发一个回调。 AngularJS应用的模块中有很多方法可以使用，其中directive()这个方法是用来定义指令的：不急，首先要注意下指令的名字，先看个简单例子：12345678angular .module(&apos;myApp&apos;, []) .directive(&apos;myDirective&apos;, myDirective);myDirective.$inject = [&apos;$timeout&apos;, &apos;UserDefinedService&apos;]function myDirective($timeout, UserDefinedService) &#123; // 指令定义放在这里&#125; 尽管在上面的的代码片段中我们定义了一个命名为myDirective的指令,AngularJS约定在 HTML 标记里使用破折号的形式连接名字。如果这个指令作为一个属性实现，那么我在 HTML 中就会像这样调用：&lt;span my-directive&gt;&lt;/span&gt; 还有：directive()方法可以接受两个参数： name(字符串)指令的名字，用来在视力中引用特定的指令。 factory_function(函数)这个函数返回一个对象，其中定义了指令的全部行为。$compile服务利用这个方法返回的对象，在DOM调用指令时来构造指令的行为。 注意：为了避免与未来的HTML标准冲突，给自定义的指令加入前缀来代表自定义的命名空间。AngularJS本身已经使用了ng-前缀，所以可以选择除此以外的名字。在例子中我们使用my-前缀（比如my-derictive）。 当AngularJS在DOM中遇到具名的指令时，会去匹配已经注册过的指令，并通过名字在注册过的对象中查找。此时，就开始了一个指令的生命周期，指令的生命周期开始于\\$compile方法并结束于link方法 下面，来看看定义一个指令时可以使用的全部设置选项。可能的选项如下所示，每个键的值说明了可以将这个属性设置为何种类型或者什么样的函数：12345678910111213141516171819202122232425262728293031angular .module(&apos;myApp&apos;, []) .directive(&apos;myDirective&apos;, myDirective);function myDirective() &#123; return: &#123; restrict: String, // priority: Number, terminal: Boolean, template: String or Template Function: function(tElement, tAttrs) &#123;...&#125;, templateUrl: String, replace: Boolean or String, scope: Boolean or Object, transclude: Boolean, controller: String or function(scope, element, attrs, transclude, otherInjectables) &#123;...&#125;, controllerAs: String, require: String, link: function(scope, iElement, iAttrs) &#123;...&#125;, compile: // 返回一个对象或连接函数，如下所示: function(tElement, tAttrs, transclude) &#123; return &#123; pre: function(scope, iElement, iAttrs， controller) &#123;...&#125;, post: function(scope, iElement, iAttrs, controller) &#123;...&#125; &#125; // 或者 return function postLink(...) &#123;...&#125; &#125; &#125;&#125; 下面我们来详细说说每种设置 restrict(字符串string)restrict是一个可选的参数。它告诉AngularJS这个指令在DOM中可以何种形式被声明。默认AngularJS认为restrict的值是A，即以属性的形式来进行声明。可选值如下：E(元素)： &lt;my-directive&gt;&lt;/my-directive&gt; A(属性，默认值)：&lt;div my-directive=&quot;expression&quot;&gt;&lt;/div&gt; C(类名)：&lt;div class=&quot;my-directive:expression;&quot;&gt;&lt;/div&gt;M(注释)：&lt;!-- directive:my-directive expression --&gt;AE : 可以结合上面的任意值来放松限制。 千万别用 ‘C’ 或者 ‘M’ 来限制你的指令。 用 ‘C’ 不能使之在标记中凸显出来， 用 ‘M’ 是为了向后兼容。 如果你觉得有趣， 你可以用一个例子来设置 restrict 为 ‘ACME’。这些选项可以单独使用，也可以混合在一起使用。 属性是用来声明指令最常用的方式，因为它能在包括老版本的IE浏览器在内的所有浏览器中正常工作，并且不需要在文档头部注册新的标签。 包含某个组件的核心行为时使用元素型。用额外的行为、状态或者其他内容进行修饰或扩展时使用属性型优先级(数值型Number) 优先级参数可以被设置为一个数值。大多数指令会忽略这个参数，使用默认值0，但也有些场景设置高优先级是非常重要甚至是必须的。例如，ngRepeat将这个参数设置为1000，这样就可以保证在同一元素上，它总是在其他指令之前被调用。 如果一个元素上具有两个优先级相同的指令，声明在前面的那个会被优先调用。如果其中一个的优先级更高，则不管声明的顺序如何都会被优先调用：具有更高优先级的指令总是优先运行。 terminal(布尔型Boolean) terminal是一个布尔型参数，可以被设置为true或false。这个参数用来告诉AngularJS停止运行当前元素上比本指令优先级低的指令。但同当前指令优先级相同的指令还是会被执行。如果元素上某个指令设置了terminal参数并具有较高的优先级，就不要再用其他低优先级的指令对其进行修饰了，因为不会被调用。但是具有相同优先级的指令还是会被继续调用。 template(字符串string或函数Function)template参数是可选的，必须被设置为以下两种形式之一： 一段HTML文本;一个可以接受两个参数的函数，参数为tElement和tAttrs，并返回一个代表模板的字符串。tElement和tAttrs中的t代表template，是相对于instance的。在讨论链接和编译设置时会详细介绍，模板元素或属性与实例元素或属性之间的区别。 在实际生产中，更好的选择是使用templateUrl参数引用外部模板，因为多行文本阅读和维护起来都是一场噩梦。 templateUrl（字符串String | 函数Function）可选的参数，可以是以下类型： 一个代表外部HTML文件路径的字符串 一个可以接受两个参数的函数，参数为tElement和tAttrs，并返回一个外部HTML文件路径的字符串 模板的URL都将通过AngularJS内置的安全层， 特别是\\$getTrustedResourceUrl，这样可以保护模板不会被不信任的源加载 调用指令时会在后台通过Ajax来请求HTML模板文件，也就是说： * 需要防止CORS错误 * 编译和链接要暂停，等待模板加载完成 模板加载后，AngularJS会将它默认缓存到$templateCache服务中，，可以提前将模板缓存到一个定义模板的JavaScript文件中，这样就不需要通过XHR来加载模板了 replace(布尔型Boolean)replace是一个可选参数，如果设置了这个参数，值必须为true，因为默认值为false。默认值意味着模板会被当作子元素插入到调用此指令的元素内部：123456&lt;div some-directive&gt;&lt;/div&gt;.directive(&apos;someDirective&apos;, function() &#123; return &#123; template: &apos;&lt;div&gt;some stuff here&lt;/div&gt;&apos; &#125;&#125;) 调用指令之后的结果如下(这是默认replace为false时的情况)：123&lt;div some-directive&gt; &lt;div&gt;some stuff here&lt;/div&gt;&lt;/div&gt; 如果replace被设置为了true：123456.directive(&apos;someDirective&apos;, function() &#123; return &#123; replace: true, // 修饰过 template: &apos;&lt;div&gt;some stuff here&lt;/div&gt;&apos; &#125;&#125;) 指令调用后的结果将是：1&lt;div&gt;some stuff here&lt;/div&gt; scope（布尔值Boolean | 对象Object）scope参数是可选的，默认为false： false：直接调用相同的作用域对象； true：从当前作用域对象继承一个新的作用域对象； 对象：创建一个同当前作用域相隔离的作用域对象。 ####独立作用域 scope属性值设置为true，作用是让自定义的每一个指令拥有独立的作用域，而不是共享一个作用域。 隔离作用域 通常情况下，当我们需要创建可复用的组建时，我们需要的就是具有隔离作用域的指令。它不依赖于上下文或者说是父级的作用域，所以可以随意迁移，不需要考虑依赖数据的问题。 隔离作用域实现起来很简单，只要将自定义指令返回对象中“scope”值写成“{}”就行。 1234567891011121314151617181920//隔离作用域app.directive(&apos;helloWorld&apos;, function() &#123; return &#123; scope: &#123;&#125;,//隔离作用域 restrict: &apos;AE&apos;, replace: true, template: &apos;&lt;p style=&quot;background-color:&#123;&#123;color&#125;&#125;&quot;&gt;Hello World&lt;/p&gt;&apos;, link: function(scope, elem, attrs) &#123; elem.bind(&apos;click&apos;, function() &#123; elem.css(&apos;background-color&apos;,&apos;white&apos;); scope.$apply(function() &#123; scope.color = &quot;white&quot;; &#125;); &#125;); elem.bind(&apos;mouseover&apos;, function() &#123; elem.css(&apos;cursor&apos;, &apos;pointer&apos;); &#125;); &#125; &#125;;&#125;); 使用隔离作用域时，可以将指令内部的隔离作用 域，同指令外部的作用域进行数据绑定： * 本地作用域属性：使用@符号将本地作用域同DOM属性的值进行绑定 * 双向绑定：通过=可以将本地作用域上的属性同父级作用域上的属性进行双向的数据绑定 * 父级作用域绑定：通过&amp;符号可以对父级作用域进行绑定，以便在其中运行函数 transclude（布尔值Boolean）可选，默认为false 可以将整个模板，包括其中的指令通过嵌入全部传入一个指令中。这样做可以将任意内容和作用域传递给指令。transclude参数就是用来实现这个目的的，指令的内部可以访问外部指令的作用域，并且模板也可以访问外部的作用域对象 只有当你希望创建一个可以包含任意内容的指令时，才使用transclude: true controller（字符串String | 函数Function）可选： * 字符串：以字符串的值为名字，查找注册在应用中的控制器的构造函数 * 函数：直接定义内联的控制器 可以向控制器中注入如下服务： \\$scope: 与指令元素相关联的当前作用域 \\$element: 当前指令对应的元素 \\$attrs: 由当前元素的属性组成的对象 \\$transclude: 嵌入链接函数会与对应的嵌入作用域进行预绑定。transclude链接函数是实际被执行用来克隆元素和操作DOM的函数。controllerAs （字符串String） 用来设置控制器的别名，可以以此为名来发布控制器，并且作用域可以访问controllerAs。这样就可以在视图中引用控制器，甚至无需注入$scope。 require（字符串String | 数组Array）字符串或数组元素的值是会在当前指令的作用域中使用的指令名称。require会将控制器注入到其值所指定的指令中，并作为当前指令的链接函数的第四个参数。 默认情况下，指令只会在自身的元素上查找控制器。可以用下面的前缀进行修饰，改变查找控制器时的行为： ?: 如果在当前指令中没有找到所需要的控制器，会将null作为传给link函数的第四个参数 ^: 如果添加了^前缀，指令会在上游的指令链中查找require参数所指定的控制器 ?^: 将前面两个选项的行为组合起来，可选择地加载需要的指令并在父指令链中进行查找 没有前缀: ，指令将会在自身所提供的控制器中进行查找，如果没有找到任何控制器（或具有指定名字的指令）就抛出一个错误 compile（对象Object | 函数Function）在compile函数内部，只对DOM进行操作，返回函数等效于使用link配置，返回对象的话包含两个函数： preLink会在编译阶段之后、指令连接到子元素之前运行 postLink会在所有子元素指令都链接之后才运行1234567compile: function(tElement, tAttrs, transclude) &#123; // 一些DOM操作 return &#123; pre: function preLink(scope, iElement, iAttrs, controller) &#123;&#125;, post: function postLink(scope, iElement, iAttrs, controller) &#123;&#125; &#125;;&#125; link（函数Function）link函数会访问scope对象，其返回一个postLink函数。如果在compile中返回了post，那么link选项就会被忽略 link: function postLink(scope, iElement, iAttrs){} compile和linkcompile和link有许多异同： compile函数只会被调用一次，而link函数的调用次数可能会很多。compile用于对模板自身的转换，而link负责模型和视图之间进行动态关联link函数能够访问scope作用域对象，而compile不会，因为在编译阶段，scope对象还不存在。link和compile都会接收指令声明的DOM元素以及属性列表compile可以返回preLink和postLink函数，而link只能返回postLink函数 AngularJS的生命周期 AngularJS应用启动后会进行编译和链接，作用域会同HTML进行绑定，应用可以对用户在HTML中进行的操作进行实时响应。 编译三个阶段 首先浏览器会用它的标准API将HTML解析成DOM。模板必须是可被解析的HTML。这是AngularJS和那些“以字符串为基础而非以DOM元素为基础的”模板系统的区别之处。 DOM的编译是有\\$compile方法来执行的。这个方法会遍历DOM并找到匹配的指令。一旦找到一个，它就会被加入一个指令列表中，这个列表是用来记录所有和当前DOM相关的指令的。 一旦所有的指令都被确定了，会按照优先级被排序，并且他们的compile方法会被调用。指令的\\$compile()函数能修改DOM结构，并且要负责生成一个link函数（后面会提到）。\\$compile方法最后返回一个合并起来的链接函数，这是链接函数是每一个指令的compile函数返回的链接函数的集合。 通过调用一步所说的链接函数来将模板与作用域链接起来。这会轮流调用每一个指令的链接函数，让每一个指令都能对DOM注册监听事件，和建立对作用域的的监听。这样最后就形成了作用域的DOM的动态绑定。任何一个作用域的改变都会在DOM上体现出来。大致过程如下：12345678910111213var $compile = ...; // injected into your codevar scope = ...;var html = &apos;&lt;div ng-bind=&apos;exp&apos;&gt;&lt;/div&gt;&apos;;// Step 1: parse HTML into DOM elementvar template = angular.element(html);// Step 2: compile the templatevar linkFn = $compile(template);// Step 3: link the compiled template with the scope.linkFn(scope); 模板之中可能含有指令，指令之中可能又含有模板，模板之中又含有指令，由此形成一棵模板树。只有具有最高优先级的指令中的模板会被编译。如果一个元素已经有一个含有模板的指令了，永远不要对其用另一个指令进行修饰。一个指令会将内部子指令的模板合并在一起成为一个模板函数并返回，它无法查找父指令，只能通过模板函数访问内部子指令 ngModelngModel提供更底层的API来处理控制器内的数据。 为了设置作用域中的视图值，需要调用ngModel.\\$setViewValue()函数，接受一个字符串参数value，表示想要赋予的实际值，然后：ngModel.\\$setViewValue()方法会更新控制器本地的\\$viewValue，然后将值传递给每一个\\$parser函数值被解析且\\$parser所有函数都完成后，值会赋给\\$modeValue属性，并且传递给指令中ng-model属性提供的表达式所有步骤都完成后，\\$viewChangeListeners中所有的监听器都会被调用 单独调用\\$setViewValue()不会唤起一个新的digest循环，因此如果想更新指令，需要在设置\\$viewValue后手动触发digestngModel的\\$render方法可以定义视图具体的渲染方式，它在$parser完成后被调用 ngModelController中有几个属性可用来检查甚至修改视图： \\$viewValue： 保存着更新视图所需的实际字符串。 \\$modelValue：由数据模型持有。\\$modelValue和\\$viewValue可能是不同的，取决于\\$parser流水线是否对其进行了操作。 \\$parsers：\\$parsers的值是一个由函数组成的数组，其中的函数会以流水线的形式被逐一调用。ngModel从DOM中读取的值会被传入\\$parsers中的函数，并依次被其中的解析器处理。 \\$formatters：\\$formatters的值是一个由函数组成的数组，其中的函数会以流水线的形式在数据模型的值 发生变化时被逐一调用。它和\\$parser流水线互不影响，用来对值进行格式化和转换，以便在绑定了这个值的控件中显示。 \\$viewChangeListeners：\\$viewChangeListeners的值是一个由函数组成的数组，其中的函数会以流水线的形式在视图中的值发生变化时被逐一调用。通过\\$viewChangeListeners，可以在无需使用\\$watch的情况下实现类似的行为。由于返回值会被忽略，因此这些函数不需要返回值。 友情链接AngularJs权威教程很好玩的博客–AngularJs指令详解AngularJS - 指令详解天镶的读书笔记","tags":[{"name":"AngularJs","slug":"AngularJs","permalink":"http://yoursite.com/tags/AngularJs/"}]},{"title":"AngularJS浅谈-博客","date":"2016-11-28T09:50:33.000Z","path":"2016/11/28/AngularJs浅谈/","text":"AngularJS是啥？（一脸懵逼）简介： AngularJS诞生于2009年，由Misko Hevery 等人创建，后为Google所收购。是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVC、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。 具体点说： AngularJS 是一个 JavaScript 框架 AngularJS 是以一个 JavaScript 文件形式发布的，可通过 script 标签添加到网页中：&lt;script src=&quot;../libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; AngularJS 扩展了 HTML AngularJS 通过 ng-directives 扩展了 HTML。ng-app 指令定义一个 AngularJS 应用程序。ng-model 指令把元素值（比如输入域的值）绑定到应用程序。ng-bind 指令把应用程序数据绑定到 HTML 视图。ng-init 指令初始化 AngularJS 应用程序变量 那么，重点来了，AngularJs可以干啥啊？AngularJS 使得开发现代的单一页面应用程序（SPAs：Single Page Applications）变得更加容易。 AngularJS 把应用程序数据绑定到 HTML 元素。AngularJS 可以克隆和重复 HTML 元素。AngularJS 可以隐藏和显示 HTML 元素。AngularJS 可以在 HTML 元素”背后”添加代码。AngularJS 支持输入验证。 举个荔枝（例子）吧！12345678910111213141516171819202122232425262728293031&lt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;例子&lt;/title&gt; &lt;script src=&quot;angular-1.0.1.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt; 名：&lt;input type=&quot;text&quot; ng-model=&quot;lastName&quot;&gt;&lt;br&gt; 姓：&lt;input type=&quot;text&quot; ng-model=&quot;firstName&quot;&gt;&lt;br&gt; &lt;br&gt; 姓名：&#123;&#123;firstName+&quot; &quot;+ lastName&#125;&#125; &lt;br&gt; 姓名：&#123;&#123;fullName()&#125;&#125;&lt;/div&gt;&lt;script&gt; var app=angular.module(&apos;myApp&apos;,[]); app.controller(&apos;myCtrl&apos;,function($scope)&#123; $scope.firstName=&quot;重庆&quot;; $scope.lastName=&quot;黄&quot;; $scope.fullName = function() &#123; return $scope.firstName + &quot; &quot; + $scope.lastName; &#125; &#125;);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 初始化加载流程 统一过程： 1、浏览器载入HTML，然后把它解析成DOM。2、浏览器载入angular.js脚本。3、AngularJS等到DOMContentLoaded事件触发。4、AngularJS寻找ng-app指令，这个指令指示了应用的边界。5、使用ng-app中指定的模块来配置注入器(\\$injector)。6、注入器($injector)是用来创建“编译服务(\\$compile service)”和“根作用域(\\$rootScope)”的。7、编译服务(\\$compile service)是用来编译DOM并把它链接到根作用域(\\$rootScope)的。 具体过程： AngularJS 应用程序由 ng-app 定义。应用程序在 内运行。ng-controller=”myCtrl” \b属性是一个 AngularJS 指令。用于定义一个控制器。myCtrl 函数是一个 JavaScript 函数。AngularJS 使用$scope 对象来调用控制器。在 AngularJS 中， $scope 是一个应用象(属于应用变量和函数)。控制器的 $scope （相当于作用域、控制范围）用来保存AngularJS Model(模型)的对象。控制器在作用域中创建了两个属性 (firstName 和 lastName)。ng-model 指令绑定输入域到控制器的属性（firstName 和 lastName）。 记住一点：在大型的应用程序中，通常是把控制器存储在外部文件中。只需要把 &lt;script&gt; 标签中的代码复制到名为 js文件.js 的外部文件中即可，然后在script中引用js文件： 接下来说一下AngularJs中核心的集中特性吧！！ 先来个图！ MVC模块化自动化双向数据绑定 MVC（Model模型 View视图 Controller控制器） 首先要知道为什么要MVC？ AngularJs程序分为3部分：模板，表现层逻辑，数据（model）。 模板：我们用html，css写的ui视图代码，其中包含AngularJs的指令，表达式，并最终会被AngularJs编译机制编译为附加在dom树上。AngularJs的指令（directive）可以由我们自由扩展。 表现层逻辑：包括应用程序逻辑和行为。用javascript定义作为视图控制器逻辑。在AngularJs作为MVC框架，在控制器中我们无需添加对于dom级的事件监听，这些在AngularJs中已经内置了。在ui节点dom事件发生后AngularJs会自动转到scope上的某个行为（Action）逻辑。 数据：视图对象（viewobject）需要被AngularJs Scope（1.0中作为service出现）引用，可以使任何类型的javascript对象，数组，基本类型，对象。并且AngularJs会自动异步更新模型，即在ui发生改变的时他会自动刷新模型（mode），反之在模型发生改变的时候也会自动刷新ui。在这里我们不需要定义形如getter，setter的一些列方法。 MVC之间的关系，下面这张图看一下MVC中都包含些什么东西 再看下面这张图-其中service是共用的的东西抽象出来的服务 模块化 AngularJs的模块（module):它是一个集合，相当于一个框子，由模型，视图，过滤器，服务等等组成 我们都知道JavaScript很容易就写出全局函数，所以无论是用jQuery还是纯JavaScript，我们都会使用模块化的策略避免写出来的函数污染全局。 1234567891011121314HTML代码:&lt;!doctype html&gt;&lt;html ng-app=&quot;HelloAngular&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller=&quot;helloNgCtrl&quot;&gt; &lt;p&gt;&#123;&#123;greeting.text&#125;&#125;,Angular&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;js/angular-1.3.0.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;NgModule1.js&quot;&gt;&lt;/script&gt;&lt;/html&gt; 123456789101112//JS代码1:var modelName = angular.module(&apos;modelName&apos;,[]);modelName .controller(&apos;contollerName&apos;,[&apos;$scope&apos;,function($scope)&#123; $scope.greeting = &#123;$scope.greeting=&#123;text:&apos;hello&apos;&#125;;&#125;&#125;]);//JS代码2function HelloAngular($scope)&#123; $scope.greeting=&#123; text:&apos;hello&apos; &#125;;&#125; 很明显JS1代码函数污染了全局，而Js2代码通过一个模块进行封装，从而避免污染了全局。 在前面我们看到ng-app指令。它的作用是自动启动一个AngularJS应用，ng-app指令一般指派在应用的根元素上，比如，body或者html标签。在每一个HTML文档中，只能有一个AngularJS应用可以被自动启动，在HTML文档中第一个被找到定义在根元素上的ng-app指令将会作为自动启动的应用。那我们在js代码中定义的模块和ng-app有什么关系呢？很明显，它是告诉AngularJS应用在启动时加载指定的模块，假设这里ng-app只是放一个纯标签，而不给它赋值。那么它就不知道这里该加载什么模块，于是，它也不认识在模块中定义的textController控制器。 但是，赋值与否和启动一个AngularJS的应用无关：12345&lt;body ng-app&gt; &lt;div ng-controller=&quot;helloNgCtrl&quot;&gt; &lt;p&gt;&#123;&#123;greeting.text&#125;&#125;,Angular&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; 这样也是可以启动AngularJS应用，并实现name模型的绑定。 看一下ng官方的模块切分方式 最后看一下模块化的完整项目结构，有利于大家对项目的整体认知 双向数据绑定 先来个官方例子：123456789101112131415161718&lt;!doctype html&gt; 2 &lt;html ng-app&gt; 3 4 &lt;head&gt; 5 6 &lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&gt;&lt;/script&gt; 7 8 &lt;/head&gt; 9 10 &lt;body&gt;11 12 Your name: &lt;input type=&quot;text&quot; ng-model=&quot;yourname&quot; placeholder=&quot;World&quot;&gt;//一个输入框，默认内容为World13 14 &lt;hr&gt;15 16 Hello &#123;&#123;yourname || &apos;World&apos;&#125;&#125;!18 &lt;/body&gt;20 &lt;/html&gt; 注:在输入框中输入任何字符都会立即绑定更新到页面. 这里采用ng-model指令（directive）绑定是模型scope属性yourname。并采用表达式将yourname绑定到文本信息中。这里只需要任何的dom时间监听，因为AngularJs内置了。 友情链接：MVC框架-破浪博客AngularJs实战视频AngularJs中文铁锚的CSDN博客模块化","tags":[{"name":"AngularJs","slug":"AngularJs","permalink":"http://yoursite.com/tags/AngularJs/"}]},{"title":"JS-我待this如初见","date":"2016-08-18T09:50:33.000Z","path":"2016/08/18/JS-我待this如初见/","text":"何为this？this是对象，是在运行时基于函数的执行环境(和对象有关)绑定的，首先，当代码没执行前，或没执行到之前，this 是没有指向的,所以切记：在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了。因为this的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。this只要一出现，一定牵扯到函数和对象一般方法：首先分析this所在的函数是被当做哪个对象的方法调用的，则该对象就是this所引用的对象。 其实，this的取值，分五种情况。我们来挨个看一下。 全局和调用普通函数 构造函数 函数作为对象的一个属性 函数用call或apply或bind 事件监听函数中的this 情况1：全局 &amp; 调用普通函数在全局环境下，this永远是window，这个应该没有非议。123console.log(this==window);//turethis.a=20;console.log(window.a); 普通函数在调用时，其中的this也都是window。 1234567var home=&quot;中国&quot;;var person=function()&#123; var home=&quot;河南&quot; console.log(this); //window console.log(this.home); //中国 &#125;person(); 但是严格模式下 this是undefined(竞然)：12345678910function person1()&#123; return this; &#125;person1()===window; //truefunction person2()&#123; &quot;use strict&quot; //严格模式 return this;&#125;person2()===undefined; //true 情况2：构造函数所谓构造函数就是用来new对象的函数。其实严格来说，所有的函数都可以new一个对象，但是有些函数的定义是为了new一个对象，而有些函数则不是。另外注意，构造函数的函数名第一个字母大写（规则约定）。例如：Object、Array、Function等。 如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象 1234567891011121314window.home=&quot;中国&quot;;window.age=&quot;5000+&quot;;function Person()&#123; this.home=&quot;河南&quot;; this.age=20; console.log(this); //Person &#123;home: &quot;河南&quot;, age: 20&#125; console.log(this.home);// 河南&#125;var chongqing = new Person();console.log(chongqing.home); //河南还是中国console.log(chongqing.age); //20还是5000+console.log(age); //5000+还是20 以上代码中，如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象,即上文中的chongqing。 上个例子中构造函数没有返回值，默认返回this，但是若有返回语句，返回一个对象的话，会将return的对象作为返回值12345678910111213function Myclass()&#123; this.a=20;&#125;var o=new Myclass();console.log(o.a); //20function Person()&#123; this.a=20; return &#123; a: 21&#125;;&#125;var o=new Person();console.log(o.a); //21还是20 注意，以上仅限new Person()的情况，即Person函数作为构造函数的情况。如果直接调用Person函数，而不是new Person()，情况就大不一样了。相当于普通函数1234567891011window.home=&quot;中国&quot;;window.age=&quot;5000+&quot;;function Person()&#123; this.home=&quot;河南&quot;; this.age=20; console.log(this); //window 还是Person &#123;home: &quot;河南&quot;, age: 20&#125; console.log(this.home);//???河南还是中国 console.log(home);//???河南还是中国&#125;Person(); 这种情况下this是window，就是相当于普通函数中的this 构造函数还有一种情况，在构造函数的prototype中，this代表着什么？在整个原型链中，this代表的是当前对象的值1234567891011121314window.home=&quot;中国&quot;;window.age=&quot;5000+&quot;;function Person()&#123; this.home=&quot;河南&quot;; this.age=20; console.log(this); //Person &#123;home: &quot;河南&quot;, age: 20&#125;&#125;Person.prototype.getHome=function()&#123; console.log(this.home); //河南&#125;var chongqing= new Person();chongqing.getHome();// 如上代码，在Person.prototype.getHome函数中，this指向的是chongqing对象。因此可以通过this.name获取chongqing.name的值。 其实，不仅仅是构造函数的prototype，即便是在整个原型链中，this代表的也都是当前对象的值。 情况3：函数作为对象的一个方法在这又分两种情况： 函数作为对象的方法被调用,此时函数中的this指向该对象 函数被赋值到了另一个变量中，this的值是window ###1. 如果函数作为对象的一个方法时，并且作为对象的一个方法被调用时，函数中的this指向该对象。1234567891011window.home=&quot;中国&quot;;window.age=&quot;5000+&quot;;var obj=&#123; home:&quot;河南&quot;, person: function()&#123; console.log(this); //Object &#123;home: &quot;河南&quot;&#125; console.log(this.home); //河南 &#125;&#125;;obj.person(); 以上代码中，person不仅作为一个对象的一个方法，而且的确是作为对象的一个方法被调用。结果this就是obj对象。 注意，如果person函数不作为obj的一个方法被调用，会是什么结果呢？ 2. 如果person函数被赋值到了另一个变量中，并没有作为obj的一个方法被调用，那么this的值就是window1234567891011window.home=&quot;中国&quot;;window.age=&quot;5000+&quot;;var obj=&#123; home:&quot;河南&quot;, person: function()&#123; console.log(this); //？？window还是object console.log(this.home); //？？中国还是河南 &#125;&#125;;var person1=obj.person;person1(); 如上代码，如果person函数被赋值到了另一个变量中，并没有作为obj的一个属性被调用，那么this的值就是window,相当于全局了，this.home的值为中国 3.闭包中使用this对象（对象方法函数中又有一个匿名函数）-this用处（诡异） 在ES3中，此时使用this比较糟糕，因为this失去了方向，引用的是window对象，而不是定义函数所在的对象,欣慰的是，this在ES5中是固定的，我们应该清楚地了解这种情况注意： 在ES3中，当函数作为某个对象的方法调用时，this等于那个对象，不过在闭包中，匿名函数的执行环境具有全局性，此时通常this指向window1234567891011var obj=&#123; home:&quot;河南&quot;, person: function()&#123; function person1()&#123; console.log(this); //window console.log(this.home); //undefined &#125; person1();&#125;&#125;;obj.person(); 总结：当this值的宿主环境被封装在另一个函数内部或在另一个函数的上下文被调用时，this将永远是对window对象的引用（再次说明，this在ES5中是固定的） 如何改变上述情况呢？可以在父函数中使用作用域链来保留对this的引用，以使this值不丢失。如下代码演示了如何使用that变量及其作用域来有效跟踪函数上下文12345678910111213var obj=&#123; home:&quot;河南&quot;, person: function()&#123; var that=this; //person作用域中，保存this引用对象obj（而不是window） function person1()&#123; //输出通过作用域得到河南，因为that=this console.log(that); //Object &#123;home: &quot;河南&quot;&#125; console.log(that.home); //河南 &#125; person1();&#125;&#125;;obj.person(); 情况4：函数用call或者apply或bind调用 先简单说一下call和apply和bind如何使用 call(),apply() 关于call和apply，首先这两个方法的用途都是在特定的作用域中调用函数，，都有两个参数call/apply(作用域，传递给函数的参数) 它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数。 apply的用法和call大致相同，只有一点区别，apply只接受两个参数，第一个参数和call相同，第二个参数必须是一个数组，数组中的元素对应的就是函数的形参。注意不同的是接受参数的方式不同，call()传递给函数的参数必须逐个列举出来，而apply()则是参数数组 bind() bind（）创造一个函数的实例，其this值会被绑定到传给bind（）函数的值。 牢记：当一个函数被call或apply或bind调用时，this的值就取传入的对象的值,即call（）或apply或bind（）括号里的对象。 call实例12345678910window.home=&quot;中国&quot;;window.age=&quot;5000+&quot;;var obj=&#123; home:&quot;河南&quot;&#125;;var person=function()&#123; console.log(this); //Object &#123;home: &quot;河南&quot;&#125; console.log(this.home); //河南 &#125;person.call(obj); 还要注意：apply()的参数为空时，默认调用全局对象。 123456789 var x = 0; function test()&#123; alert(this.x); &#125; var o=&#123;&#125;; o.x = 1; o.m = test; o.m.apply(); //0 bind()实例12345678window.color=&quot;red&quot;;var o=&#123;color:&quot;blue&quot;&#125;;function sayColor()&#123; alert(this.color);&#125;var objectSayColor=sayColor.bind(o);objectSayColor(); //blue还是red sayColor()调用bind（）并传入对象o。创建了objectSaycolor（）函数，objectSaycolor（）函数中的this的值等于o，因此，即使是在全局作用域中调用这个函数也会看到“blue”。 情况5：事件监听函数中的this(大家应该熟悉)12345var one = document.getElementByIdx( &apos;one&apos; );one.onclick = function()&#123; alert( this.innerHTML ); //this指向的是one元素， 友情链接：Javascript高级程序设计（第3版）-关于this对象-182页JavaScript启示录-this部分博客-深入理解Js-this博客-js中this慕课网Javascript深入浅出-this部分博客-this关键字详解 Ending（欲知后事如何，且听下回分解）","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Hello World","date":"2016-06-06T08:05:40.000Z","path":"2016/06/06/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}]}]