[{"title":"Github自身踩到的坑","date":"2017-07-28T15:36:05.000Z","path":"2017/07/28/Github自身踩到的坑/","text":"用Github有一两年了，是时候总结一下以前踩得坑了，这些坑开始时还真把自己摔得不轻！！！！！小插曲：自己以前用hexo搭建的博客，每次写博客都要新建.md文件等初始化步骤,然后提交，有些繁琐，再加上自己又换了台电脑，又要部署hexo（虽然不需要重新部署），但还是有些步骤，索性用简书写，方便快捷些！ git pull时ssh: Could not resolve hostname github.com: Name or service not known, fatal: Could not read from remote repository.123456$ git pullssh: Could not resolve hostname github.com: Name or service not knownfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 这个错误好醉，是因为没网了，就很皮 git本地仓库首次push到远程仓库出现错误 ! [rejected] master -&gt; master (fetch first)新建好本地的仓库和远程仓库之后， 经过git add .然后git commit -m &quot;......&quot;最后想推送到远程仓库的时候 git push -u origin master出现下图错误 解决很简单，使用强制推送使用下面的命令git push -f origin master 附上git push 的说明12345678910111213141516171819NAMEgit-push - Update remote refs along with associated objectsSYNOPSISgit push [--all | --mirror | --tags] [--follow-tags] [--atomic] [-n | --dry-run] [--receive-pack=&lt;git-receive-pack&gt;] [--repo=&lt;repository&gt;] [-f | --force] [--prune] [-v | --verbose] [-u | --set-upstream] [--[no-]signed|--sign=(true|false|if-asked)] [--force-with-lease[=&lt;refname&gt;[:&lt;expect&gt;]]] [--no-verify] [&lt;repository&gt; [&lt;refspec&gt;…​]]-f --forceUsually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. Also, when --force-with-lease option is used, the command refuses to update a remote ref whose current value does not match what is expected.This flag disables these checks, and can cause the remote repository to lose commits; use it with care.Note that --force applies to all the refs that are pushed, hence using it with push.default set to matching or with multiple push destinations configured with remote.*.push may overwrite refs other than the current branch (including local refs that are strictly behind their remote counterpart). To force a push to only one branch, use a + in front of the refspec to push (e.g git push origin +master to force a push to the master branch). See the&lt;refspec&gt;... section above for details. github上传时出现error: src refspec master does not match any如下： 引起该错误的原因是，目录中没有文件，空目录是不能提交上去的 解决方法:先提交文件git add . git commit -m &quot;&quot;例如下：1234touch READMEgit add README git commit -m &apos;first commit&apos;git push origin master fatal： unable to create ‘../../.git/index.lock’:File exists 解决方法：把文件index.lock删掉 ###Permission denied (publickey).fatal: The remote end hung up unexpectedly 错误原因：github上没有配置公钥解决方法：配置公钥，并放到github上GitHub设置公钥在windows下面 安装git，从程序目录打开 “Git Bash” 键入命令：ssh-keygen -t rsa -C “email@email.com”“email@email.com”是github账号 提醒你输入key的名称，输入如id_rsa如果执行成功。返回 Generating public/private rsa key pair.Enter file in which to save the key (/home/forwhat.cn/.ssh/id_rsa):在这里就是设置存储地址了.反正我是直接按的回车，一直回车 在C:\\Documents and Settings\\Administrator\\下产生两个文件：id_rsa和id_rsa.pub 把4中生成的密钥文件复制到C:\\Documents and Settings\\Administrator.ssh\\ 目 录下。 用记事本打开id_rsa.pub文件，复制内容，在github.com的网站上到ssh密钥管理页面，添加新公钥，随便取个名字例如你的电脑名 需要注意步骤2中产生的密钥文件在当前用户的根目录，必须把这两个文件放到当前用户目录的“.ssh”目录下才能生效。 坑不会踩完的，但会一直进步着，大家加油……","tags":[]},{"title":"Hello World","date":"2017-07-28T15:03:14.573Z","path":"2017/07/28/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"Sublime侧边栏[SideBar]字体变大","date":"2017-01-15T08:05:40.000Z","path":"2017/01/15/Sublime侧边栏字体变大/","text":"","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}]},{"title":"MPic神器-上传照片直接生成外链","date":"2017-01-12T06:31:40.000Z","path":"2017/01/12/Mpic神器/","text":"一直以来写博文，上传本地照片是一个特别麻烦的事，一来webstorm收费，其次cmd Markdown上传照片只支持外联，而上传照片到七牛云不失为一个好方法，但操作过程复杂，正在我愁眉不展时，上网一搜，搜到了一神器Mpic-图床神器。可以和七牛云绑定一起发挥威力。下载链接经过自己的一番折腾，最终发现MPic果然省时省事不少，目前我知道的上传方式有2种： 截图上传（QQ截图个人感觉不错） 拖拽本地图片上传下载之后的界面：下面介绍一下下载软件之后的操作步骤： 下载之后首先就是注册账号注意几个问题： 首先你用默认域名时，账户余额应不少于10元; 申请存储空间七牛云自己会带个域名，用这个自带的域名就可以，如下图，当然，用自己绑定的域名也可以，不过域名必须是注册过的，注册很麻烦耗时，不嫌麻烦的也可以试试。 在我的上传中，可查看和删除自己之前上传过的照片 好，大功告成，终于可以好好地写自己的博客，顺带肆意的上传自已的照片了！！哈哈哈","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}]},{"title":"HTML5-canvas之绘制圆弧和贝塞尔曲线(3)","date":"2017-01-01T09:50:33.000Z","path":"2017/01/01/HTML5-canvas之绘制圆弧和贝塞尔曲线/","text":"今天我们主要是学习如何绘制圆弧和贝塞尔曲线。 圆弧的绘制圆弧可以理解为一个圆上的某部分线段，在canvas中，绘制一条圆弧的语法如下：1ctx.arc( 圆心x坐标, 圆心y坐标, 圆的半径r , 开始角度, 结束角度 ); 其中的 “开始角度” 和 “结束角度” 是相对360度的 顺时针 的极坐标而言的，可配合下图理解： 我们来一个例子，绘制一个圆心坐标为(80,80)，半径为40，开始角度为30度，结束角度为90度，那么可以这样绘制： 12345678910&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.arc( 80, 80, 40, 1/6*Math.PI, 1/2*Math.PI);ctx.stroke(); //描边&lt;/script&gt; 其中开始角和结束角我们分别设定为“1/6Math.PI”和“1/2Math.PI”，是因为canvas里的角度是以PI（π）为单位的，在js中写作Math.PI，你可以把一个PI理解为180度，那么30度便是1/6个PI。上述代码效果如下： 开始角和结束角也可以是负值，则角度从0度开始以逆时针方式获取：1234var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.arc( 80, 80, 40, -1/6*Math.PI, -1/2*Math.PI);ctx.stroke(); //描边 我们可以很轻松地来绘制一个完整的圆，将起始角设为0度，结束角设为360度（2*Math.PI）即可： 123456789var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.arc( 80, 80, 40, 0, 2*Math.PI);ctx.lineWidth = 3; //描边宽度为3pxctx.strokeStyle = &quot;yellow&quot;;ctx.stroke(); //描边ctx.fillStyle = &quot;#4DA6FF&quot;;ctx.fill(); //填充颜色 注意给圆填充颜色我们使用的是 .fill() 方法，和多边形的填充方式一样。 接着说说 arc() 的好兄弟 arcTo() 方法，它可以在两条线段之间连接起一条弧线，其语法如下 ctx.arcTo( 起点切线末端x坐标, 起点切线末端y坐标, 终点x坐标, 终点y坐标, 圆的半径r ); 可以配合下图理解： 我们先不管什么“连接两条线段”的事情，单纯看下arcTo()绘制了怎样的一条圆弧：1234567891011&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.moveTo(20,20); // 创建开始点ctx.arcTo(60,20,60,60,40); // 创建圆弧路径ctx.stroke(); &lt;/script&gt; 那么我们利用arcTo()方法来连接两条直线吧： 12345678910111213&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.moveTo(20,20);ctx.lineTo(60,20);ctx.arcTo(100,20,100,60,40); // 创建圆弧路径ctx.lineTo(100,100);ctx.stroke(); &lt;/script&gt; 需要知道的是 arc() 不会影响画笔的位置，而 arcTo() 会把画笔移到圆弧线的终点位置。 曲线的绘制无论是arc()抑或arcTo()，均是绘制了一个正圆上的部分圆弧线段，下面讲讲更灵活的曲线的绘制。 首先介绍的是canvas中贝塞尔曲线的绘制。使用过AI等专业矢量制图软件的朋友相信能很好地理解这一部分。我们先看下在制图软件中用钢笔工具绘制一条贝塞尔曲线的过程： 可以看到每两点可以连成一条贝塞尔路径，且每一个点都有一条方位控制线来控制曲线的弯曲程度和走向，在canvas中也是以类似形式控制贝塞尔曲线的形状。 我们先来看看bezierCurveTo()的实现方式，它称作“三次方贝塞尔曲线”，其语法为：1ctx.bezierCurveTo( CSx, CSy, CEx, CEy, Ex, Ey ); 其中CSx、CSy表示贝塞尔曲线起点方向控制线末端的x坐标和y坐标。CEx、CEy表示贝塞尔曲线终点方向控制线末端的x坐标和y坐标。Ex、Ey表示贝塞尔曲线终点坐标。 参考图如下，图中的贝塞尔曲线起点坐标为（20,20），终点坐标为（200,20），起点的方向控制线末端坐标为（20,100），终点的方向控制线末端坐标为（200,100）： 有的朋友可能会问为何bezierCurveTo()方法没有起始点的参数，答案是起始点默认为bezierCurveTo()方法执行之前画笔所在的位置，我们可以通过ctx.moveTo(x,y)来确定起始点的位置。 如上图所示的贝塞尔曲线我们可以这样绘制：1234567891011&lt;canvas id=&quot;myCanvas&quot; width=&quot;300&quot; height=&quot;150&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.moveTo(20,20); //确定起始点ctx.bezierCurveTo( 20, 100, 200, 100, 200, 20 );ctx.stroke(); //描边&lt;/script&gt; 我们可以绘制两条或者多条连在一起的贝塞尔曲线，从而塑造我们想要的曲线： 123456789101112&lt;canvas id=&quot;myCanvas&quot; width=&quot;400&quot; height=&quot;250&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.moveTo(20,120); //确定起始点ctx.bezierCurveTo( 20, 200, 200, 200, 200, 120 ); //绘制第一条贝塞尔曲线ctx.bezierCurveTo( 200, 20, 380, 20, 380, 120 ); //绘制第二条贝塞尔曲线，该曲线起点为上一条曲线终点（200，120）ctx.stroke(); //描边&lt;/script&gt; 使用过矢量制图软件的朋友可能有个地方会困惑，那就是我们很多时候开始绘制一条曲线时（起点不做拉伸），该曲线的起点是没有任何方向控制线的，如下图： 如果我们要绘制一条起点不做方向控制的曲线，那么bezierCurveTo()方法就不再适用了。 针对这种情况，可以通过 quadraticCurveTo() 方法来解决，它称作“二次方贝塞尔曲线”，语法为 ctx.quadraticCurveTo( CEx, CEy, Ex, Ey ); 其中CEx、CEy表示曲线终点方向控制线末端的x坐标和y坐标。Ex、Ey表示曲线终点坐标。至于曲线起点则跟bezierCurveTo()一样，为该方法执行前画笔所在的位置。 我们试着来绘制一条这样的曲线，它是我在AI中用钢笔工具绘制出来的： 它的矢量轮廓是这样的： 由于起点是没有方向控制线的，我们很容易知道得先绘制一条quadraticCurve，然后再紧接着绘制一条bezierCurve来完成这条曲线。 我们先确定下各点的坐标： 然后轻松写出代码： 123456789101112&lt;canvas id=&quot;myCanvas&quot; width=&quot;490&quot; height=&quot;270&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.moveTo(52,37); //确定起始点ctx.quadraticCurveTo( 45, 175, 172, 157 ); //绘制第一条曲线ctx.bezierCurveTo( 298, 140, 337, 201, 312, 236 ); //绘制第二条曲线ctx.stroke(); //描边&lt;/script&gt; 效果杠杠的 建议有兴趣的朋友多实践，其中贝塞尔曲线部分的知识点可以通过AI等矢量设计软件来加深理解。共勉~ 啦啦啦还有，大家元旦快乐啊！ 有关链接 http://www.cnblogs.com/vajoy/p/3925190.html","tags":[{"name":"html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"HTML5-Canvas之矩阵和多边形的绘制（2）","date":"2016-12-25T09:50:33.000Z","path":"2016/12/25/HTML5-Canvas之矩阵和多边形的绘制/","text":"上篇文章我们了解了canvas的定义、获取和基础的绘图操作，其中的绘图功能我们讲解了线段绘制、上色、描边等方面知识点。 今天我们来讲讲矩形（Rectangle）和多边形的绘制。 矩形的绘制一共有两个口令，分别是 ctx.fillRect(x, y, width, height) 和 ctx.strokeRect(x, y, width, height) ，参数中的 x 和 y 依旧表示需绘制的矩形的起始点坐标（相对canvas原点），width 和 height表示需绘制的矩形宽高。 而 fillRect 表示绘制一个实心矩形，strokeRect 表示绘制一个描边矩形，我们来一个简单的例子：12345678910&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.fillRect(10,10,50,50); //从画布上的(10,10)坐标点为起始点，绘制一个宽高均为50px的实心矩形ctx.strokeRect(70,10,50,50); //从画布上的(70,10)坐标点为起始点，绘制一个宽高均为50px的描边矩形&lt;/script&gt; 效果如下 你也可以使用 Rect( x, y, width, height ) 的方法创建矩形路径，之后再通过 .stroke() 或 .fill() 方法来给矩形上色： 1234567var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.rect(20,20,150,100); //创建矩形路径ctx.stroke(); //描边ctx.beginPath(); //重置画笔，避免污染ctx.rect(50,90,50,50); //创建矩形路径ctx.fill(); //填充 效果如下 上方我们绘制了两个默认黑色的实心和描边矩形，相信你也联想到上一章我们绘制线段时，若没有定义strokeStyle，则线段也是默认为黑色的事情。那么我们要给这俩矩形上色，或许你也会联想到应当使用 *Style 来处理，而这想法也是正确的。 在canvas上，给实心对象上色可以用 fillStyle 来定义，给描边对象上色我们可以用 strokeStyle来定义，它们的赋值均为 color|gradient|pattern ，在上章我们已经细说过，这里不再赘述。 那么我们来给上方绘制了的实心矩形填充一个放射状渐变（黄-蓝-红），将描边矩形的描边设为绿色。我们可以这样做： 12345678910111213141516171819&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象var grd = ctx.createRadialGradient(35,35,0,35,35,36); //定义放射状渐变对象，设定渐变线起始点和结束点坐标，坐标格式为(起始点x,起始点y,结束点x,结束点y)grd.addColorStop(0,&quot;yellow&quot;); //定义渐变线起点颜色grd.addColorStop(0.5,&quot;blue&quot;); //定义渐变线中间点的颜色grd.addColorStop(1,&quot;red&quot;); //定义渐变线结束点的颜色ctx.fillStyle = grd; //将放射状渐变对象赋值给fillStylectx.fillRect(10,10,50,50); //从画布上的(10,10)坐标点为起始点，绘制一个宽高均为50px的实心矩形ctx.beginPath(); //重置画笔，这是个好习惯ctx.strokeStyle = &quot;green&quot;; //定义描边颜色为绿色ctx.strokeRect(70,10,50,50); //从画布上的(70,10)坐标点为起始点，绘制一个宽高均为50px的描边矩形&lt;/script&gt; 效果如下 这里要提到的是上一次没有仔细介绍过的放射状渐变方法 createRadialGradient ，其语法为 ctx.createRadialGradient( Xstart, Ystart, Radiusstart, Xend, Yend, Radiusend ) 其中前三个参数表示渐变起始圆形的中心坐标和半径，后三个参数表示渐变结束圆形的中点坐标和半径。 或许你会被这里的“半径”迷惑，回顾我们上章学习的createLinearGradient，它的参数并没有“半径”的概念，如果你是一名平面设计师，你更可能觉得放射状渐变只需要起始点和结束点坐标就可以了（毕竟PS/AI中的径向渐变只需要这两个点）。 但canvas在这里加入的“半径”参数还是有一定作用的，可以创造出比PS中径向渐变稍微复杂一些的效果。 ⑴ 我们先来一个最简单最好理解的例子：123456789var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象var grd = ctx.createRadialGradient(70,70,0,70,70,100); //定义放射状渐变对象，设定起始圆和结束圆中点重叠，且起始圆半径为0grd.addColorStop(0,&quot;yellow&quot;); //定义渐变线起点颜色grd.addColorStop(0.5,&quot;blue&quot;); //定义渐变线中间点的颜色grd.addColorStop(1,&quot;rgba(255,0,0,0)&quot;); //定义渐变线结束点的颜色，其中颜色透明度为0ctx.fillStyle = grd; //将放射状渐变对象赋值给fillStylectx.fillRect(0,0,c.width,c.height); //绘制一个跟画布大小一样的实心矩形 我们设置起始圆和结束圆中点相同，且起始圆半径为0，那么它的渐变线就是从两圆的中点开始到结束圆的边缘结束。我们设置渐变线结束点颜色透明度为0是为了方便查看结束圆的边界。效果如下： ⑵ 我们在⑴的基础上将起始圆的半径设为20，代码和效果图如下：123456789var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象var grd = ctx.createRadialGradient(70,70,20,70,70,100); //定义放射状渐变对象，设定起始圆和结束圆中点重叠，且起始圆半径为20grd.addColorStop(0,&quot;yellow&quot;); grd.addColorStop(0.5,&quot;blue&quot;); grd.addColorStop(1,&quot;rgba(255,0,0,0)&quot;); ctx.fillStyle = grd; ctx.fillRect(0,0,c.width,c.height); ⑶ 我们在⑵的基础上挪动起始圆的中点，不要让它跟结束圆的中点重叠，代码和效果图如下： 123456789var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象var grd = ctx.createRadialGradient(60,40,20,70,70,100); //起始圆不仅有半径，而且中点跟结束圆中点不相同grd.addColorStop(0,&quot;yellow&quot;); grd.addColorStop(0.5,&quot;blue&quot;); grd.addColorStop(1,&quot;rgba(255,0,0,0)&quot;); ctx.fillStyle = grd; ctx.fillRect(0,0,c.width,c.height); 注意我们在定义RadialGradient时，要尽量避免起始圆的范围超出结束圆的范围（起始圆最好是结束圆内部的一个真子集），否则绘制出来的效果会出现无法预知的错误，例如下面的代码：123456789var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象var grd = ctx.createRadialGradient(60,60,50,70,70,50); //起始圆的左边超出了结束圆内部区域grd.addColorStop(0,&quot;yellow&quot;); grd.addColorStop(0.5,&quot;blue&quot;); grd.addColorStop(1,&quot;rgba(255,0,0,0)&quot;); ctx.fillStyle = grd; ctx.fillRect(0,0,c.width,c.height); 不过如果你掌握了RadialGradient上色原理，倒是可以随意定位起始圆和结束圆的方位和大小。我从TimeLangoliers的博客（点击查看出处）看到这张原理图：他还依照此原理图写了一个例子：12345678910var canvas = document.getElementById(id); if (canvas == null) return false; var context = canvas.getContext(&apos;2d&apos;); var g1 = context.createRadialGradient(100, 150, 10, 300, 150, 50); g1.addColorStop(0.1, &apos;rgb(255,0,0)&apos;); g1.addColorStop(0.5, &apos;rgb(0,255,0)&apos;); g1.addColorStop(1, &apos;rgb(0,0,255)&apos;); context.fillStyle = g1; context.fillRect(0, 0, 400, 300); 至此我们学习了通过 fillRect 和 strokeRect 来绘制矩形，下面再讲一个Rect相关的功能——clearRect。 clearRect类似PS中的方块橡皮擦，可以擦除画布上任意一块矩形区域的内容，其语法如下： ctx.clearRect( x, y, width, height ); 其中 x 和 y 表示起始点坐标，width 和 height 表示这块“橡皮擦”的宽高。举个例子：123456789var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.fillStyle = &quot;red&quot;; ctx.fillRect(0,0,c.width,c.height); ctx.beginPath();ctx.fillStyle = &quot;blue&quot;; ctx.fillRect(10,20,60,60); ctx.clearRect(20,20,80,50); //擦除以（20,20）坐标为起点，宽高为80*50的区域 注意clearRect不会清除掉之前定义过的样式、画笔位置等绘制信息，打个比方，有时候我们需要清空整个画布，我们可以这样做：12345678910var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.fillStyle = &quot;blue&quot;; ctx.fillRect(10,20,60,60); //下面重置画布大小，从而清空画布c.width = c.width; //在jQ中可以写为 c.attr(&quot;width&quot;, c.width()); c.height = c.height; //在jQ中可以写为 c.attr(&quot;height&quot;, c.height()); //重新绘制一个矩形ctx.fillRect(10,20,60,60); 这个方法是通过重置画布大小，从而触发清空画布事件，但前面定义的 fillStyle=”blue” 也被清空掉了，从而绘制了一个黑色的矩形： 如果不想清除掉之前定义的样式，我们可以通过clearRect来实现：123456789var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.fillStyle = &quot;blue&quot;; ctx.fillRect(10,20,60,60); //下面通过clearRect来擦除画布ctx.clearRect(0,0,c.width,c.height);//重新绘制一个矩形ctx.fillRect(10,20,60,60); 执行结果如下： 最后聊一下多边形的绘制，其实现非常简单，先来个例子：123456789101112131415161718var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象//定义样式ctx.fillStyle = &quot;blue&quot;; ctx.strokeStyle = &quot;red&quot;;ctx.lineWidth = &quot;8&quot;;ctx.lineJoin = &quot;round&quot;;//绘制多边形ctx.moveTo(10,10);ctx.lineTo(100,30);ctx.lineTo(120,80);ctx.lineTo(60,60);ctx.lineTo(10,10);ctx.stroke(); //描边ctx.fill(); //填充 可见我们这里通过lineTo绘制了多边形的每条边（注意起点跟终点是同一个坐标），然后通过 stroke() 来描边、fill() 来填充，其执行效果如下： 眼尖的朋友会发现该多边形左上角的俩条描边没有接在一起，这是因为我们没有把这个多边形路径闭合起来，我们可以通过 ctx.closePath() 来解决这个问题： 眼尖的朋友会发现该多边形左上角的俩条描边没有接在一起，这是因为我们没有把这个多边形路径闭合起来，我们可以通过 ctx.closePath() 来解决这个问题：123456789101112131415161718var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象//定义样式ctx.fillStyle = &quot;blue&quot;; ctx.strokeStyle = &quot;red&quot;;ctx.lineWidth = &quot;8&quot;;ctx.lineJoin = &quot;round&quot;;//绘制多边形ctx.moveTo(10,10);ctx.lineTo(100,30);ctx.lineTo(120,80);ctx.lineTo(60,60);ctx.lineTo(10,10);ctx.closePath(); //闭合多边形路径ctx.stroke(); //描边ctx.fill(); //填充 这次就到这里，下次再见了！、 学习链接 canvas学习笔记HTML5- Canvas入门（二）玩转html5画图","tags":[{"name":"html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"HTML5-Canvas初探（1）","date":"2016-12-18T09:50:33.000Z","path":"2016/12/18/HTML5-Canvas初探/","text":"canvas其实没有那么玄乎，它不外乎是一个H5的标签，跟其它HTML标签如出一辙：1&lt;canvas&gt;&lt;/canvas&gt; canvas 元素用于在网页上绘制图形。 那么什么是 Canvas？ HTML5 的 canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，您可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 canvas本身没有任何的绘图能力，所有的绘图工作都是通过js来实现的。通常我们在js通过getElementById来获取要操作的canvas（这意味着咱得给canvas设个id）：123456&lt;canvas id=&quot;myCanvas&quot;&gt;&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;); //获取要操作的canvas//操作canvas的代码...&lt;/script&gt; 注意最好在一开始的时候就给canvas设置好其宽高（若不设定宽高，浏览器会默认设置canvas大小为宽300、高100像素），而且不能使用css来设置（会被拉伸），建议直接写于canvas标签内部： &lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt; 也可以在js脚本中设置： 1234567&lt;canvas id=&quot;myCanvas&quot;&gt;&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);c.width=200;c.height=200;&lt;/script&gt; 为什么不能用css来设置呢？这是因为 canvas 元素有元素本身大小与元素绘图表面大小两套尺寸。 设置 width 和 height 时，实际上是同时修改了该元素本身大小和元素绘图表面大小； 而设置 css，只会改变元素本身大小，并不会改变元素绘图表面大小。 关于canvas大小需要知道的一点是，后续咱们对canvas所做的全部绘图操作，超出此大小范围的部分是不可见的。顾名思义，可以把canvas看成一块画布，其大小是咱设定好的宽高，那么无论你怎么画，画布外的地方自然是画不到的。 对于有些浏览器是不支持canvas功能的，我们可以直接在canvas标签中写一些替换内容，在浏览器不支持canvas时显示：123&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt; 接着在聊如何在canvas上绘图前，咱得先说说.getContext(“2d”)这东西。.getContext() 是canvas的绘图对象/方法，要让canvas执行绘图工作必须先获取canvas的.getContext()对象来执行。 .getContext()只接受一个参数，该参数用于获取canvas的绘图环境，例如.getContext(“2d”)表示该canvas的绘图环境为2D平面（可以绘制文本、直线、弧线、矩形、圆形等）。当前H5只支持2D环境，在不久的将来会开放3D绘图功能。（故咱可将“getContext”翻译为“获取绘图环境”） 接下来：主要是对canvas线段绘制功能的介绍理论不多说，我们先来个小例子，从最简单的绘制直线开始： 1234567891011&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.moveTo(10,10); //定义绘画开始的位置ctx.lineTo(150,50); //画一条直线，结束点坐标是x=150,y=50ctx.stroke(); //描边&lt;/script&gt; 效果如下：在这里我们使用了3个getContext(“2d”)对象的绘图方法： .moveTo(x坐标 , y坐标) 可以理解为定位画笔在画布上的位置（注意所有绘图方法所定义的坐标是相对canvas而言的而不是浏览器窗口，对canvas来说，最左上角的点的坐标是(0,0)） .lineTo(x坐标 , y坐标) 顾名思义，就是画一条直线到某个点，很好理解。需要知道的是此方法仅仅做路径运动，而不存在任何视觉上的绘图效果（上色、描边） .stroke() 描边方法，有玩过AfterEffect的朋友会很清楚，不给运动路径加stroke特效的画是不存在描边效果的，canvas也一样，想要运动路径轨迹能有视觉效果，需要使用相应的上色/描边方法 自此我们很轻松地绘制了一条黑色的直线，但如果我们想要绘制一条红色的或者其它颜色的线段，该怎么做呢？ 答案很简单，使用ctx.strokeStyle来设定描边的颜色即可。我们画三条红色的线段吧： 123456789&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:solid 1px #CCC; margin:30px;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.moveTo(0,0); //咱把“画笔”移到坐标(0,0)ctx.line 注释都说的很清楚了，故不再赘述实现原理，其效果如下： 注意在开始绘制路径的时候，一定要加上moveTo(x,y)，否则第一个lineTo()的运动轨迹将不计入绘图中（浏览器会认为没获取到该运动轨迹的起始点，故忽略此线段）。 另外有一个问题，如果上方我们会出来的两条线段（嗯，一条折线，一条直线），我们希望第一条折线是蓝色的，第二条直线是红色的，应当怎么做？ 你会很自然地做如下处理：1234567891011121314&lt;script&gt; var c = document.getElementById(&quot;myCanvas&quot;); var ctx = c.getContext(&quot;2d&quot;); ctx.moveTo(0,0); ctx.lineTo(150,50); ctx.lineTo(20,100); ctx.strokeStyle = &quot;blue&quot;; //设定描边颜色为蓝色 ctx.stroke(); ctx.moveTo(90,90); ctx.lineTo(80,150); ctx.strokeStyle = &quot;red&quot;; //设定描边颜色为红色 ctx.stroke(); &lt;/script&gt; 但运行脚本会发现，折线除了被描了一遍蓝色，也被描了一遍红色：这是因为canvas在第二次给路径上色时，是把之前的所有路径轨迹合在一起来上色的，除非咱们让canvas知道那折线和直线应该是独立开来的俩路径。 我们可以使用.beginPath()来解决： 123456789101112131415&lt;script&gt; var c = document.getElementById(&quot;myCanvas&quot;); var ctx = c.getContext(&quot;2d&quot;); ctx.moveTo(0,0); ctx.lineTo(150,50); ctx.lineTo(20,100); ctx.strokeStyle = &quot;blue&quot;; //设定描边颜色为蓝色 ctx.stroke(); ctx.beginPath(); //告诉canvas咱们要重新绘制一条全新的路径了，之前画的东西从此再无关系 ctx.moveTo(90,90); ctx.lineTo(80,150); ctx.strokeStyle = &quot;red&quot;; //设定描边颜色为红色 ctx.stroke(); &lt;/script&gt; 有的朋友一开始会搞不清楚beginPath()的用途，觉得有moveTo()就可以了，其实beginPath()可以做到上述的隔离路径绘制效果的作用，防止之前的效果被污染。 接着唠嗑.strokeStyle的赋值方式，咱们上方是直接用了 ctx.strokeStyle=”red” 来定义描边颜色为红色，不过ctx.strokeStyle可获值的形式有三种： ctx.strokeStyle=color|gradient|pattern; //即支持 “颜色/渐变/图案笔刷” 的赋值 先看看color赋值方式，和我们常规的css赋值是一样的，支持css3颜色值标准，如下例：12345//下面四种形式都是一样的，表示描边颜色为“橙色”ctx.strokeStyle = &quot;orange&quot;;ctx.strokeStyle = &quot;#FFA500&quot;; //#rrggbb形式ctx.strokeStyle = &quot;rgb(255,165,0)&quot;; //RGB形式ctx.strokeStyle = &quot;rgba(255,165,0,1)&quot;; //比上面的rgb多了个a（Alpha），即透明度 2 . 再看下渐变gradient，这个稍有复杂： 12345678910111213var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); ctx.moveTo(0,0); ctx.lineTo(150,50); ctx.lineTo(20,100); var grd = ctx.createLinearGradient(0,0,170,0); //定义线性渐变对象，设定渐变线起始点和结束点坐标，坐标格式为(起始点x,起始点y,结束点x,结束点y)grd.addColorStop(0,&quot;black&quot;); //定义渐变线起点颜色grd.addColorStop(0.5,&quot;red&quot;); //定义渐变线中间点的颜色grd.addColorStop(1,&quot;yellow&quot;); //定义渐变线结束点的颜色ctx.strokeStyle = grd; //将渐变对象赋值给strokeStylectx.stroke(); //描边 效果如下： 这里我们提到了一个概念叫“渐变线”，没有玩过设计的朋友需要了解下渐变的知识点，我们可以把LinearGradient（线性渐变，另有放射状/圆形渐变RadialGradient）范围看成一个矩形（你可以通过Illustator、Photoshop等专业设计软件来辅助你理解这点）：我们一开始定义线性渐变对象的代码 var grd = ctx.createLinearGradient(0,0,170,0) 不外乎就是设定了线性渐变线起始点为(0,0)，结束点为(170,0)。 紧接着我们通过 addColorStop( 渐变线位置, 颜色 ) 来设定了渐变色值，分别在渐变线0、0.5、1的位置设置了黑色、红色、黄色，其渐变效果如下：通过 ctx.strokeStyle = grd 将渐变赋值给描边方法，最终描边得到了我们想要的渐变效果。 3 . 最后看看pattern描边方式，strokeStyle之所以不叫strokeColor是因为它除了支持颜色描边还支持图案描边（搞设计的朋友或许称作笔触描边会更有feel）。 线性渐变描边需要先createLinerGradient(xstart,ystart,xend,yend)，那么设置图案描边自然也要先新建一个canvasPattern对象：1createPattern(image, repetitionStyle) 其中参数 image 代表图案对象，一般通过 document.createElement(‘img’) 或者 new Image() ，再定义其src值来创建该对象。而repetitionStyle参数很好理解，即图案重复形式，其可选值有”repeat” 、”repeat-x”、”repeat-y” 和”no-repeat” （和css的background-repeat可选值一样，不赘述）。 我们这样写1234567891011121314151617&lt;body&gt;&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:solid 1px #CCC; margin:30px;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt; var c = document.getElementById(&quot;myCanvas&quot;); var ctx = c.getContext(&quot;2d&quot;); pic = new Image(); //创建图片对象，或者 pic = document.createElement(&apos;img&apos;) pic.src = &quot;http://images.cnblogs.com/cnblogs_com/vajoy/558870/o_5.jpg&quot;; //定义图片的映射地址 var redTexture = ctx.createPattern(pic, &quot;repeat&quot;); //定义Pattern对象，设定填充图案为pic图片，填充形式为平铺 ctx.strokeStyle = redTexture; //定义描边样式为上一行设定的Pattern描边 ctx.moveTo(80,10); ctx.lineTo(10,90); ctx.stroke();&lt;/script&gt; 效果如下：注意这里我还加了个 ctx.lineWidth = 8 来设定线段的粗度。 自此我们学习了strokeStyle的三个赋值方式，也学习了上述的通过 ctx.lineWidth = lineWeight 的形式来给线段设定粗度。 咱们再学习两个很简单的线段属性 lineCap 和 lineJoin。 ⑴ lineCap是设定线段端点的形状（线帽），其值可以是 butt 默认，即线条端点为平直的边缘round 线条端点为圆角线帽square 为线条端点添加正方形线帽 1234567891011121314151617181920212223242526272829&lt;canvas id=&quot;myCanvas&quot; width=&quot;250&quot; height=&quot;120&quot; style=&quot;border:1px solid #DDD;&quot;&gt;&lt;/canvas&gt;&lt;script&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.lineWidth=10;ctx.beginPath();ctx.lineCap=&quot;butt&quot;;ctx.moveTo(20,10);ctx.lineTo(200,60);ctx.strokeStyle=&quot;red&quot;;ctx.stroke();ctx.beginPath();ctx.lineCap=&quot;round&quot;;ctx.moveTo(30,90);ctx.lineTo(200,40);ctx.strokeStyle=&quot;blue&quot;;ctx.stroke();ctx.beginPath();ctx.lineCap=&quot;square&quot;;ctx.moveTo(10,30);ctx.lineTo(200,80);ctx.strokeStyle=&quot;green&quot;;ctx.stroke();&lt;/script&gt; 效果如下： 光看此图可能看不太出“butt”和”square”的区别，但懂得使用AI绘制矢量的同学们应该比较了解： ⑵ lineJoin则是设定折线的交接处的外角类型，其值可为： miter 默认，折线交接处为尖角round 折线交接处为圆角bevel 折线交接处为斜角 12345678910111213141516171819202122232425262728293031&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;220&quot; style=&quot;border:1px solid #DDD;&quot;&gt;&lt;/canvas&gt;&lt;script&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.lineWidth=13;ctx.lineJoin=&quot;bevel&quot;;ctx.moveTo(20,20);ctx.lineTo(100,50);ctx.lineTo(20,80);ctx.strokeStyle=&quot;red&quot;;ctx.stroke();ctx.beginPath();ctx.lineJoin=&quot;round&quot;;ctx.moveTo(20,60);ctx.lineTo(100,90);ctx.lineTo(20,150);ctx.strokeStyle=&quot;green&quot;;ctx.stroke();ctx.beginPath();ctx.lineJoin=&quot;miter&quot;;ctx.moveTo(20,90);ctx.lineTo(100,150);ctx.lineTo(20,200);ctx.strokeStyle=&quot;blue&quot;;ctx.stroke();&lt;/script&gt; 效果如下 需要了解的是，miter还受到了属性miterLimit的影响（点此查看详细），但个人觉得它跟bevel实现的效果是一致的，故在此不做介绍。这次就到这里了，下次再见了啦！ 下面推荐一下其他很好的博文HTML5- Canvas入门（一）玩转html5&lt;canvas&gt;画图","tags":[{"name":"html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"项目常用的less语法详解","date":"2016-12-10T09:50:33.000Z","path":"2016/12/10/项目常用的less语法详解/","text":"什么是less？ less是一种动态样式语言，属于css预处理语言的一种，类似于css的语法，为css赋予了动态语言的特性，如变量、继承，运算，函数等，更方便css的编写和维护 编译工具 Koala编译 国人开发的less/sass编译工具、 下载地址： http://koala-app.com/index-zh.html 常用： 输出方式compress(进行压缩) Node.js库 浏览器端使用Koala配置及使用 新建后缀为.less文件：index.less头部写上：@charset “utf-8”; //设定字符集 把文件夹拖到koala中，设置输出路径为style下的index.css使用koala进行编译，然后就生成了一个index.css文件。 之后我们只要编辑index.less文件即可。 项目中常用的语言特性注释 less有两种注释 //*会在css中编译出来/*/ //不会在css中编译出来第一种的注释会在css中编译出来，第二种不会 变量： 变量允许我们单独定义一系列通用的样式，然后在需要的时候去调用。所以在做全局样式调整的时候我们可能只需要修改几行代码就可以了。 less中声明变量用@开头，例：@变量名：值；less源码：12@margin-left:30px;box&#123;margin: margin-left;&#125; 编译后的css1box&#123;margin:30px;&#125; 混合模式（Mixins） 混合可以将一个定义好的class A轻松的引入到另一个class B中，从而简单实现class B继承class A中的所有属性。我们还可以带参数地调用，就像使用函数一样。 123456789101112131415161718192021222324252627282930313233343536373839404142//混合.box&#123; width: @text_width; height: 100px; background: green; .border;&#125;.border&#123; border:solid 1px pink;&#125;//混合，可带参数.border_02(@border_width)&#123; border:solid yellow @border_width;&#125;.test_mix2&#123; .border_02(30px); //注意：参数不初始化，括号里必须要有个值，&#125;//混合默认带值.border_03(@border_width:10px)&#123; border:solid yellow @border_width;&#125;.test_mix3&#123; .border_03();&#125;//混合好例子（适用多个浏览器）.border_radius(@radius:5px)&#123; -webkit-border-radius:@radius; -moz-border-radius:@radius; border-radius:@radius;&#125;.radius_test&#123; width: 100px; height: 100px; background: pink; .border_radius(30px);&#125; 匹配模式： 有点像switch或者if 判断满足哪个条件就用哪一个。 其他的就是混合。 @_ ： ,这个很强大：无论匹配到什么值，均会运行，类似于成全局了（函数名一致） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465.float(left)&#123; float:left; &#125;//调用匹配模式：那么就是： .setFloat&#123; .float(left); &#125; //举个三角例子//匹配模式(原始)// .tri_test&#123; // width: 0; // height: 0 // overflow: hidden;// border-width: 150px;// border-color: red transparent transparent transparent;// border-style: solid dashed dashed dashed ;//dashed 虚线// &#125;//匹配模式.triangle(top, @w: 5px, @c:#ccc)&#123; //朝上 border-width: @w; border-color: transparent transparent #ccc transparent; border-style: dashed dashed solid dashed ;//dashed 虚线&#125;.triangle(bottom, @w: 5px, @c:#ccc)&#123; //朝下 border-width: @w; border-color: @c transparent transparent transparent; border-style: solid dashed dashed dashed ;//dashed 虚线&#125;.triangle(left, @w: 5px, @c:#ccc)&#123; //朝左 border-width: @w; border-color: transparent @c transparent transparent; border-style: dashed solid dashed dashed ;//dashed 虚线&#125;.triangle(right, @w: 5px, @c:#ccc)&#123; //朝右 border-width: @w; border-color: transparent transparent transparent @c ; border-style: dashed dashed dashed solid ;//dashed 虚线&#125;.triangle(@_, @w: 5px, @c:#ccc)&#123; //@_ 强大：无论匹配到什么值，均会运行这个函数 width: 0; height: 0; overflow: hidden;&#125;.tri_test&#123; .triangle(top, 100px);&#125;//好例子：：匹配：定位.pos(r)&#123; position:relative;&#125;.pos(a)&#123; position:absolute;&#125;.pos(f)&#123; position:fixed;&#125;.match&#123; width: 100px; height: 150px; background-color: green; .pos(r);&#125; 运算 任何数字，颜色或者变量都可以参与运算，运算应该包裹在括号里 例如+ - * / 12345@val:300px;.box&#123; width: @val + 20;/*less没有强制要求必须加单位，只要有一个有单位即可*/ height: (@val - 20) * 5; color: #ccc - 10 ;/*less会把颜色转成 255 的数值，然后进行计算，输出颜色值对应的颜色，工作中很少用到*/ 嵌套规则 &amp; 代表上一层选择器 用处1：123a&#123; &amp;:hover&#123;&#125; &#125;； 用处2：123.content&#123; &amp;_item1&#123; &#125; &#125; //&amp;_item1就相当于。content_item1 1234567891011121314151617181920212223242526272829303132//嵌套例子/*.list&#123;&#125;.list li&#123;&#125;.list a&#123;&#125;.list span&#123;&#125;*/下面所属关系，一层套一层，省去了重复的东西.list&#123; width: 600px; margin:30px auto; padding: 0; list-style: none; li&#123; height: 30px; line-height: 30px; background-color: pink; margin-bottom: 5px; &#125; a&#123; float: left; //&amp; 代表上一层选择器 &amp;:hover&#123; color: red; &#125; &#125; span&#123; float: right; &#125;&#125; &amp; 代表他的上一层选择器 12345678//&amp; 代表他的上一层选择器a&#123; float: left; //&amp; 代表上一层选择器 &amp;:hover&#123; color: red; &#125; &#125; &amp;同样代表他的上一层选择器，起连接作用 123456789101112131415161718//嵌套小例子//HTML&lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;content_item1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;content_item2&quot;&gt;&lt;/div&gt; &lt;/div&gt;//LESS.content&#123; width: 40px; height: 40px; background: #ccc; &amp;_item1&#123; //&amp;_item1就相当于。content_item1 width: 20px; height: 20px; background: pink; &#125;&#125; @arguments变量（用的不是很多）懒人必备 @arguments包含了所有传递进来的参数。 123456789101112 @border（@w：30px，@c：red，@s：solid）&#123; border：@w @c @s&#125;//如果你不想单独处理每一个参数的话就可以像这样写：.border_arg(@w:30px,@c:red,@ww:solid)&#123;border:@arguments;//这个@arguments就相当于@w,@c,@s 包含所有参数&#125;//调用.test_arguments&#123;.border_arg(40px);&#125; 封装 可以把封装的东西放到一个单独的 less里面，只需要在main.less主文件里面 @import 加文件名 xx 可以省略后缀名. 加载css需要 @import(less) “xxx.css”换汤不换药 其中“”前面有一个空格 还是css那一套加载方式，放到哪里就在哪里加载，样式表！123//引入a.less和a.css例子@import &quot;a.less&quot;; //引入其他的less样式表,其中.less可写可不写@import (less) &quot;a.css&quot; //引入css样式表，注意（less）和“a.css”中间有个空格 less 也有作用域1234567.content1&#123;@w:100px;width:@w;&#125;.content2&#123;width:@w;//错误，这个@w引用不了，因为他在.content1中&#125; 欲知更多，请戳less-中文官网可学习视频：less即学即用-慕课","tags":[{"name":"less","slug":"less","permalink":"http://yoursite.com/tags/less/"}]},{"title":"AngularJs指令解密","date":"2016-12-04T09:50:33.000Z","path":"2016/12/04/AngularJs指令解密/","text":"指令定义在《AngularJs权威教程》中，指令可以简单理解成特定的DOM元素上运行的函数；我认为还可以理解成将将自定义的HTML标签解析成原始的标签，然后为其加入一些扩展的功能（函数）.angularjs 提供了一个强大的扩展系统，通过指令机制，我们可以通过自定义指令来扩展自己的指令系统。 在AngularJS的核心里，指令可以绑定元素的属性（例如可见性，class列表，内部文本，内部HTML或者值）到scope的属性或表达式。最值得注意的是，一旦监测到scope中的变化被标记，这些绑定就会被更新。反过来也是相似的，使用$observe函数能够监测DOM属性，当监测到属性变化时会触发一个回调。 AngularJS应用的模块中有很多方法可以使用，其中directive()这个方法是用来定义指令的：不急，首先要注意下指令的名字，先看个简单例子：12345678angular .module(&apos;myApp&apos;, []) .directive(&apos;myDirective&apos;, myDirective);myDirective.$inject = [&apos;$timeout&apos;, &apos;UserDefinedService&apos;]function myDirective($timeout, UserDefinedService) &#123; // 指令定义放在这里&#125; 尽管在上面的的代码片段中我们定义了一个命名为myDirective的指令,AngularJS约定在 HTML 标记里使用破折号的形式连接名字。如果这个指令作为一个属性实现，那么我在 HTML 中就会像这样调用：&lt;span my-directive&gt;&lt;/span&gt; 还有：directive()方法可以接受两个参数： name(字符串)指令的名字，用来在视力中引用特定的指令。 factory_function(函数)这个函数返回一个对象，其中定义了指令的全部行为。$compile服务利用这个方法返回的对象，在DOM调用指令时来构造指令的行为。 注意：为了避免与未来的HTML标准冲突，给自定义的指令加入前缀来代表自定义的命名空间。AngularJS本身已经使用了ng-前缀，所以可以选择除此以外的名字。在例子中我们使用my-前缀（比如my-derictive）。 当AngularJS在DOM中遇到具名的指令时，会去匹配已经注册过的指令，并通过名字在注册过的对象中查找。此时，就开始了一个指令的生命周期，指令的生命周期开始于\\$compile方法并结束于link方法 下面，来看看定义一个指令时可以使用的全部设置选项。可能的选项如下所示，每个键的值说明了可以将这个属性设置为何种类型或者什么样的函数：12345678910111213141516171819202122232425262728293031angular .module(&apos;myApp&apos;, []) .directive(&apos;myDirective&apos;, myDirective);function myDirective() &#123; return: &#123; restrict: String, // priority: Number, terminal: Boolean, template: String or Template Function: function(tElement, tAttrs) &#123;...&#125;, templateUrl: String, replace: Boolean or String, scope: Boolean or Object, transclude: Boolean, controller: String or function(scope, element, attrs, transclude, otherInjectables) &#123;...&#125;, controllerAs: String, require: String, link: function(scope, iElement, iAttrs) &#123;...&#125;, compile: // 返回一个对象或连接函数，如下所示: function(tElement, tAttrs, transclude) &#123; return &#123; pre: function(scope, iElement, iAttrs， controller) &#123;...&#125;, post: function(scope, iElement, iAttrs, controller) &#123;...&#125; &#125; // 或者 return function postLink(...) &#123;...&#125; &#125; &#125;&#125; 下面我们来详细说说每种设置 restrict(字符串string)restrict是一个可选的参数。它告诉AngularJS这个指令在DOM中可以何种形式被声明。默认AngularJS认为restrict的值是A，即以属性的形式来进行声明。可选值如下：E(元素)： &lt;my-directive&gt;&lt;/my-directive&gt; A(属性，默认值)：&lt;div my-directive=&quot;expression&quot;&gt;&lt;/div&gt; C(类名)：&lt;div class=&quot;my-directive:expression;&quot;&gt;&lt;/div&gt;M(注释)：&lt;!-- directive:my-directive expression --&gt;AE : 可以结合上面的任意值来放松限制。 千万别用 ‘C’ 或者 ‘M’ 来限制你的指令。 用 ‘C’ 不能使之在标记中凸显出来， 用 ‘M’ 是为了向后兼容。 如果你觉得有趣， 你可以用一个例子来设置 restrict 为 ‘ACME’。这些选项可以单独使用，也可以混合在一起使用。 属性是用来声明指令最常用的方式，因为它能在包括老版本的IE浏览器在内的所有浏览器中正常工作，并且不需要在文档头部注册新的标签。 包含某个组件的核心行为时使用元素型。用额外的行为、状态或者其他内容进行修饰或扩展时使用属性型优先级(数值型Number) 优先级参数可以被设置为一个数值。大多数指令会忽略这个参数，使用默认值0，但也有些场景设置高优先级是非常重要甚至是必须的。例如，ngRepeat将这个参数设置为1000，这样就可以保证在同一元素上，它总是在其他指令之前被调用。 如果一个元素上具有两个优先级相同的指令，声明在前面的那个会被优先调用。如果其中一个的优先级更高，则不管声明的顺序如何都会被优先调用：具有更高优先级的指令总是优先运行。 terminal(布尔型Boolean) terminal是一个布尔型参数，可以被设置为true或false。这个参数用来告诉AngularJS停止运行当前元素上比本指令优先级低的指令。但同当前指令优先级相同的指令还是会被执行。如果元素上某个指令设置了terminal参数并具有较高的优先级，就不要再用其他低优先级的指令对其进行修饰了，因为不会被调用。但是具有相同优先级的指令还是会被继续调用。 template(字符串string或函数Function)template参数是可选的，必须被设置为以下两种形式之一： 一段HTML文本;一个可以接受两个参数的函数，参数为tElement和tAttrs，并返回一个代表模板的字符串。tElement和tAttrs中的t代表template，是相对于instance的。在讨论链接和编译设置时会详细介绍，模板元素或属性与实例元素或属性之间的区别。 在实际生产中，更好的选择是使用templateUrl参数引用外部模板，因为多行文本阅读和维护起来都是一场噩梦。 templateUrl（字符串String | 函数Function）可选的参数，可以是以下类型： 一个代表外部HTML文件路径的字符串 一个可以接受两个参数的函数，参数为tElement和tAttrs，并返回一个外部HTML文件路径的字符串 模板的URL都将通过AngularJS内置的安全层， 特别是\\$getTrustedResourceUrl，这样可以保护模板不会被不信任的源加载 调用指令时会在后台通过Ajax来请求HTML模板文件，也就是说： * 需要防止CORS错误 * 编译和链接要暂停，等待模板加载完成 模板加载后，AngularJS会将它默认缓存到$templateCache服务中，，可以提前将模板缓存到一个定义模板的JavaScript文件中，这样就不需要通过XHR来加载模板了 replace(布尔型Boolean)replace是一个可选参数，如果设置了这个参数，值必须为true，因为默认值为false。默认值意味着模板会被当作子元素插入到调用此指令的元素内部：123456&lt;div some-directive&gt;&lt;/div&gt;.directive(&apos;someDirective&apos;, function() &#123; return &#123; template: &apos;&lt;div&gt;some stuff here&lt;/div&gt;&apos; &#125;&#125;) 调用指令之后的结果如下(这是默认replace为false时的情况)：123&lt;div some-directive&gt; &lt;div&gt;some stuff here&lt;/div&gt;&lt;/div&gt; 如果replace被设置为了true：123456.directive(&apos;someDirective&apos;, function() &#123; return &#123; replace: true, // 修饰过 template: &apos;&lt;div&gt;some stuff here&lt;/div&gt;&apos; &#125;&#125;) 指令调用后的结果将是：1&lt;div&gt;some stuff here&lt;/div&gt; scope（布尔值Boolean | 对象Object）scope参数是可选的，默认为false： false：直接调用相同的作用域对象； true：从当前作用域对象继承一个新的作用域对象； 对象：创建一个同当前作用域相隔离的作用域对象。 ####独立作用域 scope属性值设置为true，作用是让自定义的每一个指令拥有独立的作用域，而不是共享一个作用域。 隔离作用域 通常情况下，当我们需要创建可复用的组建时，我们需要的就是具有隔离作用域的指令。它不依赖于上下文或者说是父级的作用域，所以可以随意迁移，不需要考虑依赖数据的问题。 隔离作用域实现起来很简单，只要将自定义指令返回对象中“scope”值写成“{}”就行。 1234567891011121314151617181920//隔离作用域app.directive(&apos;helloWorld&apos;, function() &#123; return &#123; scope: &#123;&#125;,//隔离作用域 restrict: &apos;AE&apos;, replace: true, template: &apos;&lt;p style=&quot;background-color:&#123;&#123;color&#125;&#125;&quot;&gt;Hello World&lt;/p&gt;&apos;, link: function(scope, elem, attrs) &#123; elem.bind(&apos;click&apos;, function() &#123; elem.css(&apos;background-color&apos;,&apos;white&apos;); scope.$apply(function() &#123; scope.color = &quot;white&quot;; &#125;); &#125;); elem.bind(&apos;mouseover&apos;, function() &#123; elem.css(&apos;cursor&apos;, &apos;pointer&apos;); &#125;); &#125; &#125;;&#125;); 使用隔离作用域时，可以将指令内部的隔离作用 域，同指令外部的作用域进行数据绑定： * 本地作用域属性：使用@符号将本地作用域同DOM属性的值进行绑定 * 双向绑定：通过=可以将本地作用域上的属性同父级作用域上的属性进行双向的数据绑定 * 父级作用域绑定：通过&amp;符号可以对父级作用域进行绑定，以便在其中运行函数 transclude（布尔值Boolean）可选，默认为false 可以将整个模板，包括其中的指令通过嵌入全部传入一个指令中。这样做可以将任意内容和作用域传递给指令。transclude参数就是用来实现这个目的的，指令的内部可以访问外部指令的作用域，并且模板也可以访问外部的作用域对象 只有当你希望创建一个可以包含任意内容的指令时，才使用transclude: true controller（字符串String | 函数Function）可选： * 字符串：以字符串的值为名字，查找注册在应用中的控制器的构造函数 * 函数：直接定义内联的控制器 可以向控制器中注入如下服务： \\$scope: 与指令元素相关联的当前作用域 \\$element: 当前指令对应的元素 \\$attrs: 由当前元素的属性组成的对象 \\$transclude: 嵌入链接函数会与对应的嵌入作用域进行预绑定。transclude链接函数是实际被执行用来克隆元素和操作DOM的函数。controllerAs （字符串String） 用来设置控制器的别名，可以以此为名来发布控制器，并且作用域可以访问controllerAs。这样就可以在视图中引用控制器，甚至无需注入$scope。 require（字符串String | 数组Array）字符串或数组元素的值是会在当前指令的作用域中使用的指令名称。require会将控制器注入到其值所指定的指令中，并作为当前指令的链接函数的第四个参数。 默认情况下，指令只会在自身的元素上查找控制器。可以用下面的前缀进行修饰，改变查找控制器时的行为： ?: 如果在当前指令中没有找到所需要的控制器，会将null作为传给link函数的第四个参数 ^: 如果添加了^前缀，指令会在上游的指令链中查找require参数所指定的控制器 ?^: 将前面两个选项的行为组合起来，可选择地加载需要的指令并在父指令链中进行查找 没有前缀: ，指令将会在自身所提供的控制器中进行查找，如果没有找到任何控制器（或具有指定名字的指令）就抛出一个错误 compile（对象Object | 函数Function）在compile函数内部，只对DOM进行操作，返回函数等效于使用link配置，返回对象的话包含两个函数： preLink会在编译阶段之后、指令连接到子元素之前运行 postLink会在所有子元素指令都链接之后才运行1234567compile: function(tElement, tAttrs, transclude) &#123; // 一些DOM操作 return &#123; pre: function preLink(scope, iElement, iAttrs, controller) &#123;&#125;, post: function postLink(scope, iElement, iAttrs, controller) &#123;&#125; &#125;;&#125; link（函数Function）link函数会访问scope对象，其返回一个postLink函数。如果在compile中返回了post，那么link选项就会被忽略 link: function postLink(scope, iElement, iAttrs){} compile和linkcompile和link有许多异同： compile函数只会被调用一次，而link函数的调用次数可能会很多。compile用于对模板自身的转换，而link负责模型和视图之间进行动态关联link函数能够访问scope作用域对象，而compile不会，因为在编译阶段，scope对象还不存在。link和compile都会接收指令声明的DOM元素以及属性列表compile可以返回preLink和postLink函数，而link只能返回postLink函数 AngularJS的生命周期 AngularJS应用启动后会进行编译和链接，作用域会同HTML进行绑定，应用可以对用户在HTML中进行的操作进行实时响应。 编译三个阶段 首先浏览器会用它的标准API将HTML解析成DOM。模板必须是可被解析的HTML。这是AngularJS和那些“以字符串为基础而非以DOM元素为基础的”模板系统的区别之处。 DOM的编译是有\\$compile方法来执行的。这个方法会遍历DOM并找到匹配的指令。一旦找到一个，它就会被加入一个指令列表中，这个列表是用来记录所有和当前DOM相关的指令的。 一旦所有的指令都被确定了，会按照优先级被排序，并且他们的compile方法会被调用。指令的\\$compile()函数能修改DOM结构，并且要负责生成一个link函数（后面会提到）。\\$compile方法最后返回一个合并起来的链接函数，这是链接函数是每一个指令的compile函数返回的链接函数的集合。 通过调用一步所说的链接函数来将模板与作用域链接起来。这会轮流调用每一个指令的链接函数，让每一个指令都能对DOM注册监听事件，和建立对作用域的的监听。这样最后就形成了作用域的DOM的动态绑定。任何一个作用域的改变都会在DOM上体现出来。大致过程如下：12345678910111213var $compile = ...; // injected into your codevar scope = ...;var html = &apos;&lt;div ng-bind=&apos;exp&apos;&gt;&lt;/div&gt;&apos;;// Step 1: parse HTML into DOM elementvar template = angular.element(html);// Step 2: compile the templatevar linkFn = $compile(template);// Step 3: link the compiled template with the scope.linkFn(scope); 模板之中可能含有指令，指令之中可能又含有模板，模板之中又含有指令，由此形成一棵模板树。只有具有最高优先级的指令中的模板会被编译。如果一个元素已经有一个含有模板的指令了，永远不要对其用另一个指令进行修饰。一个指令会将内部子指令的模板合并在一起成为一个模板函数并返回，它无法查找父指令，只能通过模板函数访问内部子指令 ngModelngModel提供更底层的API来处理控制器内的数据。 为了设置作用域中的视图值，需要调用ngModel.\\$setViewValue()函数，接受一个字符串参数value，表示想要赋予的实际值，然后：ngModel.\\$setViewValue()方法会更新控制器本地的\\$viewValue，然后将值传递给每一个\\$parser函数值被解析且\\$parser所有函数都完成后，值会赋给\\$modeValue属性，并且传递给指令中ng-model属性提供的表达式所有步骤都完成后，\\$viewChangeListeners中所有的监听器都会被调用 单独调用\\$setViewValue()不会唤起一个新的digest循环，因此如果想更新指令，需要在设置\\$viewValue后手动触发digestngModel的\\$render方法可以定义视图具体的渲染方式，它在$parser完成后被调用 ngModelController中有几个属性可用来检查甚至修改视图： \\$viewValue： 保存着更新视图所需的实际字符串。 \\$modelValue：由数据模型持有。\\$modelValue和\\$viewValue可能是不同的，取决于\\$parser流水线是否对其进行了操作。 \\$parsers：\\$parsers的值是一个由函数组成的数组，其中的函数会以流水线的形式被逐一调用。ngModel从DOM中读取的值会被传入\\$parsers中的函数，并依次被其中的解析器处理。 \\$formatters：\\$formatters的值是一个由函数组成的数组，其中的函数会以流水线的形式在数据模型的值 发生变化时被逐一调用。它和\\$parser流水线互不影响，用来对值进行格式化和转换，以便在绑定了这个值的控件中显示。 \\$viewChangeListeners：\\$viewChangeListeners的值是一个由函数组成的数组，其中的函数会以流水线的形式在视图中的值发生变化时被逐一调用。通过\\$viewChangeListeners，可以在无需使用\\$watch的情况下实现类似的行为。由于返回值会被忽略，因此这些函数不需要返回值。 友情链接AngularJs权威教程很好玩的博客–AngularJs指令详解AngularJS - 指令详解天镶的读书笔记","tags":[{"name":"AngularJs","slug":"AngularJs","permalink":"http://yoursite.com/tags/AngularJs/"}]},{"title":"AngularJS浅谈-博客","date":"2016-11-28T09:50:33.000Z","path":"2016/11/28/AngularJs浅谈/","text":"AngularJS是啥？（一脸懵逼）简介： AngularJS诞生于2009年，由Misko Hevery 等人创建，后为Google所收购。是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVC、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。 具体点说： AngularJS 是一个 JavaScript 框架 AngularJS 是以一个 JavaScript 文件形式发布的，可通过 script 标签添加到网页中：&lt;script src=&quot;../libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; AngularJS 扩展了 HTML AngularJS 通过 ng-directives 扩展了 HTML。ng-app 指令定义一个 AngularJS 应用程序。ng-model 指令把元素值（比如输入域的值）绑定到应用程序。ng-bind 指令把应用程序数据绑定到 HTML 视图。ng-init 指令初始化 AngularJS 应用程序变量 那么，重点来了，AngularJs可以干啥啊？AngularJS 使得开发现代的单一页面应用程序（SPAs：Single Page Applications）变得更加容易。 AngularJS 把应用程序数据绑定到 HTML 元素。AngularJS 可以克隆和重复 HTML 元素。AngularJS 可以隐藏和显示 HTML 元素。AngularJS 可以在 HTML 元素”背后”添加代码。AngularJS 支持输入验证。 举个荔枝（例子）吧！ 12345678910111213141516171819202122232425262728293031&lt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;例子&lt;/title&gt; &lt;script src=&quot;angular-1.0.1.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt; 名：&lt;input type=&quot;text&quot; ng-model=&quot;lastName&quot;&gt;&lt;br&gt; 姓：&lt;input type=&quot;text&quot; ng-model=&quot;firstName&quot;&gt;&lt;br&gt; &lt;br&gt; 姓名：&#123;&#123;firstName+&quot; &quot;+ lastName&#125;&#125; &lt;br&gt; 姓名：&#123;&#123;fullName()&#125;&#125;&lt;/div&gt;&lt;script&gt; var app=angular.module(&apos;myApp&apos;,[]); app.controller(&apos;myCtrl&apos;,function($scope)&#123; $scope.firstName=&quot;重庆&quot;; $scope.lastName=&quot;黄&quot;; $scope.fullName = function() &#123; return $scope.firstName + &quot; &quot; + $scope.lastName; &#125; &#125;);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 初始化加载流程 统一过程： 1、浏览器载入HTML，然后把它解析成DOM。2、浏览器载入angular.js脚本。3、AngularJS等到DOMContentLoaded事件触发。4、AngularJS寻找ng-app指令，这个指令指示了应用的边界。5、使用ng-app中指定的模块来配置注入器(\\$injector)。6、注入器($injector)是用来创建“编译服务(\\$compile service)”和“根作用域(\\$rootScope)”的。7、编译服务(\\$compile service)是用来编译DOM并把它链接到根作用域(\\$rootScope)的。 具体过程： AngularJS 应用程序由 ng-app 定义。应用程序在 内运行。ng-controller=”myCtrl” \b属性是一个 AngularJS 指令。用于定义一个控制器。myCtrl 函数是一个 JavaScript 函数。AngularJS 使用$scope 对象来调用控制器。在 AngularJS 中， $scope 是一个应用象(属于应用变量和函数)。控制器的 $scope （相当于作用域、控制范围）用来保存AngularJS Model(模型)的对象。控制器在作用域中创建了两个属性 (firstName 和 lastName)。ng-model 指令绑定输入域到控制器的属性（firstName 和 lastName）。 记住一点：在大型的应用程序中，通常是把控制器存储在外部文件中。只需要把 &lt;script&gt; 标签中的代码复制到名为 js文件.js 的外部文件中即可，然后在script中引用js文件： 接下来说一下AngularJs中核心的集中特性吧！！ 先来个图！ MVC模块化自动化双向数据绑定 MVC（Model模型 View视图 Controller控制器） 首先要知道为什么要MVC？ AngularJs程序分为3部分：模板，表现层逻辑，数据（model）。 模板：我们用html，css写的ui视图代码，其中包含AngularJs的指令，表达式，并最终会被AngularJs编译机制编译为附加在dom树上。AngularJs的指令（directive）可以由我们自由扩展。 表现层逻辑：包括应用程序逻辑和行为。用javascript定义作为视图控制器逻辑。在AngularJs作为MVC框架，在控制器中我们无需添加对于dom级的事件监听，这些在AngularJs中已经内置了。在ui节点dom事件发生后AngularJs会自动转到scope上的某个行为（Action）逻辑。 数据：视图对象（viewobject）需要被AngularJs Scope（1.0中作为service出现）引用，可以使任何类型的javascript对象，数组，基本类型，对象。并且AngularJs会自动异步更新模型，即在ui发生改变的时他会自动刷新模型（mode），反之在模型发生改变的时候也会自动刷新ui。在这里我们不需要定义形如getter，setter的一些列方法。 MVC之间的关系，下面这张图看一下MVC中都包含些什么东西 再看下面这张图-其中service是共用的的东西抽象出来的服务 模块化 AngularJs的模块（module):它是一个集合，相当于一个框子，由模型，视图，过滤器，服务等等组成 我们都知道JavaScript很容易就写出全局函数，所以无论是用jQuery还是纯JavaScript，我们都会使用模块化的策略避免写出来的函数污染全局。 1234567891011121314HTML代码:&lt;!doctype html&gt;&lt;html ng-app=&quot;HelloAngular&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller=&quot;helloNgCtrl&quot;&gt; &lt;p&gt;&#123;&#123;greeting.text&#125;&#125;,Angular&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;js/angular-1.3.0.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;NgModule1.js&quot;&gt;&lt;/script&gt;&lt;/html&gt; 123456789101112//JS代码1:var modelName = angular.module(&apos;modelName&apos;,[]);modelName .controller(&apos;contollerName&apos;,[&apos;$scope&apos;,function($scope)&#123; $scope.greeting = &#123;$scope.greeting=&#123;text:&apos;hello&apos;&#125;;&#125;&#125;]);//JS代码2function HelloAngular($scope)&#123; $scope.greeting=&#123; text:&apos;hello&apos; &#125;;&#125; 很明显JS1代码函数污染了全局，而Js2代码通过一个模块进行封装，从而避免污染了全局。 在前面我们看到ng-app指令。它的作用是自动启动一个AngularJS应用，ng-app指令一般指派在应用的根元素上，比如，body或者html标签。在每一个HTML文档中，只能有一个AngularJS应用可以被自动启动，在HTML文档中第一个被找到定义在根元素上的ng-app指令将会作为自动启动的应用。那我们在js代码中定义的模块和ng-app有什么关系呢？很明显，它是告诉AngularJS应用在启动时加载指定的模块，假设这里ng-app只是放一个纯标签，而不给它赋值。那么它就不知道这里该加载什么模块，于是，它也不认识在模块中定义的textController控制器。 但是，赋值与否和启动一个AngularJS的应用无关：12345&lt;body ng-app&gt; &lt;div ng-controller=&quot;helloNgCtrl&quot;&gt; &lt;p&gt;&#123;&#123;greeting.text&#125;&#125;,Angular&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; 这样也是可以启动AngularJS应用，并实现name模型的绑定。 看一下ng官方的模块切分方式 最后看一下模块化的完整项目结构，有利于大家对项目的整体认知 双向数据绑定 先来个官方例子：123456789101112131415161718&lt;!doctype html&gt; 2 &lt;html ng-app&gt; 3 4 &lt;head&gt; 5 6 &lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&gt;&lt;/script&gt; 7 8 &lt;/head&gt; 9 10 &lt;body&gt;11 12 Your name: &lt;input type=&quot;text&quot; ng-model=&quot;yourname&quot; placeholder=&quot;World&quot;&gt;//一个输入框，默认内容为World13 14 &lt;hr&gt;15 16 Hello &#123;&#123;yourname || &apos;World&apos;&#125;&#125;!18 &lt;/body&gt;20 &lt;/html&gt; 注:在输入框中输入任何字符都会立即绑定更新到页面. 这里采用ng-model指令（directive）绑定是模型scope属性yourname。并采用表达式将yourname绑定到文本信息中。这里只需要任何的dom时间监听，因为AngularJs内置了。 友情链接：MVC框架-破浪博客AngularJs实战视频AngularJs中文铁锚的CSDN博客模块化","tags":[{"name":"AngularJs","slug":"AngularJs","permalink":"http://yoursite.com/tags/AngularJs/"}]},{"title":"JS-我待this如初见","date":"2016-08-18T09:50:33.000Z","path":"2016/08/18/JS-我待this如初见/","text":"何为this？this是对象，是在运行时基于函数的执行环境(和对象有关)绑定的，首先，当代码没执行前，或没执行到之前，this 是没有指向的,所以切记：在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了。因为this的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。this只要一出现，一定牵扯到函数和对象一般方法：首先分析this所在的函数是被当做哪个对象的方法调用的，则该对象就是this所引用的对象。 其实，this的取值，分五种情况。我们来挨个看一下。 全局和调用普通函数 构造函数 函数作为对象的一个属性 函数用call或apply或bind 事件监听函数中的this 情况1：全局 &amp; 调用普通函数在全局环境下，this永远是window，这个应该没有非议。123console.log(this==window);//turethis.a=20;console.log(window.a); 普通函数在调用时，其中的this也都是window。 1234567var home=&quot;中国&quot;;var person=function()&#123; var home=&quot;河南&quot; console.log(this); //window console.log(this.home); //中国 &#125;person(); 但是严格模式下 this是undefined(竞然)：12345678910function person1()&#123; return this; &#125;person1()===window; //truefunction person2()&#123; &quot;use strict&quot; //严格模式 return this;&#125;person2()===undefined; //true 情况2：构造函数所谓构造函数就是用来new对象的函数。其实严格来说，所有的函数都可以new一个对象，但是有些函数的定义是为了new一个对象，而有些函数则不是。另外注意，构造函数的函数名第一个字母大写（规则约定）。例如：Object、Array、Function等。 如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象 1234567891011121314window.home=&quot;中国&quot;;window.age=&quot;5000+&quot;;function Person()&#123; this.home=&quot;河南&quot;; this.age=20; console.log(this); //Person &#123;home: &quot;河南&quot;, age: 20&#125; console.log(this.home);// 河南&#125;var chongqing = new Person();console.log(chongqing.home); //河南还是中国console.log(chongqing.age); //20还是5000+console.log(age); //5000+还是20 以上代码中，如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象,即上文中的chongqing。 上个例子中构造函数没有返回值，默认返回this，但是若有返回语句，返回一个对象的话，会将return的对象作为返回值12345678910111213function Myclass()&#123; this.a=20;&#125;var o=new Myclass();console.log(o.a); //20function Person()&#123; this.a=20; return &#123; a: 21&#125;;&#125;var o=new Person();console.log(o.a); //21还是20 注意，以上仅限new Person()的情况，即Person函数作为构造函数的情况。如果直接调用Person函数，而不是new Person()，情况就大不一样了。相当于普通函数1234567891011window.home=&quot;中国&quot;;window.age=&quot;5000+&quot;;function Person()&#123; this.home=&quot;河南&quot;; this.age=20; console.log(this); //window 还是Person &#123;home: &quot;河南&quot;, age: 20&#125; console.log(this.home);//???河南还是中国 console.log(home);//???河南还是中国&#125;Person(); 这种情况下this是window，就是相当于普通函数中的this 构造函数还有一种情况，在构造函数的prototype中，this代表着什么？在整个原型链中，this代表的是当前对象的值1234567891011121314window.home=&quot;中国&quot;;window.age=&quot;5000+&quot;;function Person()&#123; this.home=&quot;河南&quot;; this.age=20; console.log(this); //Person &#123;home: &quot;河南&quot;, age: 20&#125;&#125;Person.prototype.getHome=function()&#123; console.log(this.home); //河南&#125;var chongqing= new Person();chongqing.getHome();// 如上代码，在Person.prototype.getHome函数中，this指向的是chongqing对象。因此可以通过this.name获取chongqing.name的值。 其实，不仅仅是构造函数的prototype，即便是在整个原型链中，this代表的也都是当前对象的值。 情况3：函数作为对象的一个方法在这又分两种情况： 函数作为对象的方法被调用,此时函数中的this指向该对象 函数被赋值到了另一个变量中，this的值是window ###1. 如果函数作为对象的一个方法时，并且作为对象的一个方法被调用时，函数中的this指向该对象。1234567891011window.home=&quot;中国&quot;;window.age=&quot;5000+&quot;;var obj=&#123; home:&quot;河南&quot;, person: function()&#123; console.log(this); //Object &#123;home: &quot;河南&quot;&#125; console.log(this.home); //河南 &#125;&#125;;obj.person(); 以上代码中，person不仅作为一个对象的一个方法，而且的确是作为对象的一个方法被调用。结果this就是obj对象。 注意，如果person函数不作为obj的一个方法被调用，会是什么结果呢？ 2. 如果person函数被赋值到了另一个变量中，并没有作为obj的一个方法被调用，那么this的值就是window1234567891011window.home=&quot;中国&quot;;window.age=&quot;5000+&quot;;var obj=&#123; home:&quot;河南&quot;, person: function()&#123; console.log(this); //？？window还是object console.log(this.home); //？？中国还是河南 &#125;&#125;;var person1=obj.person;person1(); 如上代码，如果person函数被赋值到了另一个变量中，并没有作为obj的一个属性被调用，那么this的值就是window,相当于全局了，this.home的值为中国 3.闭包中使用this对象（对象方法函数中又有一个匿名函数）-this用处（诡异） 在ES3中，此时使用this比较糟糕，因为this失去了方向，引用的是window对象，而不是定义函数所在的对象,欣慰的是，this在ES5中是固定的，我们应该清楚地了解这种情况注意： 在ES3中，当函数作为某个对象的方法调用时，this等于那个对象，不过在闭包中，匿名函数的执行环境具有全局性，此时通常this指向window1234567891011var obj=&#123; home:&quot;河南&quot;, person: function()&#123; function person1()&#123; console.log(this); //window console.log(this.home); //undefined &#125; person1();&#125;&#125;;obj.person(); 总结：当this值的宿主环境被封装在另一个函数内部或在另一个函数的上下文被调用时，this将永远是对window对象的引用（再次说明，this在ES5中是固定的） 如何改变上述情况呢？可以在父函数中使用作用域链来保留对this的引用，以使this值不丢失。如下代码演示了如何使用that变量及其作用域来有效跟踪函数上下文12345678910111213var obj=&#123; home:&quot;河南&quot;, person: function()&#123; var that=this; //person作用域中，保存this引用对象obj（而不是window） function person1()&#123; //输出通过作用域得到河南，因为that=this console.log(that); //Object &#123;home: &quot;河南&quot;&#125; console.log(that.home); //河南 &#125; person1();&#125;&#125;;obj.person(); 情况4：函数用call或者apply或bind调用 先简单说一下call和apply和bind如何使用 call(),apply() 关于call和apply，首先这两个方法的用途都是在特定的作用域中调用函数，，都有两个参数call/apply(作用域，传递给函数的参数) 它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数。 apply的用法和call大致相同，只有一点区别，apply只接受两个参数，第一个参数和call相同，第二个参数必须是一个数组，数组中的元素对应的就是函数的形参。注意不同的是接受参数的方式不同，call()传递给函数的参数必须逐个列举出来，而apply()则是参数数组 bind() bind（）创造一个函数的实例，其this值会被绑定到传给bind（）函数的值。 牢记：当一个函数被call或apply或bind调用时，this的值就取传入的对象的值,即call（）或apply或bind（）括号里的对象。 call实例12345678910window.home=&quot;中国&quot;;window.age=&quot;5000+&quot;;var obj=&#123; home:&quot;河南&quot;&#125;;var person=function()&#123; console.log(this); //Object &#123;home: &quot;河南&quot;&#125; console.log(this.home); //河南 &#125;person.call(obj); 还要注意：apply()的参数为空时，默认调用全局对象。 123456789 var x = 0; function test()&#123; alert(this.x); &#125; var o=&#123;&#125;; o.x = 1; o.m = test; o.m.apply(); //0 bind()实例12345678window.color=&quot;red&quot;;var o=&#123;color:&quot;blue&quot;&#125;;function sayColor()&#123; alert(this.color);&#125;var objectSayColor=sayColor.bind(o);objectSayColor(); //blue还是red sayColor()调用bind（）并传入对象o。创建了objectSaycolor（）函数，objectSaycolor（）函数中的this的值等于o，因此，即使是在全局作用域中调用这个函数也会看到“blue”。 情况5：事件监听函数中的this(大家应该熟悉)12345var one = document.getElementByIdx( &apos;one&apos; );one.onclick = function()&#123; alert( this.innerHTML ); //this指向的是one元素， 友情链接：Javascript高级程序设计（第3版）-关于this对象-182页JavaScript启示录-this部分博客-深入理解Js-this博客-js中this慕课网Javascript深入浅出-this部分博客-this关键字详解 Ending（欲知后事如何，且听下回分解）","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]}]