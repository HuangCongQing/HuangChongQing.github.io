[{"title":"25分钟学会使用MySQL基本操作","date":"2017-09-17T09:50:33.000Z","path":"2017/09/17/25分钟学会使用MySQL基本操作/","text":"###1 MySQL登录与退出 MySQL登陆MySQL 参数(在cmd命令框中输入) 登陆MySqlmysql -uroot -p -P3306 -h127.0.0.1 MySql退出 MySQL修改root密码 MySQL修改root密码链接 2 修改MySQL提示符及语法规范先说一个小技巧，cmd命令框清屏用cls 首先说一下神魔是MySql提示符？看下面图就懂了 连接客户端即登录时通过参数指定mysql -uroot -proot --prompt 提示符 连接上客户端后，通过prompt命令修改prompt 提示符 下面是MySql具体可更更改的操作 PROMPT \\u@\\h \\d 修改为用户名@主机名 数据库名称 3 MySQL常用命令 4 MySQL语句规范特别注意分号，因为不加分号，这段语句不执行，如下图 5 数据库操作{}必选项，[]可选项 数据库怎么看呢？当前服务器下到底有多少数据库(正确安装之后，默认有四个数据库)show DATABASES 创建数据库编码方式是什么？不加，默认是配置文件设置的编码方式 如果想创建一个GBK的编码方式的数据库怎么来？CREATE DATABASE IF NOT EXISTS Hello2 CHARACTER SET gbk 修改数据库 修改编码方式ALTER DATABASE Hello2 CHARACTER SET utf8 删除数据库DROP DATABASE 数据库名 基本操作就这样了！回顾下重点： 对了，还要说下，写SQL每句语句的后面，一定要加分号 ;哦！！ 可参考的常用命令链接： MYSQL常用命令Mysql命令大全 - 宁静.致远 - 博客园","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"coursera视频无法播放（翻墙也无效）？看这里就全懂了","date":"2017-09-17T09:50:33.000Z","path":"2017/09/17/coursera视频无法播放（翻墙也无效）？看这里就全懂了/","text":"Coursera是国外的一款非常有名的公开课网站，值得大家一起学习,但有时候要在coursera上看个课程，发现看不了，爬墙各种方法都试了，特意在网上搜集了解决方案，亲测有效，现在特意记录下来，希望能帮到你。好好学习，天天向上。 该方法针对Windows用户(win7，win8，win10)，亲测有效。Mac电脑的可参考我最后发的链接 用管理员权限记事本打开host文件，地址如下: C:\\Windows\\System32\\drivers\\etc，（以文本格式打开hosts就好） 将如下内容复制到文件末尾12345678952.84.246.90 d3c33hcgiwev3.cloudfront.net52.84.246.252 d3c33hcgiwev3.cloudfront.net52.84.246.144 d3c33hcgiwev3.cloudfront.net52.84.246.72 d3c33hcgiwev3.cloudfront.net52.84.246.106 d3c33hcgiwev3.cloudfront.net52.84.246.135 d3c33hcgiwev3.cloudfront.net52.84.246.114 d3c33hcgiwev3.cloudfront.net52.84.246.90 d3c33hcgiwev3.cloudfront.net52.84.246.227 d3c33hcgiwev3.cloudfront.net 如下图： 打开cmd命令行，输入如下命令ipconfig/flushdns 刷新页面即可，终于可以看视频啦 参考链接：coursera 视频总是缓冲或者无法观看,有什么方法解决? - 知乎coursera无法观看视频解决方法Coursera无法观看课程解决方案-百度经验 Mac和windows国内coursera官网看不了视频怎么办**好看的人儿，点个喜欢❤ 你会更好看哦~~","tags":[{"name":"技术杂谈","slug":"技术杂谈","permalink":"http://yoursite.com/tags/技术杂谈/"},{"name":"coursera","slug":"coursera","permalink":"http://yoursite.com/tags/coursera/"}]},{"title":"吴恩达-神经网络和深度学习（ 第三周 浅层神经网络：）","date":"2017-09-14T09:50:33.000Z","path":"2017/09/14/吴恩达-神经网络和深度学习（-第三周--浅层神经网络：）/","text":"学习使用前向传播和反向传播搭建出有一个隐藏层的神经网络。 hidden layer Neural Network ###3.1 神经网络概览 ###3.2 神经网络表示 双层神经网络（只有一个隐藏层，单隐层神经网络） 输入层-四个隐藏层单元-输出层 双层神经网络。不把输入层看做一个标准的层 这里的隐藏层有两个相关的参数w和b,使用上标[1]表示这些参数，w是4x3矩阵,b是4x1向量（4代表有四个节点或者隐藏单元，3来自于3个输入特征） 输出层也有相关的参数w^[2] (1x4,隐藏层有四个隐藏单元，输出层只有一个单元),b^[2]【1x1】 ###3.3 计算神经网络的输出 gengrate 生成compute 计算matrix 矩阵 神经网络只不过是计算这些步骤很多次 ###3.4 多个例子中的向量化 训练样本横向堆叠构成矩阵X m个训练样本 用激活函数来表示这些式子a^[2](i)【i是训练样本i,2指的是第二层】 一个for循环遍历所有的m训练样本 向量化 ###3.5 向量化实现的解释 这就是对不同训练样本向量化的神经网络，接下来，我们目前为止我们一直都是用sigmoid函数 ###3.6 激活函数（activation function） 如何使用不同种类的激活函数，simoid只是其中的一个可能选择 为了搭建神经网络，可以选择的是选择隐层里用哪个激活函数，还有神经网络的输出单元用什么激活函数有一个函数总比sigmoid函数表现好，那就是a=tanh(z)（双曲正切函数），函数介于+1和-1之间，意味着激活函数的平均值更接近0 但 二分分类是，输出层最好用sigmoid,因为y输出介于0-1更合理 不过，sigmoid和tanh函数都有一个缺点，如果z非常大，或非常小，函数的斜率很接近0，这样会拖慢梯度下降算法 修正线性单元（ReLU）就派上用场了（z为正，斜率为1，为负，斜率为0） 在选择激活函数时有一些经验法则 如果你的输出值是0或1，如果你在做二元分类，那么sigmoid很适合作为输出层的激活函数，然后其他所有单元都用ReUL。如果你不确定隐层应该用哪个，那就用ReUL作为激活函数 还有个带泄露的ReUL（z小于0是有一个缓缓的斜率，）通常比ReUL激活函数好，不过实际中使用的频率没那么高 在实践中使用ReUL激活函数，学习速度通常会快得多，比使用tanh或sigmoid激活函数快得多，因为ReUL没有函数斜率接近0时，减慢学习速度的学习速度的效应 说一下几个激活函数 sigmoid除非用在二元分类的输出层，不然绝对不要用，或者几乎从来不会用 最常用的默认激活函数ReLU，不确定用哪个，就用这个，或者带泄露的ReLU（max(0.01z, z)） ###3.7 为什么需要非线性激活函数（nonlinear activation function）？ 如果用线性激活函数（linear activation function）或者叫做恒等激活函数，那么神经网络只是把输入线性组合再输出，无论你的神经网络多少层，一直在做的只是计算线性激活函数，和没有任何的标准Logistic回归是一样的，因为两个线性函数组合的本身就是线性函数，除非你引用非线性， 只有一个地方可以使用线性激活函数g（z） = z，就是你要机器学习的是回归问题，所以y是一个实数， 线性激活函数不可能用在隐藏层（除压缩），要用，也是用在输出层， ###3.8 激活函数的导数 接下来讨论梯度下降的基础，如何估计，如何计算单个激活函数的导数，斜率， ###3.9 神经网络的梯度下降法梯度下降算法的具体实现，如何处理单隐层神经网络，提供所需的方程，来实现反向传播，或者说梯度下降算法， keepdims = true(确保python输出的是矩阵) 正向传播 4个方程 反向传播 6个方程 ###3.10 （选修）直观理解反向传播 ###3.11 随机初始化 当你训练神经网络时，随机初始化权重非常重要，对于logistic回归，可以将权重初始化为零，但如果将神经网络各参数数组初始化为0，再使用梯度下降算法（gredient descent），那会完全失效 因为我们需要两个不同的隐藏单元，去计算不同的函数，这个问题的解决方案是随机初始化所有参数， 可以令W^[1] = np.random,randn, 这可以产生参数为（2， 2）的高斯分布随机变量，然后你再乘以一个很小的数字【因为通常喜欢把权重矩阵初始化非常小的随机数】，所有你将权重初始化很小的随机数， 如果训练单隐层神经网络时，没有太多的隐藏层，设为0.01还可以，但当训练一个很深的神经网络时，可能要试试0.01以外的常数， 把b初始化0是可以的 所以，在这周的视频里，你知道如何设立单隐层神经网络，初始化参数，并用正向传播计算预测值，还有计算导数，然后使用梯度下降，反向传播","tags":[{"name":"神经网络","slug":"神经网络","permalink":"http://yoursite.com/tags/神经网络/"},{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/tags/深度学习/"}]},{"title":"看透神经网络和深度学习的脉络，终于不迷糊了","date":"2017-09-09T09:50:33.000Z","path":"2017/09/09/看透神经网络和深度学习的脉络，终于不迷糊了/","text":"神经网络和深度学习近几年好多人在学习，但是他们具体是什么关系，又有什么联系，众说纷纭，有人说：深度学习可以理解成用深度神经网络（DNN，Deep Neural Network）来进行机器学习，有人说：深度学习是一种方法，神经网络是个模型。用了深度学习可以有效解决层数多的网络不好学习的问题还有人说：本是同根生，相煎何太急接下来，下面这张图，能帮助大家更好地学习神经网络和深度学习，掌握理清脉络 线性回归是最基本的注释：红色是基础 ＮＬＰ自然语言处理(nlp,natural language processing) 机器学习(machine learning) ＣＮＮ卷积神经网络（convolutional neural network） ＲＮＮ递归神经网络(Recurrent Neural Network) LSTM Long Short Term Memory长的短时记忆长短时记忆长短时记忆模型 CNN：卷积神经网络【空间】RNN: 递归神经网络【时域】神经网络中，隐含层网络的输出作为下一时刻自身的输入–&gt;一级一级会衰弱–》需要记忆封存的结构（LSTM）RNN-&gt;LSTM【记忆量的扩充】 描述 非线性的运算关系叠加起来就是一个神经网络 神经网络到CNN，RNN（空间和时间的扩展） 卷积核：二维的处理算组，图像的处理 神经网络到CNN就是一维到二维三维的转化，在空间上进行扩展 神经网络到RNN（神经网络一维有个时间的延续，比如说语音） 记忆GATE-根据输入的信息判断哪些是需要提前记下来的，在之后处理的时候选择要不要释放 小象学院公开课具体讲述了这一内容，下面是视频链接：视频连接 本文转载自微信公众号：重庆小哥稳","tags":[{"name":"神经网络","slug":"神经网络","permalink":"http://yoursite.com/tags/神经网络/"},{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/tags/深度学习/"}]},{"title":"吴恩达-神经网络和深度学习(第二周神经网络基础)","date":"2017-09-07T09:50:33.000Z","path":"2017/09/07/吴恩达-神经网络和深度学习(第二周神经网络基础)/","text":"学习如何用神经网络的思维模式提出机器学习问题、如何使用向量化加速你的模型。 先介绍一些名词 training set (训练集) feature vector(特征向量) classifier(分类器) calculus（微积分） 循环（loop） 数据集（datasets） vectorization (向量化) matrix(矩阵) vector(向量) 本周用到的一些符号【Notation】 （x,y）表示一个单独的样本 x是xn维的特征向量 标签y值为0/1 训练集由m个训练样本构成 (x^(1), y^(1))表示样本一输入和输出， {x^(1), y^(1),…..x^(n), y^(n).}整个训练集 测试集的 样本数。训练集的样本数 矩阵也可表示训练集输入x,输出标签y 注意：训练样本作为行向量堆叠 输出y是1xm矩阵 如下图： 二分分类【Binary Classification】 神经网络的计算过程中，通常有一个正向过程【forward pass】（或者正向传播步骤）,接着有一个反向过程【backward pass】(或者反向传播步骤) logistic回归是一个用于二分分类的算法 计算机保存图片，要保存三个独立矩阵（Red红 blue绿 Green蓝）如果有64X64的一张图片，则输入向量的维度n=64X64X3=12288 在二分分类问题中，目标是训练出一个分类器，他以图片的特征向量x作为输入，，预测输出的结果y(只有两个值) logistic回归这是一个学习算法，用在监督学习中，如下图： logistic回归损失函数损失函数【error function】在单个训练样本中定义的，他衡量了在单个训练样本上的表现成本函数【cost function 】在全体训练集样本下的表现–&gt;对损失函数求和对以上函数要找到合适的参数w和b成本函数用于衡量参数w和b的效果 如下图： 梯度下降法【Gradient Descent】 训练或学习训练集上的参数w和b 导数等于= be equal to pluse minusX times/ divide 计算图 可以说，一个神经网络的计算都是按照前向或者反向传播过程来实现的，首先计算出神经网络的输出首先计算出神经网络的输出，紧接着一个反向传播操作，后者我们用来计算出对应的梯度或者导数，流程图解释了为什么这样实现流程图，是用蓝色箭头画出来的的，从左到右的计算 计算图的导数计算从右到左计算导数 logistic回归中的梯度下降法（用偏导数实现）导数流程图来计算梯度用偏导数有点大材小用，但对理解比较好 m个样本的梯度下降运用到整个样本集中 向量化循环很低效率，用向量化来加速运算(np.function)z=np.dot(w, x) + b可能有人说：可扩展深度学习实现是在GPU(图像处理单元)上做的，而我们做的再jupyter notebook上（CPU）但GPU和CPU都有并行化的指令，SIMD单指令流多数据流，这点对GPU和CPU上面是成立的，只是GPU更擅长SIMD运算 for循环能不用就不用，如果可以使用内置函数或者其他方法计算循环，会比for循环更快 进一步向量化logistic回归 向量化logistic回归的梯度输出这就得到高度向量化的，高效的logistic回归梯度下降法 python中的广播（使python和Numpy部分代码更高效）广播（broadcasting）对列向量，行向量都有效例子： 实现神经网络算法时主要用到的广播形式 关于python/numpy向量的说明千万不要用秩为1的数组随意插入assert()声明，要仔细检查矩阵和数组的维度不要害怕调用reshape,来确保你的矩阵和向量 可以排除，简化甚至消灭代码中各种奇怪的bug 学习链接4. Logistic代码实战","tags":[{"name":"神经网络","slug":"神经网络","permalink":"http://yoursite.com/tags/神经网络/"},{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/tags/深度学习/"}]},{"title":"吴恩达-神经网络和深度学习(第一周深度学习概论)","date":"2017-09-01T09:50:33.000Z","path":"2017/09/01/吴恩达-神经网络和深度学习(第一周深度学习概论)/","text":"学习驱动神经网络兴起的主要技术趋势，了解现今深度学习在哪里应用、如何应用。 8 月 8 日，吴恩达正式发布了 Deepleanring.ai——基于 Coursera 的系列深度学习课程，但在中国无法访问这套课程（除非你连VPN），还有Coursera中是英文授课，就有点尴尬。幸好，之后，吴恩达和网易合作，将课程内容免费放到网易的教育平台上.所以，终于有机会学这门课了！特记下笔记，以备忘！ 可以先看一下人工智能的完整学习图 有一起学习的同学，可以联系我，一起进步哦！！！Coursera学习Deep Learning Specialization网易云学习地址 什么是神经网络由输入到输出修正线性单元（ReLU） 用神经网络进行监督学习神经网络（neutral networks） 机器学习–&gt;监督学习 监督学习 standard NN – 房屋价格预测，广告点金 卷积神经网络（CNN）—图像领域 循环神经网络（RNN）—一维序列，时间，音频(机器翻译，语音变文本) 复杂，混合神经网络（complex,hybrid,NN）—（无人驾驶）基本图例： 结构化数据和非结构化数据 结构化数据：数据的数据库 非结构化数据：机器不容易理解的语音,图片,文本(用于语音识别，图像识别，自然语言文字处理) 如下图理解： 符号规定m–训练集的规模（训练样本的数量） 深度学习进行过程 学完第一周的课程，特意找了一张图片，宏观把控，今后一定非常有用 待续…….","tags":[{"name":"神经网络","slug":"神经网络","permalink":"http://yoursite.com/tags/神经网络/"},{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/tags/深度学习/"}]},{"title":"mongoexport导出数据时遇到的种种问题（好坑）","date":"2017-08-26T09:50:33.000Z","path":"2017/08/26/mongoexport导出数据时遇到的种种问题（好坑）/","text":"想导出mongodb数据库里的数据，结果，搞了一天，踩了无数的坑，才终于导出数据，真的，要哭了，赶紧记录下来（说实话，网上有些文章真的随着版本的更新，有些过时了，真的是助我踩坑耶）我主要讲我踩得坑哈，顺便说下！ 首先要开启服务，进入命令框NET START MongoDB然后进入安装目录（我的安装目录）：cd D:\\Program Files\\Work\\MongoDB\\Server\\3.4\\bin，执行mongo 执行以上两步后，就可以输入有用的命令了导出数据：mongoexport -h 127.0.0.1 -u root -p 12345 -d taobao -c prodect --type=cvs -o D:\\data\\prodect_cvs.dat不知上述意思的可以参见： Mongo的导出工具mongoexport介绍然后就报错122017-08-26T15:48:30.940+0800 error connecting to db server: server returned error on SASL authentication step: Authentication failed. 网上搜了一下，说–authenticationDatabase admin 这是是必须的，否则会报上述错误：解决办法再添加一串代码： --authenticationDatabase admin但是添加了之后还是报相同的错，又搜了一下,看了下面一篇博文 mongoDB authentication 连接到admin数据库，在admin数据库上创建一个用户，这个用户保存在admin.system.users中，它的权限比在其它数据库中设置的用户权限更大。（当admin.system.users中一个用户都没有时，即使mongod启动时添加了–auth参数，如果没有在admin数据库中添加用户，此时不进行任何认证还是可以做任何操作，直到在admin.system.users中添加了一个用户。） 原来是我没创建一个用户，但大家要注意创建用户的命令版本不同，命令也有可能不同，我就遇到了这个问题，mongodb3.X用的方法： mongoDB add user in v3.0 问题的解决（Property ‘addUser’ of object admin is not a func） 我的版本是3.X的，所有我应该执行下面 123456789101112use admindb.createUser( &#123; user: &quot;appAdmin&quot;, pwd: &quot;password&quot;, roles: [ &#123; role: &quot;readWrite&quot;, db: &quot;config&quot; &#125;, &quot;clusterAdmin&quot; ] &#125;) 旧点的版本：12use admindb.addUser(&apos;appAdmin&apos;, &apos;password&apos;) 创建完成之后如下图： 然后又遇到一个问题csv mode requires a field list,原因是第一次没有指明要导出的列，所以只是实现一个空的文件 123456user@user-xubuntu:/usr/lib/mongodb/bin$ sudo ./mongoexport -d wx_connect -c template --csv -o template_csv.dat connected to: 127.0.0.1 csv mode requires a field list ------第一次没有指明要导出的列，所以只是实现一个空的文件 user@user-xubuntu:/usr/lib/mongodb/bin$ sudo ./mongoexport -d wx_connect -c template --csv -f msgId,templateId,status,toUser -o template_csv_new.dat connected to: 127.0.0.1 exported 28 records ------导出成功 所以在末尾再加上-f 一列的名字mongoexport -h 127.0.0.1 -u root -p 12345 -d taobao -c prodect --type=cvs -o D:\\data\\prodect_cvs.dat --authenticationDatabase admin -f shop 参考博客： mongoDB的基本操作以及数据的导入导出，备份和恢复如下图 哇。终于完成了，有点小激动啊！！","tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://yoursite.com/tags/mongodb/"}]},{"title":"windows下mongodb的安装与配置（全）","date":"2017-08-25T09:50:33.000Z","path":"2017/08/25/windows下mongodb的安装与配置（全）/","text":"由于学Python存数据，需要用到mongodb数据库，自己在网上搜了很多教程，也踩了许多坑，特记录下来，希望能够对一些朋友有用,也记录下自己学的东西。 下载与安装 下载地址：https://www.mongodb.com/download-center#community 下载符合你系统的版本，然后安装。默认安装到C:\\Program Files\\MongoDB,你也可以自定义安装目录。我的目录是：·D:\\Program Files\\Work\\MongoDB\\Server\\3.4 创建数据目录MongoDB将数据目录存储在 db 目录下。但是这个数据目录不会主动创建，我们在安装完成后需要创建它。 请注意，数据目录应该放在根目录下（(如： C:\\ 或者 D:\\ 等 )。 这里我们新建mongodb文件夹在文件夹下新建各种东西我们假设创建数据目录在D:\\mongodbData\\data\\db 命令行运行mogondb服务假设你的mongodb安装在D:\\Program Files\\Work\\MongoDB\\Server\\3.4 打开cmd命令框进入安装目录D:\\Program Files\\Work\\MongoDB\\Server\\3.4\\bin 启动服务：mongod.exe --dbpath D:\\mongodbData\\data\\db 出现下图数据即算成功 将MongoDB服务器作为Windows服务运行先终止命令行，执行：12D:\\Program Files\\Work\\MongoDB\\Server\\3.4\\bin&gt; mongod.exe --logpath &quot;D:\\mongodbData\\data\\log\\mongodb.log&quot; --logappend --dbpath &quot;D:\\mongodbData/data/db&quot; --port 27017 --serviceName &quot;MongoDB&quot; --install 下表为mongodb启动的参数说明：自己注意按照自己的路径进行修改 12345678--bind_ip 绑定服务IP，若绑定127.0.0.1，则只能本机访问，不指定默认本地所有IP--logpath 定MongoDB日志文件，注意是指定文件不是目录--logappend 使用追加的方式写日志--dbpath 指定数据库路径--port 指定服务端口号，默认端口27017--serviceName 指定服务名称--serviceDisplayName 指定服务名称，有多个mongodb服务时执行。--install 指定作为一个Windows服务安装。 终止命令行中的mongodb服务，打开刚才新建的mongodb服务：NET START MongoDB运行之后如下图 如果出现服务器无法正常启动的问题，是因为mongod.lock这个文件，在服务器异常退出时，该文件会影响下一次启动mongod服务的,我们首先关闭命令行mongodb服务，然后只需要删除该文件就行了： mongod.exe --config e:\\data\\db\\mongod.lock --remove windows删除服务命令： sc delete MongoDB MongoDB后台管理 Shell进入安装目录：1cd D:\\Program Files\\Work\\MongoDB\\Server\\3.4\\bin` 执行mongo.exe,如下图 启动MongoDB服务net start MongoDB 关闭MongoDB服务net stop MongoDB 移除MongoDB服务D:\\Program Files\\Work\\MongoDB\\Server\\3.4\\bin\\mongod.exe --remove 最后说一下： 由于mongodb数据看不到摸不着，可视化工具是必须的推荐，推荐一个MongoDB可视化工具RoboMongoMongoDB可视化工具RoboMongo安装与连接教程安装很简单，但是别忘了配置环境变量 再推荐一个mongodbd的操作教程：http://wiki.jikexueyuan.com/project/mongodb/ 好了接下来就可以好好玩数据了 参考文章：http://www.jianshu.com/p/4bda3b7a9ea6http://www.jianshu.com/p/bc088aa972e9http://www.runoob.com/mongodb/mongodb-window-install.html","tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://yoursite.com/tags/mongodb/"}]},{"title":"Python 爬虫必备-正则表达式（re模块）","date":"2017-08-19T09:50:33.000Z","path":"2017/08/19/Python-爬虫必备-正则表达式（re模块）/","text":"正则表达式须知 正则表达式是用来匹配字符串非常强大的工具，在其他编程语言中同样有正则表达式的概念，Python同样不例外，利用了正则表达式，我们想要从返回的页面内容提取出我们想要的内容就易如反掌了。 正则表达式的大致匹配过程是：1.依次拿出表达式和文本中的字符比较，2.如果每一个字符都能匹配，则匹配成功；一旦有匹配不成功的字符则匹配失败。3.如果表达式中有量词或边界，这个过程会稍微有一些不同。 正则表达式语法规则下面是Python中正则表达式的一些匹配规则，图片资料来自CSDN 正则表达式特别强调 python转义字符 正则表达式使用反斜杠” \\ “来代表特殊形式或用作转义字符，这里跟Python的语法冲突，因此，Python用” \\\\ “表示正则表达式中的” \\ “，因为正则表达式中如果要匹配” \\ “，需要用\\来转义，变成” \\ “，而Python语法中又需要对字符串中每一个\\进行转义，所以就变成了” \\\\ “。 Python里的原生字符串很好地解决了这个问题，这个例子中的正则表达式可以使用r”\\”表示。同样，匹配一个数字的”\\d”可以写成r”\\d”。有了原生字符串，妈妈也不用担心是不是漏写了反斜杠，写出来的表达式也更直观勒。 贪婪模式和非贪婪模式 正则表达式通常用于在文本中查找匹配的字符串。Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；非贪婪则相反，总是尝试匹配尽可能少的字符。在”*”,”?”,”+”,”{m,n}”后面加上？,使贪婪变成非贪婪。 可参考： python 正则表达式的贪婪匹配与非贪婪匹配 Python Re模块Python 自带了re模块，它提供了对正则表达式的支持。主要用到的方法列举如下 12345678910#返回pattern对象re.compile(string[,flag]) #以下为匹配所用函数re.match(pattern, string[, flags])re.search(pattern, string[, flags])re.split(pattern, string[, maxsplit])re.findall(pattern, string[, flags])re.finditer(pattern, string[, flags])re.sub(pattern, repl, string[, count])re.subn(pattern, repl, string[, count]) 在介绍这几个方法之前，我们先来介绍一下pattern的概念，pattern可以理解为一个匹配模式，那么我们怎么获得这个匹配模式呢？很简单，我们需要利用re.compile方法就可以。例如1pattern = re.compile(r&apos;hello&apos;) 另外大家可能注意到了另一个参数 flags，在这里解释一下这个参数的含义： 参数flag是匹配模式，取值可以使用按位或运算符’|’表示同时生效，比如re.I | re.M。 可选值有：123456• re.I(全拼：IGNORECASE): 忽略大小写（括号内是完整写法，下同）• re.M(全拼：MULTILINE): 多行模式，改变&apos;^&apos;和&apos;$&apos;的行为（参见上图）• re.S(全拼：DOTALL): 点任意匹配模式，改变&apos;.&apos;的行为• re.L(全拼：LOCALE): 使预定字符类 \\w \\W \\b \\B \\s \\S 取决于当前区域设定• re.U(全拼：UNICODE): 使预定字符类 \\w \\W \\b \\B \\s \\S \\d \\D 取决于unicode定义的字符属性• re.X(全拼：VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。 在刚才所说的另外几个方法例如 re.match 里我们就需要用到这个pattern了，下面我们一一介绍。 （1）re.match(pattern, string[, flags])这个方法将会从string（我们要匹配的字符串）的开头开始，尝试匹配pattern，一直向后匹配，如果遇到无法匹配的字符，立即返回None，如果匹配未结束已经到达string的末尾，也会返回None。两个结果均表示匹配失败，否则匹配pattern成功，同时匹配终止，不再对string向后匹配。下面我们通过一个例子理解一下123456789101112131415161718192021222324252627282930313233343536373839# 将正则表达式编译成Pattern对象，注意hello前面的r的意思是“原生字符串”pattern = re.compile(r&apos;hello&apos;) # 使用re.match匹配文本，获得匹配结果，无法匹配时将返回Noneresult1 = re.match(pattern,&apos;hello&apos;)result2 = re.match(pattern,&apos;helloo CQC!&apos;)result3 = re.match(pattern,&apos;helo CQC!&apos;)result4 = re.match(pattern,&apos;hello CQC!&apos;) #如果1匹配成功if result1: # 使用Match获得分组信息 print(result1.group())else: print (&apos;1匹配失败！&apos;) #如果2匹配成功if result2: # 使用Match获得分组信息 print(result2.group())else: print( &apos;2匹配失败！&apos;) #如果3匹配成功if result3: # 使用Match获得分组信息 print( result3.group())else: print(&apos;3匹配失败！&apos;) #如果4匹配成功if result4: # 使用Match获得分组信息 print( result4.group())else: print( &apos;4匹配失败！&apos;) 我们还看到最后打印出了result.group()，这个是什么意思呢？下面我们说一下关于match对象的的属性和方法Match对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。 12341.group([group1, …]):获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。2.groups([default]):以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。 （2）re.search(pattern, string[, flags])search方法与match方法极其类似，区别在于match()函数只检测re是不是在string的开始位置匹配，search()会扫描整个string查找匹配，match（）只有在0位置匹配成功的话才有返回，如果不是开始位置匹配成功的话，match()就返回None。同样，search方法的返回对象同样match()返回对象的方法和属性。我们用一个例子感受一下 12345678# 将正则表达式编译成Pattern对象pattern = re.compile(r&apos;world&apos;)# 使用search()查找匹配的子串，不存在能匹配的子串时将返回None# 这个例子中使用match()无法成功匹配match = re.search(pattern,&apos;hello world!&apos;)if match: # 使用Match获得分组信息 print( match.group()) （3）re.split(pattern, string[, maxsplit])按照能够匹配的子串将string分割后返回列表。maxsplit用于指定最大分割次数，不指定将全部分割。我们通过下面的例子感受一下。 12345pattern = re.compile(r&apos;\\d+&apos;)print( re.split(pattern,&apos;one1two2three3four4&apos;)) ### 输出 #### [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;, &apos;four&apos;, &apos;&apos;] （4）re.findall(pattern, string[, flags])搜索string，以列表形式返回全部能匹配的子串。我们通过这个例子来感受一下 12345pattern = re.compile(r&apos;\\d+&apos;)print( re.findall(pattern,&apos;one1two2three3four4&apos;)) ### 输出 #### [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;] （5）re.finditer(pattern, string[, flags])搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。我们通过下面的例子来感受一下 123456pattern = re.compile(r&apos;\\d+&apos;)for m in re.finditer(pattern,&apos;one1two2three3four4&apos;): print( m.group()), ### 输出 #### 1 2 3 4 （6）re.sub(pattern, repl, string[, count])使用repl替换string中每一个匹配的子串后返回替换后的字符串。当repl是一个字符串时，可以使用\\id或\\g、\\g引用分组，但不能使用编号0。当repl是一个方法时，这个方法应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。count用于指定最多替换次数，不指定时全部替换。123456789pattern = re.compile(r&apos;(\\w+) (\\w+)&apos;)s = &apos;i say, hello world!&apos; print( re.sub(pattern,r&apos;\\2 \\1&apos;, s)) def func(m): return m.group(1).title() + &apos; &apos; + m.group(2).title() print( re.sub(pattern,func, s)) （7）re.subn(pattern, repl, string[, count])返回 (sub(repl, string[, count]), 替换次数)。12345678910111213pattern = re.compile(r&apos;(\\w+) (\\w+)&apos;)s = &apos;i say, hello world!&apos; print( re.subn(pattern,r&apos;\\2 \\1&apos;, s)) def func1(m): return m.group(1).title() + &apos; &apos; + m.group(2).title() print( re.subn(pattern,func1, s)) ### output #### (&apos;say i, world hello!&apos;, 2)# (&apos;I Say, Hello World!&apos;, 2) 参考：静觅 » Python爬虫入门七之正则表达式python中re项目详解","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python3X安装beautifulsoup&&BS64遇到的一些error","date":"2017-08-19T09:50:33.000Z","path":"2017/08/19/python3X安装beautifulsoup&&BS64遇到的一些error/","text":"用beautifulsoup写的没错的小爬虫地址： 前言: Beautiful Soup 3 目前已经停止开发，推荐在现在的项目中使用Beautiful Soup 4，不过它已经被移植到BS4了，也就是说导入时我们需要 import bs4 。所以这里我们用的版本是 Beautiful Soup 4.3.2 (简称BS4)，另外据说 BS4 对 Python3 的支持不够好，虽然我用的Python35，如果有小伙伴用的是 Python3 版本，可以考虑下载 BS3 版本。自己搞网页数据爬取时，需要 from bs4 import BeautifulSoup,所以在py程序运行中遇到了一系列错误……. 错误一：ImportError: No module named &#39;bs4&#39;错误如下： 解决方法如下 Python如何安装模块： 1.下载BS4模块： http://www.crummy.com/software/BeautifulSoup/bs4/download/4.3/beautifulsoup4-4.3.2.tar.gz 2.解压到Python安装目录下的根目录中： 3.运行cmd，进入解压缩后的目录（如果Python默认安装在C盘下，打开cmd之后可以使用cd …语句先返回根目录，再进入Python27\\beautifulsoup4-4.3.2）4.进入Python27\\beautifulsoup4-4.3.2之后安装BS4模块：执行：python setup.py install 可参考链接：http://www.cnblogs.com/victor5230/p/6397449.html 然而又出现错误： 错误二： ImportError: cannot import name &#39;HTMLParseError&#39;解决bs4在Python 3.5下出现“ImportError: cannot import name ‘HTMLParseError’”错误 解决方法如下：直接在cmd命令框中执行pip --upgrade beautifulsoup4 可参考链接：http://blog.csdn.net/sinat_26599509/article/details/50609646 错误三：bs4.FeatureNotFound又出现错误:如下 bs4.FeatureNotFound: Couldn&#39;t find a tree builder with the features you requested: lxml. Do you need to install a parser library? 解决方法：首先安装’pip install wheel’https://www.zhihu.com/question/49221958/answer/115712155 安装pip install lxml可参考链接1：https://www.zhihu.com/question/49221958/answer/115712155可参考链接2：http://study.163.com/forum/detail/1002230039.htm 竟然就好了！！！！！！！","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python35下的NLTK工具的安装和配置","date":"2017-08-17T09:50:33.000Z","path":"2017/08/17/python35下的NLTK工具的安装和配置/","text":"首先要说明的是我的安装环境是win7 64位，安装了python35 官网下载NLTKhttps://pypi.python.org/pypi/nltk我安装的是nltk-3.2.4.tar.gz安装上述软件，我的安装目录是D:\\Program Files\\Computer-learning解压缩nltk-3.2.4.tar.gz，在 cmd 中进入到D:\\Program Files\\Computer-learning\\nltk-3.2.4目录，执行 python setup.py install 成功标志：123Installed c:\\users\\hasee\\appdata\\local\\programs\\python\\python35\\lib\\site-packages\\six-1.10.0-py3.5.eggFinished processing dependencies for nltk==3.2.4 安装完成后，在IDLE中运行：执行下面两行 12import nltknltk.download() 出现一个NLTK Downloader对话框，修改Download Diretory（E盘或其他盘符下），我放在了C:\\Users\\hasee\\AppData\\Roaming\\nltk_data。点击all开始下载，如下 下载完成后 下载慢还可以到NLTK Corpora http://nltk.org/nltk_data/手工下载缺失的，然后放到Download Diretory，zip别删。重装系统后nltk_data文件夹可以保留，避免重复下载。","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Python安装与Eclipse环境配置（踩坑,看完这篇就够了）","date":"2017-08-12T09:50:33.000Z","path":"2017/08/12/Python安装与Eclipse环境配置（踩坑,看完这篇就够了）/","text":"安装python（配置环境变量）http://www.runoob.com/python/python-tutorial.html 配置Eclipse（路径）http://www.runoob.com/python/python-ide.html 配置PyDev 点击help按钮–&gt;Install New Software Name:取PyDevLocation：http://www.pydev.org/updates进去之后只需选择第一个包，点击next，之后一直点击下一步即可（有任何弹框，选择accept）完成，点击Yes重新启动Eclipse 新建python项目流程点击new Project，会出现Pydev文件夹，选择PyDev Project，点击Next点击OK点击apply应用点击next点击finish然后在新建的Project（python35）右击，new一个PyDev Module这样基本就完成了下面写一行代码测试一下选直接运行就行，目前不需要单元测试运行之后报错12Python脚本语法错误：SyntaxError: (unicode error) &apos;utf8&apos; codec can&apos;t decode byte 0xc0 in position 0: invalid start byte ![mark](http://upload-images.jianshu.io/upload_images/4340772-e7845b15c4257aa3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 这是因为编码格式出现问题具体了解可参考下面这个文章http://againinput4.blog.163.com/blog/static/1727994912011112224749861/要加两行代码12#!/usr/bin/python # -*- coding: UTF-8 -*- 有个尴尬的问题：我加上那两行代码，还是出错，删除那两行代码，又可以运行了,可能之前我安装了python27,这次安装了python35，第一次运行没反应过来，哈哈。总结一下： python2.X版本需要加下面这两行代码，python3.X则不需要12#!/usr/bin/python # -*- coding: UTF-8 -*- 接下来就可以好好玩Python（蛇）了","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Windows环境下msysgit下安装gitflow步骤","date":"2017-08-11T09:50:33.000Z","path":"2017/08/11/Windows环境下msysgit下安装gitflow步骤/","text":"在网上，查了好多资料，不过网上说法有好多坑，所有自己特意写了一篇，以便看此博文的人少踩坑！！ #一、Git相关配置（Windows） ##1.安装git和git flowWindows下git客户端：Git-1.9.2-preview20140411.exe参考文档，来自github的gitflow的wiki，链接：https://github.com/nvie/gitflow/wiki/Windows 这里只介绍msysgit环境下的gitflow安装。首先需要下载两个文件：getopt.exe和libintl3.dll下载地址：（可以在浏览器下载就直接下载，如果不行（反正我是不行），复制网址到 迅雷直接下载）http://sourceforge.net/projects/gnuwin32/files/util-linux/2.14.1/util-linux-ng-2.14.1-bin.zip/downloadhttp://sourceforge.net/projects/gnuwin32/files/util-linux/2.14.1/util-linux-ng-2.14.1-dep.zip/download上面两个链接，分别下载到两个文件：util-Linux-ng-2.14.1-bin.zip和util-linux-ng-2.14.1-dep.zip我们需要的文件，getopt.exe文件在util-linux-ng-2.14.1-bin.zip文件中的bin目录下，libintl3.dll也在util-linux-ng-2.14.1-dep.zip文件的bin目录下，将这两个文件拷贝到msysgit安装目录的bin目录下。 然后打开“git Bash”输入下面的命令：1$ git clone --recursive git://github.com/nvie/gitflow.git 等下载完毕，打开windows下的命令行工具，进入到刚才下载的文件目录中，例如：如果刚才是在c盘下执行的git clone命令，则进入到F:\\Front-End\\gitflow目录，然后执行下面命令（可能需要管理员权限）F:\\Front-End\\gitflow&gt; contrib\\msysgit-install.cmd如下图：出现MsysGit installation directory not found不用管 执行完毕，打开“Git Bash”，输入命令 git flow，若安装成功，出现下图界面： 如果你看到这，恭喜，你完成了，接下来，享受gitflow吧。 2 clone项目并初始化git flow1234git clone https://github.com/Tours4Fun/yiifrontendtff.gitcd yiifrontendtffgit flow init#一路回车 #二、本地开发流程 ##1. 切换到develop分支1git checkout develop ##2. 更新develop分支1git pull origin develop ##3. 基于develop新建分支123git flow feature start proj&#123;项目ID&#125;_&#123;项目简要描述&#125; #假设项目2312: git flow feature start proj2312_update_sitemap ##4. 进行开发123git status #提交前最好先查看修改了哪些文 git add . #添加文件 git commit -m \"update sitemap.xml 注释\" #提交日志 ##5. 完成开发后把分支push到远程:1git push origin feature/proj2312_update_sitemap ##6. 工单上线后可以定义删除本地无用分支(可选):12git branch -d feature/proj2312_update_sitemap git branch -D feature/proj2312_update_sitemap #强制删除 ##7. 常用命令123456git branch #查看本地分支 git checkout branch-name #切换分支 git remote update -p #远程分支拉到本地 git branch -a | grep 关键字 #搜索分支 git branch -m #重命名分支名 git push origin :feature/feature/proj2312_update_sitemap #删除远端分支 ###8. 更多命令更多命令","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"域名解析后主机记录和记录值怎么填写？都是什么意思？","date":"2017-07-31T09:50:33.000Z","path":"2017/07/31/域名解析后主机记录和记录值怎么填写？都是什么意思？/","text":"&gt;之前我买的域名在腾讯云解析之后，需要添加记录，开始一脸懵啊，在网上搜查了一些资料，整理了一下，希望为大家解点惑吧！ 主机记录：主机记录就是域名前缀，常见用法有： www：解析后的域名为 www.1756260160.com @：直接解析主域名 1756260160.com ：泛解析，匹配其他所有域名 *.1756260160.com 记录类型：要指向空间商提供的 IP 地址，选择「类型 A」，要指向一个域名，选择「类型 CNAME」 A记录：地址记录，用来指定域名的IPv4地址（如：8.8.8.8），如果需要将域名指向一个IP地址，就需要添加A记录。 CNAME： 如果需要将域名指向另一个域名，再由另一个域名提供ip地址，就需要添加CNAME记录。 NS：域名服务器记录，如果需要把子域名交给其他DNS服务商解析，就需要添加NS记录。 AAA：用来指定主机名（或域名）对应的IPv6地址（例如：ff06:0:0:0:0:0:0:c3）记录。 MX：如果需要设置邮箱，让邮箱能收到邮件，就需要添加MX记录。 线路：让指定线路的用户访问这个IP常见用法有： 默认：必须添加，否则只有单独指定的线路才能访问您的网站。如果双线解析，建议「默认」线路填写「电信IP」 联通：单独为「联通用户」指定服务器 IP，其他用户依然访问「默认」 搜索引擎：指定一个服务器 IP 让抓取 记录值：最常见的是将空间商提供的「IP地址」填写在这里哦～比如我用的就是github上的IP各类型的记录值一般是这样的：A记录：填写您服务器 IP，如果您不知道，请咨询您的空间商CNAME记录：填写空间商给您提供的域名，例如：2.comMX记录：填写您邮件服务器的IP地址或企业邮局给您提供的域名，如果您不知道，请咨询您的邮件服务提供商AAAA：不常用。解析到 IPv6 的地址。NS记录：不常用。系统默认添加的两个NS记录请不要修改。NS向下授权，填写dns域名，例如：ns3.dnsv3.comTTL: 我们默认的 600 秒是最常用的，不用修改即 Time To Live，缓存的生存时间。指地方dns缓存您域名记录信息的时间，缓存失效后会再次到DNSPod获取记录值。600（10分钟）：建议正常情况下使用 600。60（1分钟）：如果您经常修改IP，修改记录一分钟即可生效。长期使用 60，解析速度会略受影响。 3600（1小时）：如果您IP极少变动（一年几次），建议选择 3600，解析速度快。如果要修改IP，提前一天改为 60，即可快速生效。","tags":[{"name":"域名","slug":"域名","permalink":"http://yoursite.com/tags/域名/"}]},{"title":"各种邮箱pop，SMTP设置","date":"2017-07-31T09:50:33.000Z","path":"2017/07/31/各种邮箱pop，SMTP设置/","text":"看到很多用户在绑定邮箱时出现各种各样的问题，特将主流邮箱的配置问题汇总,供大家参考也供自己参考 首先向大家简单介绍一下尚邮绑定邮箱的注意事项： 1、请先确认您的邮箱支持pop3只要支持pop3或者imap4协议的公众邮箱和企业邮箱都可以使用尚邮。 目前大多数免费公众邮箱都支持pop功能，但是部分需要要手动开启（在本文的后面我们会针对几个常见的公众邮箱开通POP服务以及服务器配置方式进行介绍）。确认您的邮箱支持pop3或者imap4协议后您就可以绑定邮箱了 新浪(sina)邮箱配置方法及介绍新浪邮箱自今年（08年）6月分服务器被攻击后开始对pop取件频率进行了严格限制，同时新注册的用户需要手动才能开通pop功能（老用户不需要）。 手动开通pop的方法：登录新浪邮箱后点击“邮箱设置”-“帐户”-“pop-smtp设置”勾选“开启”后“保存”，如图所示：服务器配置方法： 类型： POP3接收邮件服务器： pop.sina.com 接收端口： 110 SSL 否发送邮件服务器： smtp.sina.com 发送端口： 25 SSL 否 QQ邮箱配置方法及介绍登陆您的QQ邮箱页面后点击页面上方的“设置”-“账号”-“POP3/SMTP服务”勾选“开启POP3/SMTP服务”后“保存修改”服务器配置方法：类型： POP3接收邮件服务器： pop.qq.com 接收端口： 110 SSL 否发送邮件服务器： smtp.qq.com发送端口： 25 SSL 否补充说明：由于QQ邮箱服务器与尚邮服务器之间的通讯速度受到网通与电信间冲突的影响，经常出现通讯超时的情况，因此即便绑定成功也会延迟较为严重。另外，QQ邮箱服务器也开始对pop频次进行限制，一旦超过会被拖入黑名单。由于尚邮的腾讯用户非常多，为解决此问题已与腾讯进行协商，将pop频次上线提高，但若添加人数很多仍会超限。因此如果您的QQ邮箱已开通pop功能但仍添加失败，很可能是pop超限导致的。基于如上几点因素，QQ邮箱在尚邮上的用户体验不是很好，不推荐您使用。建议您将QQ邮箱邮件转发至其他支持pop的邮箱上代收。 网易(126/163/yeah.net)邮箱配置方法及介绍 网易免费邮箱对pop取信频率有严格的限制，因此相对取信速度比较慢。网易免费邮箱中126和163邮箱06年后注册的以及yeah.net邮箱07年后的注册用户不再支持pop功能，需要定制其“随身邮服务”方可开通，老用户本身就是支持pop功能的，无需定制。 126邮箱配置方法：类型： POP3接收邮件服务器： pop.126.com接收端口： 110 SSL 否发送邮件服务器： smtp.126.com发送端口： 25 SSL 否特别说明：如果您确认您的126邮箱开通了POP功能，但还是不能绑定成功，可以尝试在邮箱用户名处填写126邮箱地址全称，再看是否能绑定成功。通常，126邮箱无论使用@符号前内容或者用邮箱全称来填写“邮箱用户名”都可以成功绑定。您可以多尝试下。163邮箱配置方法：类型： POP3接收邮件服务器： pop.163.com接收端口： 110 SSL 否发送邮件服务器： smtp.163.com发送端口： 25 SSL 否 Gmail邮箱配置方法及介绍Gmail邮箱也需要手动配置pop或者imap功能。 配置方法如下： 登录Gmail邮箱后点击“设置”-“转发和pop smtp”-“pop下载”下勾选“对从现在起所收到的邮件启用pop”或者“IMAP访问”中勾选“启用IMAP”然后“保存更改”POP3配置方法：类型： POP3接收邮件服务器： pop.gmail.com接收端口： 995 SSL 是发送邮件服务器： smtp.gmail.com发送端口：： 587 /25 SSL 是 （465说是可以但是测试总是超时）IMAP配置方法：类型： IMAP4接收邮件服务器： imap.gmail.com接收端口： 993 SSL 是 发送邮件服务器： smtp.gmail.com发送端口： 587 /25 SSL 是 （465说是可以但是测试总是超时 25推荐）补充说明：由于Gmail邮箱服务器本身设置的原因，Gmail邮箱邮件只允许邮件客户端软件pop收取一次，因此尚邮取过的邮件，pc客户端如outlook将收不到，反之亦然。解决方案可以参考二楼“Gmail邮件只POP一次怎么办？ ”贴。另外，Gmail邮箱是将已发送邮件和收到的邮件存放在一起的，所以使用客户端软件收Gmail的邮件会将已发送的邮件一同收取下来。 腾讯企业邮箱POP,SMTP分别是什么我今天想用QQ邮箱代收我的腾讯企业邮箱就遇到这个问题， 上图中如果是腾讯企业邮箱的话：POP地址应填：pop.exmail.qq.com 腾讯企业邮箱POP3/SMTP协议接收邮件服务器：pop.exmail.qq.com (端口 110)，使用SSL，端口号995发送邮件服务器：smtp.exmail.qq.com (端口 25)，使用SSL，端口号465 海外用户可使用以下服务器接收邮件服务器：hwpop.exmail.qq.com (端口 110)，使用SSL，端口号995发送邮件服务器：hwsmtp.exmail.qq.com (端口 25)，使用SSL，端口号465 腾讯企业邮箱IMAP协议接收邮件服务器：imap.exmail.qq.com (端口 143)，使用SSL，端口号993发送邮件服务器：smtp.exmail.qq.com (端口 25)，使用SSL，端口号465 海外用户可使用以下服务器接收邮件服务器：hwimap.exmail.qq.com (端口 143)，使用SSL，端口号993发送邮件服务器：hwsmtp.exmail.qq.com (端口 25)，使用SSL，端口号465 QQ还开发了邮我功能：","tags":[{"name":"邮箱","slug":"邮箱","permalink":"http://yoursite.com/tags/邮箱/"}]},{"title":"post和get的真正区别？","date":"2017-07-30T09:50:33.000Z","path":"2017/07/30/在腾讯企业邮箱设置自己的域名邮箱/","text":"第一步 买域名 这一步网上有很多的相关教程，大家可以查阅，自己亦可摸索，增加实践的机会。 如果是大学生，建议大家可以在阿里云或腾讯云里买，有学生优惠， 第二步 注册腾讯企业邮箱账号1.打开浏览器.输入”exmail.qq.com/” 新用户注册 点击立即开通 按域名–填写管理员信息–添加企业邮箱–一步步来就行因为我买的腾讯云的域名，所以方法一直接就能自动设置手动设置也行 上图片自动设置成功 设置基本完成，然后进入你的企业邮箱，就可以添加成员了 好了，这样就大功告成了，好好耍耍吧","tags":[{"name":"邮箱","slug":"邮箱","permalink":"http://yoursite.com/tags/邮箱/"},{"name":"域名","slug":"域名","permalink":"http://yoursite.com/tags/域名/"}]},{"title":"Github自身踩到的坑","date":"2017-07-28T15:36:05.000Z","path":"2017/07/28/Github自身踩到的坑/","text":"用Github有一两年了，是时候总结一下以前踩得坑了，这些坑开始时还真把自己摔得不轻！！！！！小插曲：自己以前用hexo搭建的博客，每次写博客都要新建.md文件等初始化步骤,然后提交，有些繁琐，再加上自己又换了台电脑，又要部署hexo（虽然不需要重新部署），但还是有些步骤，索性用简书写，方便快捷些！ git pull时ssh: Could not resolve hostname github.com: Name or service not known, fatal: Could not read from remote repository.123456$ git pullssh: Could not resolve hostname github.com: Name or service not knownfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 这个错误好醉，是因为没网了，就很皮 git本地仓库首次push到远程仓库出现错误 ! [rejected] master -&gt; master (fetch first)新建好本地的仓库和远程仓库之后， 经过git add .然后git commit -m &quot;......&quot;最后想推送到远程仓库的时候 git push -u origin master出现下图错误 解决很简单，使用强制推送使用下面的命令git push -f origin master 附上git push 的说明12345678910111213141516171819NAMEgit-push - Update remote refs along with associated objectsSYNOPSISgit push [--all | --mirror | --tags] [--follow-tags] [--atomic] [-n | --dry-run] [--receive-pack=&lt;git-receive-pack&gt;] [--repo=&lt;repository&gt;] [-f | --force] [--prune] [-v | --verbose] [-u | --set-upstream] [--[no-]signed|--sign=(true|false|if-asked)] [--force-with-lease[=&lt;refname&gt;[:&lt;expect&gt;]]] [--no-verify] [&lt;repository&gt; [&lt;refspec&gt;…​]]-f --forceUsually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. Also, when --force-with-lease option is used, the command refuses to update a remote ref whose current value does not match what is expected.This flag disables these checks, and can cause the remote repository to lose commits; use it with care.Note that --force applies to all the refs that are pushed, hence using it with push.default set to matching or with multiple push destinations configured with remote.*.push may overwrite refs other than the current branch (including local refs that are strictly behind their remote counterpart). To force a push to only one branch, use a + in front of the refspec to push (e.g git push origin +master to force a push to the master branch). See the&lt;refspec&gt;... section above for details. github上传时出现error: src refspec master does not match any如下： 引起该错误的原因是，目录中没有文件，空目录是不能提交上去的 解决方法:先提交文件git add . git commit -m &quot;&quot;例如下：1234touch READMEgit add README git commit -m &apos;first commit&apos;git push origin master fatal： unable to create ‘../../.git/index.lock’:File exists 解决方法：把文件index.lock删掉 ###Permission denied (publickey).fatal: The remote end hung up unexpectedly 错误原因：github上没有配置公钥解决方法：配置公钥，并放到github上GitHub设置公钥在windows下面 安装git，从程序目录打开 “Git Bash” 键入命令：ssh-keygen -t rsa -C “email@email.com”“email@email.com”是github账号 提醒你输入key的名称，输入如id_rsa如果执行成功。返回 Generating public/private rsa key pair.Enter file in which to save the key (/home/forwhat.cn/.ssh/id_rsa):在这里就是设置存储地址了.反正我是直接按的回车，一直回车 在C:\\Documents and Settings\\Administrator\\下产生两个文件：id_rsa和id_rsa.pub 把4中生成的密钥文件复制到C:\\Documents and Settings\\Administrator.ssh\\ 目 录下。 用记事本打开id_rsa.pub文件，复制内容，在github.com的网站上到ssh密钥管理页面，添加新公钥，随便取个名字例如你的电脑名 需要注意步骤2中产生的密钥文件在当前用户的根目录，必须把这两个文件放到当前用户目录的“.ssh”目录下才能生效。 ————2017/8/14 There is no tracking information for the current branch. Please specify which branch you want to merge with. 是因为本地分支和远程分支没有建立联系 (使用git branch -vv 可以查看本地分支和远程分支的关联关系) .根据命令行提示只需要执行以下命令即可 如果不想新建分支git branch --set-upstream master origin/master 如果想新建分支git branch --set-upstream-to=origin/远程分支的名字 本地分支的名字 git branch –set-upstream-to=origin/develop develop或git branch --set-upstream develop origin/develop（develop为新建分支name）同时推荐大家看一下下面这篇–创建于合并分支https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840038939c291467cc7c747b1810aab2fb8863508000 2018-2-26关闭 pull request（Closing a pull request）因为pull request错了，所以想取消pull request，怎么做呢？看图吧 坑不会踩完的，但会一直进步着，大家加油……","tags":[]},{"title":"Sublime侧边栏[SideBar]字体变大","date":"2017-01-15T08:05:40.000Z","path":"2017/01/15/Sublime侧边栏字体变大/","text":"","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}]},{"title":"MPic神器-上传照片直接生成外链","date":"2017-01-12T06:31:40.000Z","path":"2017/01/12/Mpic神器/","text":"一直以来写博文，上传本地照片是一个特别麻烦的事，一来webstorm收费，其次cmd Markdown上传照片只支持外联，而上传照片到七牛云不失为一个好方法，但操作过程复杂，正在我愁眉不展时，上网一搜，搜到了一神器Mpic-图床神器。可以和七牛云绑定一起发挥威力。下载链接经过自己的一番折腾，最终发现MPic果然省时省事不少，目前我知道的上传方式有2种： 截图上传（QQ截图个人感觉不错） 拖拽本地图片上传下载之后的界面：下面介绍一下下载软件之后的操作步骤： 下载之后首先就是注册账号注意几个问题： 首先你用默认域名时，账户余额应不少于10元; 申请存储空间七牛云自己会带个域名，用这个自带的域名就可以，如下图，当然，用自己绑定的域名也可以，不过域名必须是注册过的，注册很麻烦耗时，不嫌麻烦的也可以试试。 在我的上传中，可查看和删除自己之前上传过的照片 好，大功告成，终于可以好好地写自己的博客，顺带肆意的上传自已的照片了！！哈哈哈","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}]},{"title":"HTML5-canvas之绘制圆弧和贝塞尔曲线(3)","date":"2017-01-01T09:50:33.000Z","path":"2017/01/01/HTML5-canvas之绘制圆弧和贝塞尔曲线/","text":"今天我们主要是学习如何绘制圆弧和贝塞尔曲线。 圆弧的绘制圆弧可以理解为一个圆上的某部分线段，在canvas中，绘制一条圆弧的语法如下：1ctx.arc( 圆心x坐标, 圆心y坐标, 圆的半径r , 开始角度, 结束角度 ); 其中的 “开始角度” 和 “结束角度” 是相对360度的 顺时针 的极坐标而言的，可配合下图理解： 我们来一个例子，绘制一个圆心坐标为(80,80)，半径为40，开始角度为30度，结束角度为90度，那么可以这样绘制：12345678910&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.arc( 80, 80, 40, 1/6*Math.PI, 1/2*Math.PI);ctx.stroke(); //描边&lt;/script&gt; 其中开始角和结束角我们分别设定为“1/6Math.PI”和“1/2Math.PI”，是因为canvas里的角度是以PI（π）为单位的，在js中写作Math.PI，你可以把一个PI理解为180度，那么30度便是1/6个PI。上述代码效果如下： 开始角和结束角也可以是负值，则角度从0度开始以逆时针方式获取：1234var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.arc( 80, 80, 40, -1/6*Math.PI, -1/2*Math.PI);ctx.stroke(); //描边 我们可以很轻松地来绘制一个完整的圆，将起始角设为0度，结束角设为360度（2*Math.PI）即可： 123456789var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.arc( 80, 80, 40, 0, 2*Math.PI);ctx.lineWidth = 3; //描边宽度为3pxctx.strokeStyle = &quot;yellow&quot;;ctx.stroke(); //描边ctx.fillStyle = &quot;#4DA6FF&quot;;ctx.fill(); //填充颜色 注意给圆填充颜色我们使用的是 .fill() 方法，和多边形的填充方式一样。 接着说说 arc() 的好兄弟 arcTo() 方法，它可以在两条线段之间连接起一条弧线，其语法如下 ctx.arcTo( 起点切线末端x坐标, 起点切线末端y坐标, 终点x坐标, 终点y坐标, 圆的半径r ); 可以配合下图理解： 我们先不管什么“连接两条线段”的事情，单纯看下arcTo()绘制了怎样的一条圆弧：1234567891011&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.moveTo(20,20); // 创建开始点ctx.arcTo(60,20,60,60,40); // 创建圆弧路径ctx.stroke(); &lt;/script&gt; 那么我们利用arcTo()方法来连接两条直线吧： 12345678910111213&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.moveTo(20,20);ctx.lineTo(60,20);ctx.arcTo(100,20,100,60,40); // 创建圆弧路径ctx.lineTo(100,100);ctx.stroke(); &lt;/script&gt; 需要知道的是 arc() 不会影响画笔的位置，而 arcTo() 会把画笔移到圆弧线的终点位置。 曲线的绘制无论是arc()抑或arcTo()，均是绘制了一个正圆上的部分圆弧线段，下面讲讲更灵活的曲线的绘制。 首先介绍的是canvas中贝塞尔曲线的绘制。使用过AI等专业矢量制图软件的朋友相信能很好地理解这一部分。我们先看下在制图软件中用钢笔工具绘制一条贝塞尔曲线的过程： 可以看到每两点可以连成一条贝塞尔路径，且每一个点都有一条方位控制线来控制曲线的弯曲程度和走向，在canvas中也是以类似形式控制贝塞尔曲线的形状。 我们先来看看bezierCurveTo()的实现方式，它称作“三次方贝塞尔曲线”，其语法为：1ctx.bezierCurveTo( CSx, CSy, CEx, CEy, Ex, Ey ); 其中CSx、CSy表示贝塞尔曲线起点方向控制线末端的x坐标和y坐标。CEx、CEy表示贝塞尔曲线终点方向控制线末端的x坐标和y坐标。Ex、Ey表示贝塞尔曲线终点坐标。 参考图如下，图中的贝塞尔曲线起点坐标为（20,20），终点坐标为（200,20），起点的方向控制线末端坐标为（20,100），终点的方向控制线末端坐标为（200,100）： 有的朋友可能会问为何bezierCurveTo()方法没有起始点的参数，答案是起始点默认为bezierCurveTo()方法执行之前画笔所在的位置，我们可以通过ctx.moveTo(x,y)来确定起始点的位置。 如上图所示的贝塞尔曲线我们可以这样绘制：1234567891011&lt;canvas id=&quot;myCanvas&quot; width=&quot;300&quot; height=&quot;150&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.moveTo(20,20); //确定起始点ctx.bezierCurveTo( 20, 100, 200, 100, 200, 20 );ctx.stroke(); //描边&lt;/script&gt; 我们可以绘制两条或者多条连在一起的贝塞尔曲线，从而塑造我们想要的曲线： 123456789101112&lt;canvas id=&quot;myCanvas&quot; width=&quot;400&quot; height=&quot;250&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.moveTo(20,120); //确定起始点ctx.bezierCurveTo( 20, 200, 200, 200, 200, 120 ); //绘制第一条贝塞尔曲线ctx.bezierCurveTo( 200, 20, 380, 20, 380, 120 ); //绘制第二条贝塞尔曲线，该曲线起点为上一条曲线终点（200，120）ctx.stroke(); //描边&lt;/script&gt; 使用过矢量制图软件的朋友可能有个地方会困惑，那就是我们很多时候开始绘制一条曲线时（起点不做拉伸），该曲线的起点是没有任何方向控制线的，如下图： 如果我们要绘制一条起点不做方向控制的曲线，那么bezierCurveTo()方法就不再适用了。 针对这种情况，可以通过 quadraticCurveTo() 方法来解决，它称作“二次方贝塞尔曲线”，语法为 ctx.quadraticCurveTo( CEx, CEy, Ex, Ey ); 其中CEx、CEy表示曲线终点方向控制线末端的x坐标和y坐标。Ex、Ey表示曲线终点坐标。至于曲线起点则跟bezierCurveTo()一样，为该方法执行前画笔所在的位置。 我们试着来绘制一条这样的曲线，它是我在AI中用钢笔工具绘制出来的： 它的矢量轮廓是这样的： 由于起点是没有方向控制线的，我们很容易知道得先绘制一条quadraticCurve，然后再紧接着绘制一条bezierCurve来完成这条曲线。 我们先确定下各点的坐标： 然后轻松写出代码： 123456789101112&lt;canvas id=&quot;myCanvas&quot; width=&quot;490&quot; height=&quot;270&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.moveTo(52,37); //确定起始点ctx.quadraticCurveTo( 45, 175, 172, 157 ); //绘制第一条曲线ctx.bezierCurveTo( 298, 140, 337, 201, 312, 236 ); //绘制第二条曲线ctx.stroke(); //描边&lt;/script&gt; 效果杠杠的 建议有兴趣的朋友多实践，其中贝塞尔曲线部分的知识点可以通过AI等矢量设计软件来加深理解。共勉~ 啦啦啦还有，大家元旦快乐啊！ 有关链接 http://www.cnblogs.com/vajoy/p/3925190.html","tags":[{"name":"html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"HTML5-Canvas之矩阵和多边形的绘制（2）","date":"2016-12-25T09:50:33.000Z","path":"2016/12/25/HTML5-Canvas之矩阵和多边形的绘制/","text":"上篇文章我们了解了canvas的定义、获取和基础的绘图操作，其中的绘图功能我们讲解了线段绘制、上色、描边等方面知识点。 今天我们来讲讲矩形（Rectangle）和多边形的绘制。 矩形的绘制一共有两个口令，分别是 ctx.fillRect(x, y, width, height) 和 ctx.strokeRect(x, y, width, height) ，参数中的 x 和 y 依旧表示需绘制的矩形的起始点坐标（相对canvas原点），width 和 height表示需绘制的矩形宽高。而 fillRect 表示绘制一个实心矩形，strokeRect 表示绘制一个描边矩形，我们来一个简单的例子：12345678910&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.fillRect(10,10,50,50); //从画布上的(10,10)坐标点为起始点，绘制一个宽高均为50px的实心矩形ctx.strokeRect(70,10,50,50); //从画布上的(70,10)坐标点为起始点，绘制一个宽高均为50px的描边矩形&lt;/script&gt; 效果如下 你也可以使用 Rect( x, y, width, height ) 的方法创建矩形路径，之后再通过 .stroke() 或 .fill() 方法来给矩形上色： 1234567var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.rect(20,20,150,100); //创建矩形路径ctx.stroke(); //描边ctx.beginPath(); //重置画笔，避免污染ctx.rect(50,90,50,50); //创建矩形路径ctx.fill(); //填充 效果如下 上方我们绘制了两个默认黑色的实心和描边矩形，相信你也联想到上一章我们绘制线段时，若没有定义strokeStyle，则线段也是默认为黑色的事情。那么我们要给这俩矩形上色，或许你也会联想到应当使用 *Style 来处理，而这想法也是正确的。 在canvas上，给实心对象上色可以用 fillStyle 来定义，给描边对象上色我们可以用 strokeStyle来定义，它们的赋值均为 color|gradient|pattern ，在上章我们已经细说过，这里不再赘述。 那么我们来给上方绘制了的实心矩形填充一个放射状渐变（黄-蓝-红），将描边矩形的描边设为绿色。我们可以这样做： 12345678910111213141516171819&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象var grd = ctx.createRadialGradient(35,35,0,35,35,36); //定义放射状渐变对象，设定渐变线起始点和结束点坐标，坐标格式为(起始点x,起始点y,结束点x,结束点y)grd.addColorStop(0,&quot;yellow&quot;); //定义渐变线起点颜色grd.addColorStop(0.5,&quot;blue&quot;); //定义渐变线中间点的颜色grd.addColorStop(1,&quot;red&quot;); //定义渐变线结束点的颜色ctx.fillStyle = grd; //将放射状渐变对象赋值给fillStylectx.fillRect(10,10,50,50); //从画布上的(10,10)坐标点为起始点，绘制一个宽高均为50px的实心矩形ctx.beginPath(); //重置画笔，这是个好习惯ctx.strokeStyle = &quot;green&quot;; //定义描边颜色为绿色ctx.strokeRect(70,10,50,50); //从画布上的(70,10)坐标点为起始点，绘制一个宽高均为50px的描边矩形&lt;/script&gt; 效果如下 这里要提到的是上一次没有仔细介绍过的放射状渐变方法 createRadialGradient ，其语法为 ctx.createRadialGradient( Xstart, Ystart, Radiusstart, Xend, Yend, Radiusend ) 其中前三个参数表示渐变起始圆形的中心坐标和半径，后三个参数表示渐变结束圆形的中点坐标和半径。 或许你会被这里的“半径”迷惑，回顾我们上章学习的createLinearGradient，它的参数并没有“半径”的概念，如果你是一名平面设计师，你更可能觉得放射状渐变只需要起始点和结束点坐标就可以了（毕竟PS/AI中的径向渐变只需要这两个点）。 但canvas在这里加入的“半径”参数还是有一定作用的，可以创造出比PS中径向渐变稍微复杂一些的效果。 ⑴ 我们先来一个最简单最好理解的例子：123456789var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象var grd = ctx.createRadialGradient(70,70,0,70,70,100); //定义放射状渐变对象，设定起始圆和结束圆中点重叠，且起始圆半径为0grd.addColorStop(0,&quot;yellow&quot;); //定义渐变线起点颜色grd.addColorStop(0.5,&quot;blue&quot;); //定义渐变线中间点的颜色grd.addColorStop(1,&quot;rgba(255,0,0,0)&quot;); //定义渐变线结束点的颜色，其中颜色透明度为0ctx.fillStyle = grd; //将放射状渐变对象赋值给fillStylectx.fillRect(0,0,c.width,c.height); //绘制一个跟画布大小一样的实心矩形 我们设置起始圆和结束圆中点相同，且起始圆半径为0，那么它的渐变线就是从两圆的中点开始到结束圆的边缘结束。我们设置渐变线结束点颜色透明度为0是为了方便查看结束圆的边界。效果如下： ⑵ 我们在⑴的基础上将起始圆的半径设为20，代码和效果图如下：123456789var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象var grd = ctx.createRadialGradient(70,70,20,70,70,100); //定义放射状渐变对象，设定起始圆和结束圆中点重叠，且起始圆半径为20grd.addColorStop(0,&quot;yellow&quot;); grd.addColorStop(0.5,&quot;blue&quot;); grd.addColorStop(1,&quot;rgba(255,0,0,0)&quot;); ctx.fillStyle = grd; ctx.fillRect(0,0,c.width,c.height); ⑶ 我们在⑵的基础上挪动起始圆的中点，不要让它跟结束圆的中点重叠，代码和效果图如下： 123456789var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象var grd = ctx.createRadialGradient(60,40,20,70,70,100); //起始圆不仅有半径，而且中点跟结束圆中点不相同grd.addColorStop(0,&quot;yellow&quot;); grd.addColorStop(0.5,&quot;blue&quot;); grd.addColorStop(1,&quot;rgba(255,0,0,0)&quot;); ctx.fillStyle = grd; ctx.fillRect(0,0,c.width,c.height); 注意我们在定义RadialGradient时，要尽量避免起始圆的范围超出结束圆的范围（起始圆最好是结束圆内部的一个真子集），否则绘制出来的效果会出现无法预知的错误，例如下面的代码：123456789var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象var grd = ctx.createRadialGradient(60,60,50,70,70,50); //起始圆的左边超出了结束圆内部区域grd.addColorStop(0,&quot;yellow&quot;); grd.addColorStop(0.5,&quot;blue&quot;); grd.addColorStop(1,&quot;rgba(255,0,0,0)&quot;); ctx.fillStyle = grd; ctx.fillRect(0,0,c.width,c.height); 不过如果你掌握了RadialGradient上色原理，倒是可以随意定位起始圆和结束圆的方位和大小。我从TimeLangoliers的博客（点击查看出处）看到这张原理图：他还依照此原理图写了一个例子：12345678910var canvas = document.getElementById(id); if (canvas == null) return false; var context = canvas.getContext(&apos;2d&apos;); var g1 = context.createRadialGradient(100, 150, 10, 300, 150, 50); g1.addColorStop(0.1, &apos;rgb(255,0,0)&apos;); g1.addColorStop(0.5, &apos;rgb(0,255,0)&apos;); g1.addColorStop(1, &apos;rgb(0,0,255)&apos;); context.fillStyle = g1; context.fillRect(0, 0, 400, 300); 至此我们学习了通过 fillRect 和 strokeRect 来绘制矩形，下面再讲一个Rect相关的功能——clearRect。 clearRect类似PS中的方块橡皮擦，可以擦除画布上任意一块矩形区域的内容，其语法如下： ctx.clearRect( x, y, width, height ); 其中 x 和 y 表示起始点坐标，width 和 height 表示这块“橡皮擦”的宽高。举个例子：123456789var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.fillStyle = &quot;red&quot;; ctx.fillRect(0,0,c.width,c.height); ctx.beginPath();ctx.fillStyle = &quot;blue&quot;; ctx.fillRect(10,20,60,60); ctx.clearRect(20,20,80,50); //擦除以（20,20）坐标为起点，宽高为80*50的区域 注意clearRect不会清除掉之前定义过的样式、画笔位置等绘制信息，打个比方，有时候我们需要清空整个画布，我们可以这样做：12345678910var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.fillStyle = &quot;blue&quot;; ctx.fillRect(10,20,60,60); //下面重置画布大小，从而清空画布c.width = c.width; //在jQ中可以写为 c.attr(&quot;width&quot;, c.width()); c.height = c.height; //在jQ中可以写为 c.attr(&quot;height&quot;, c.height()); //重新绘制一个矩形ctx.fillRect(10,20,60,60); 这个方法是通过重置画布大小，从而触发清空画布事件，但前面定义的 fillStyle=”blue” 也被清空掉了，从而绘制了一个黑色的矩形： 如果不想清除掉之前定义的样式，我们可以通过clearRect来实现：123456789var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.fillStyle = &quot;blue&quot;; ctx.fillRect(10,20,60,60); //下面通过clearRect来擦除画布ctx.clearRect(0,0,c.width,c.height);//重新绘制一个矩形ctx.fillRect(10,20,60,60); 执行结果如下： 最后聊一下多边形的绘制，其实现非常简单，先来个例子：123456789101112131415161718var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象//定义样式ctx.fillStyle = &quot;blue&quot;; ctx.strokeStyle = &quot;red&quot;;ctx.lineWidth = &quot;8&quot;;ctx.lineJoin = &quot;round&quot;;//绘制多边形ctx.moveTo(10,10);ctx.lineTo(100,30);ctx.lineTo(120,80);ctx.lineTo(60,60);ctx.lineTo(10,10);ctx.stroke(); //描边ctx.fill(); //填充 可见我们这里通过lineTo绘制了多边形的每条边（注意起点跟终点是同一个坐标），然后通过 stroke() 来描边、fill() 来填充，其执行效果如下： 眼尖的朋友会发现该多边形左上角的俩条描边没有接在一起，这是因为我们没有把这个多边形路径闭合起来，我们可以通过 ctx.closePath() 来解决这个问题： 眼尖的朋友会发现该多边形左上角的俩条描边没有接在一起，这是因为我们没有把这个多边形路径闭合起来，我们可以通过 ctx.closePath() 来解决这个问题：123456789101112131415161718var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象//定义样式ctx.fillStyle = &quot;blue&quot;; ctx.strokeStyle = &quot;red&quot;;ctx.lineWidth = &quot;8&quot;;ctx.lineJoin = &quot;round&quot;;//绘制多边形ctx.moveTo(10,10);ctx.lineTo(100,30);ctx.lineTo(120,80);ctx.lineTo(60,60);ctx.lineTo(10,10);ctx.closePath(); //闭合多边形路径ctx.stroke(); //描边ctx.fill(); //填充 这次就到这里，下次再见了！、 学习链接 canvas学习笔记HTML5- Canvas入门（二）玩转html5画图","tags":[{"name":"html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"HTML5-Canvas之矩阵和多边形的绘制（2）","date":"2016-12-25T09:50:33.000Z","path":"2016/12/25/关于eslint使用规则，和各种报错对应规则/","text":"在用vue2.0写项目时，由于vue-cli脚 架自动带了带了代码规范监测，稍微不小心就会出现一些Warning,这时就需要，根据自己习惯的代码规范，用一下代码进行对Eslint规范的一些忽略。下面详细介绍一下： ESLint 由 JavaScript 红宝书 作者 Nicholas C. Zakas 编写， 2013 年发布第一个版本。 NCZ 的初衷不是重复造一个轮子，而是在实际需求得不到 JSHint 团队响应 的情况下做出的选择：以可扩展、每条规则独立、不内置编码风格为理念编写一个 lint 工具。ESLint 主要有以下特点： 默认规则包含所有 JSLint、JSHint 中存在的规则，易迁移； 规则可配置性高：可设置「警告」、「错误」两个 error 等级，或者直接禁用； 包含代码风格检测的规则（可以丢掉 JSCS 了）； 支持插件扩展、自定义规则。 下面说一下如何配置：比如，我写vue过程中，出现了下面的warning:12WARNING Compiled with 1 warnings11:26:30http://eslint.org/docs/rules/quotes Strings must use singlequote 警告的意思就是字符串必须用单引号如下图：这时候，你就可以在.eslintrc.js配置你的规则rule&quot;quotes&quot;: [1, &quot;single&quot;],//引号类型 `` &quot;&quot; &#39;&#39; Use / eslint-disable / to ignore all warnings in a file.还有一种万能方法，就是在报错的JS文件中第一行写上/* eslint-disable */ 如下图这样就可以和Eslint携手并进了 配置（我主要用第三种方法,为了方便查看，特记录如下：）可以通过以下三种方式配置 ESLint: 使用 .eslintrc 文件（支持 JSON 和 YAML 两种语法）； 在 package.json 中添加 eslintConfig 配置块；直接在代码文件中定义。 以下是.eslintrc 文件示例和解释：为了方便查看，特记录如下,需要用的规则，到时候直接搜索就可以了，简直开心极了：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298&#123; &quot;env&quot;: &#123; &quot;browser&quot;: true, &quot;node&quot;: true, &quot;commonjs&quot;: true &#125;, &quot;ecmaFeatures&quot;: &#123; // lambda表达式 &quot;arrowFunctions&quot;: true, // 解构赋值 &quot;destructuring&quot;: true, // class &quot;classes&quot;: true, // http://es6.ruanyifeng.com/#docs/function#函数参数的默认值 &quot;defaultParams&quot;: true, // 块级作用域，允许使用let const &quot;blockBindings&quot;: true, // 允许使用模块，模块内默认严格模式 &quot;modules&quot;: true, // 允许字面量定义对象时，用表达式做属性名 // http://es6.ruanyifeng.com/#docs/object#属性名表达式 &quot;objectLiteralComputedProperties&quot;: true, // 允许对象字面量方法名简写 /*var o = &#123; method() &#123; return &quot;Hello!&quot;; &#125; &#125;; 等同于 var o = &#123; method: function() &#123; return &quot;Hello!&quot;; &#125; &#125;; */ &quot;objectLiteralShorthandMethods&quot;: true, /* 对象字面量属性名简写 var foo = &apos;bar&apos;; var baz = &#123;foo&#125;; baz // &#123;foo: &quot;bar&quot;&#125; // 等同于 var baz = &#123;foo: foo&#125;; */ &quot;objectLiteralShorthandProperties&quot;: true, // http://es6.ruanyifeng.com/#docs/function#rest参数 &quot;restParams&quot;: true, // http://es6.ruanyifeng.com/#docs/function#扩展运算符 &quot;spread&quot;: true, // http://es6.ruanyifeng.com/#docs/iterator#for---of循环 &quot;forOf&quot;: true, // http://es6.ruanyifeng.com/#docs/generator &quot;generators&quot;: true, // http://es6.ruanyifeng.com/#docs/string#模板字符串 &quot;templateStrings&quot;: true, &quot;superInFunctions&quot;: true, // http://es6.ruanyifeng.com/#docs/object#对象的扩展运算符 &quot;experimentalObjectRestSpread&quot;: true &#125;, &quot;rules&quot;: &#123; // 定义对象的set存取器属性时，强制定义get &quot;accessor-pairs&quot;: 2, // 指定数组的元素之间要以空格隔开(,后面)， never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格 &quot;array-bracket-spacing&quot;: [2, &quot;never&quot;], // 在块级作用域外访问块内定义的变量是否报错提示 &quot;block-scoped-var&quot;: 0, // if while function 后面的&#123;必须与if在同一行，java风格。 &quot;brace-style&quot;: [2, &quot;1tbs&quot;, &#123; &quot;allowSingleLine&quot;: true &#125;], // 双峰驼命名格式 &quot;camelcase&quot;: 2, // 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗号， // always-multiline：多行模式必须带逗号，单行模式不能带逗号 &quot;comma-dangle&quot;: [2, &quot;never&quot;], // 控制逗号前后的空格 &quot;comma-spacing&quot;: [2, &#123; &quot;before&quot;: false, &quot;after&quot;: true &#125;], // 控制逗号在行尾出现还是在行首出现 // http://eslint.org/docs/rules/comma-style &quot;comma-style&quot;: [2, &quot;last&quot;], // 圈复杂度 &quot;complexity&quot;: [2,9], // 以方括号取对象属性时，[ 后面和 ] 前面是否需要空格, 可选参数 never, always &quot;computed-property-spacing&quot;: [2,&quot;never&quot;], // 强制方法必须返回值，TypeScript强类型，不配置 &quot;consistent-return&quot;: 0, // 用于指统一在回调函数中指向this的变量名，箭头函数中的this已经可以指向外层调用者，应该没卵用了 // e.g [0,&quot;that&quot;] 指定只能 var that = this. that不能指向其他任何值，this也不能赋值给that以外的其他值 &quot;consistent-this&quot;: 0, // 强制在子类构造函数中用super()调用父类构造函数，TypeScrip的编译器也会提示 &quot;constructor-super&quot;: 0, // if else while for do后面的代码块是否需要&#123; &#125;包围，参数： // multi 只有块中有多行语句时才需要&#123; &#125;包围 // multi-line 只有块中有多行语句时才需要&#123; &#125;包围, 但是块中的执行语句只有一行时， // 块中的语句只能跟和if语句在同一行。if (foo) foo++; else doSomething(); // multi-or-nest 只有块中有多行语句时才需要&#123; &#125;包围, 如果块中的执行语句只有一行，执行语句可以零另起一行也可以跟在if语句后面 // [2, &quot;multi&quot;, &quot;consistent&quot;] 保持前后语句的&#123; &#125;一致 // default: [2, &quot;all&quot;] 全都需要&#123; &#125;包围 &quot;curly&quot;: [2, &quot;all&quot;], // switch语句强制default分支，也可添加 // no default 注释取消此次警告 &quot;default-case&quot;: 2, // 强制object.key 中 . 的位置，参数: // property，&apos;.&apos;号应与属性在同一行 // object, &apos;.&apos; 号应与对象名在同一行 &quot;dot-location&quot;: [2, &quot;property&quot;], // 强制使用.号取属性 // 参数： allowKeywords：true 使用保留字做属性名时，只能使用.方式取属性 // false 使用保留字做属性名时, 只能使用[]方式取属性 e.g [2, &#123;&quot;allowKeywords&quot;: false&#125;] // allowPattern: 当属性名匹配提供的正则表达式时，允许使用[]方式取值,否则只能用.号取值 e.g [2, &#123;&quot;allowPattern&quot;: &quot;^[a-z]+(_[a-z]+)+$&quot;&#125;] &quot;dot-notation&quot;: [2, &#123;&quot;allowKeywords&quot;: true&#125;], // 文件末尾强制换行 &quot;eol-last&quot;: 2, // 使用 === 替代 == &quot;eqeqeq&quot;: [2, &quot;allow-null&quot;], // 方法表达式是否需要命名 &quot;func-names&quot;: 0, // 方法定义风格，参数： // declaration: 强制使用方法声明的方式，function f()&#123;&#125; e.g [2, &quot;declaration&quot;] // expression：强制使用方法表达式的方式，var f = function() &#123;&#125; e.g [2, &quot;expression&quot;] // allowArrowFunctions: declaration风格中允许箭头函数。 e.g [2, &quot;declaration&quot;, &#123; &quot;allowArrowFunctions&quot;: true &#125;] &quot;func-style&quot;: 0, &quot;no-alert&quot;: 0,//禁止使用alert confirm prompt&quot;no-array-constructor&quot;: 2,//禁止使用数组构造器&quot;no-bitwise&quot;: 0,//禁止使用按位运算符&quot;no-caller&quot;: 1,//禁止使用arguments.caller或arguments.callee&quot;no-catch-shadow&quot;: 2,//禁止catch子句参数与外部作用域变量同名&quot;no-class-assign&quot;: 2,//禁止给类赋值&quot;no-cond-assign&quot;: 2,//禁止在条件表达式中使用赋值语句&quot;no-console&quot;: 2,//禁止使用console&quot;no-const-assign&quot;: 2,//禁止修改const声明的变量&quot;no-constant-condition&quot;: 2,//禁止在条件中使用常量表达式 if(true) if(1)&quot;no-continue&quot;: 0,//禁止使用continue&quot;no-control-regex&quot;: 2,//禁止在正则表达式中使用控制字符&quot;no-debugger&quot;: 2,//禁止使用debugger&quot;no-delete-var&quot;: 2,//不能对var声明的变量使用delete操作符&quot;no-div-regex&quot;: 1,//不能使用看起来像除法的正则表达式/=foo/&quot;no-dupe-keys&quot;: 2,//在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125;&quot;no-dupe-args&quot;: 2,//函数参数不能重复&quot;no-duplicate-case&quot;: 2,//switch中的case标签不能重复&quot;no-else-return&quot;: 2,//如果if语句里面有return,后面不能跟else语句&quot;no-empty&quot;: 2,//块语句中的内容不能为空&quot;no-empty-character-class&quot;: 2,//正则表达式中的[]内容不能为空&quot;no-empty-label&quot;: 2,//禁止使用空label&quot;no-eq-null&quot;: 2,//禁止对null使用==或!=运算符&quot;no-eval&quot;: 1,//禁止使用eval&quot;no-ex-assign&quot;: 2,//禁止给catch语句中的异常参数赋值&quot;no-extend-native&quot;: 2,//禁止扩展native对象&quot;no-extra-bind&quot;: 2,//禁止不必要的函数绑定&quot;no-extra-boolean-cast&quot;: 2,//禁止不必要的bool转换&quot;no-extra-parens&quot;: 2,//禁止非必要的括号&quot;no-extra-semi&quot;: 2,//禁止多余的冒号&quot;no-fallthrough&quot;: 1,//禁止switch穿透&quot;no-floating-decimal&quot;: 2,//禁止省略浮点数中的0 .5 3.&quot;no-func-assign&quot;: 2,//禁止重复的函数声明&quot;no-implicit-coercion&quot;: 1,//禁止隐式转换&quot;no-implied-eval&quot;: 2,//禁止使用隐式eval&quot;no-inline-comments&quot;: 0,//禁止行内备注&quot;no-inner-declarations&quot;: [2, &quot;functions&quot;],//禁止在块语句中使用声明（变量或函数）&quot;no-invalid-regexp&quot;: 2,//禁止无效的正则表达式&quot;no-invalid-this&quot;: 2,//禁止无效的this，只能用在构造器，类，对象字面量&quot;no-irregular-whitespace&quot;: 2,//不能有不规则的空格&quot;no-iterator&quot;: 2,//禁止使用__iterator__ 属性&quot;no-label-var&quot;: 2,//label名不能与var声明的变量名相同&quot;no-labels&quot;: 2,//禁止标签声明&quot;no-lone-blocks&quot;: 2,//禁止不必要的嵌套块&quot;no-lonely-if&quot;: 2,//禁止else语句内只有if语句&quot;no-loop-func&quot;: 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）&quot;no-mixed-requires&quot;: [0, false],//声明时不能混用声明类型&quot;no-mixed-spaces-and-tabs&quot;: [2, false],//禁止混用tab和空格&quot;linebreak-style&quot;: [0, &quot;windows&quot;],//换行风格&quot;no-multi-spaces&quot;: 1,//不能用多余的空格&quot;no-multi-str&quot;: 2,//字符串不能用\\换行&quot;no-multiple-empty-lines&quot;: [1, &#123;&quot;max&quot;: 2&#125;],//空行最多不能超过2行&quot;no-native-reassign&quot;: 2,//不能重写native对象&quot;no-negated-in-lhs&quot;: 2,//in 操作符的左边不能有!&quot;no-nested-ternary&quot;: 0,//禁止使用嵌套的三目运算&quot;no-new&quot;: 1,//禁止在使用new构造一个实例后不赋值&quot;no-new-func&quot;: 1,//禁止使用new Function&quot;no-new-object&quot;: 2,//禁止使用new Object()&quot;no-new-require&quot;: 2,//禁止使用new require&quot;no-new-wrappers&quot;: 2,//禁止使用new创建包装实例，new String new Boolean new Number&quot;no-obj-calls&quot;: 2,//不能调用内置的全局对象，比如Math() JSON()&quot;no-octal&quot;: 2,//禁止使用八进制数字&quot;no-octal-escape&quot;: 2,//禁止使用八进制转义序列&quot;no-param-reassign&quot;: 2,//禁止给参数重新赋值&quot;no-path-concat&quot;: 0,//node中不能使用__dirname或__filename做路径拼接&quot;no-plusplus&quot;: 0,//禁止使用++，--&quot;no-process-env&quot;: 0,//禁止使用process.env&quot;no-process-exit&quot;: 0,//禁止使用process.exit()&quot;no-proto&quot;: 2,//禁止使用__proto__属性&quot;no-redeclare&quot;: 2,//禁止重复声明变量&quot;no-regex-spaces&quot;: 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/&quot;no-restricted-modules&quot;: 0,//如果禁用了指定模块，使用就会报错&quot;no-return-assign&quot;: 1,//return 语句中不能有赋值表达式&quot;no-script-url&quot;: 0,//禁止使用javascript:void(0)&quot;no-self-compare&quot;: 2,//不能比较自身&quot;no-sequences&quot;: 0,//禁止使用逗号运算符&quot;no-shadow&quot;: 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名&quot;no-shadow-restricted-names&quot;: 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用&quot;no-spaced-func&quot;: 2,//函数调用时 函数名与()之间不能有空格&quot;no-sparse-arrays&quot;: 2,//禁止稀疏数组， [1,,2]&quot;no-sync&quot;: 0,//nodejs 禁止同步方法&quot;no-ternary&quot;: 0,//禁止使用三目运算符&quot;no-trailing-spaces&quot;: 1,//一行结束后面不要有空格&quot;no-this-before-super&quot;: 0,//在调用super()之前不能使用this或super&quot;no-throw-literal&quot;: 2,//禁止抛出字面量错误 throw &quot;error&quot;;&quot;no-undef&quot;: 1,//不能有未定义的变量&quot;no-undef-init&quot;: 2,//变量初始化时不能直接给它赋值为undefined&quot;no-undefined&quot;: 2,//不能使用undefined&quot;no-unexpected-multiline&quot;: 2,//避免多行表达式&quot;no-underscore-dangle&quot;: 1,//标识符不能以_开头或结尾&quot;no-unneeded-ternary&quot;: 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;&quot;no-unreachable&quot;: 2,//不能有无法执行的代码&quot;no-unused-expressions&quot;: 2,//禁止无用的表达式&quot;no-unused-vars&quot;: [2, &#123;&quot;vars&quot;: &quot;all&quot;, &quot;args&quot;: &quot;after-used&quot;&#125;],//不能有声明后未被使用的变量或参数&quot;no-use-before-define&quot;: 2,//未定义前不能使用&quot;no-useless-call&quot;: 2,//禁止不必要的call和apply&quot;no-void&quot;: 2,//禁用void操作符&quot;no-var&quot;: 0,//禁用var，用let和const代替&quot;no-warning-comments&quot;: [1, &#123; &quot;terms&quot;: [&quot;todo&quot;, &quot;fixme&quot;, &quot;xxx&quot;], &quot;location&quot;: &quot;start&quot; &#125;],//不能有警告备注&quot;no-with&quot;: 2,//禁用with&quot;array-bracket-spacing&quot;: [2, &quot;never&quot;],//是否允许非空数组里面有多余的空格&quot;arrow-parens&quot;: 0,//箭头函数用小括号括起来&quot;arrow-spacing&quot;: 0,//=&gt;的前/后括号&quot;accessor-pairs&quot;: 0,//在对象中使用getter/setter&quot;block-scoped-var&quot;: 0,//块语句中使用var&quot;brace-style&quot;: [1, &quot;1tbs&quot;],//大括号风格&quot;callback-return&quot;: 1,//避免多次调用回调什么的&quot;camelcase&quot;: 2,//强制驼峰法命名&quot;comma-dangle&quot;: [2, &quot;never&quot;],//对象字面量项尾不能有逗号&quot;comma-spacing&quot;: 0,//逗号前后的空格&quot;comma-style&quot;: [2, &quot;last&quot;],//逗号风格，换行时在行首还是行尾&quot;complexity&quot;: [0, 11],//循环复杂度&quot;computed-property-spacing&quot;: [0, &quot;never&quot;],//是否允许计算后的键名什么的&quot;consistent-return&quot;: 0,//return 后面是否允许省略&quot;consistent-this&quot;: [2, &quot;that&quot;],//this别名&quot;constructor-super&quot;: 0,//非派生类不能调用super，派生类必须调用super&quot;curly&quot;: [2, &quot;all&quot;],//必须使用 if()&#123;&#125; 中的&#123;&#125;&quot;default-case&quot;: 2,//switch语句最后必须有default&quot;dot-location&quot;: 0,//对象访问符的位置，换行的时候在行首还是行尾&quot;dot-notation&quot;: [0, &#123; &quot;allowKeywords&quot;: true &#125;],//避免不必要的方括号&quot;eol-last&quot;: 0,//文件以单一的换行符结束&quot;eqeqeq&quot;: 2,//必须使用全等&quot;func-names&quot;: 0,//函数表达式必须有名字&quot;func-style&quot;: [0, &quot;declaration&quot;],//函数风格，规定只能使用函数声明/函数表达式&quot;generator-star-spacing&quot;: 0,//生成器函数*的前后空格&quot;guard-for-in&quot;: 0,//for in循环要用if语句过滤&quot;handle-callback-err&quot;: 0,//nodejs 处理错误&quot;id-length&quot;: 0,//变量名长度&quot;indent&quot;: [2, 4],//缩进风格&quot;init-declarations&quot;: 0,//声明时必须赋初值&quot;key-spacing&quot;: [0, &#123; &quot;beforeColon&quot;: false, &quot;afterColon&quot;: true &#125;],//对象字面量中冒号的前后空格&quot;lines-around-comment&quot;: 0,//行前/行后备注&quot;max-depth&quot;: [0, 4],//嵌套块深度&quot;max-len&quot;: [0, 80, 4],//字符串最大长度&quot;max-nested-callbacks&quot;: [0, 2],//回调嵌套深度&quot;max-params&quot;: [0, 3],//函数最多只能有3个参数&quot;max-statements&quot;: [0, 10],//函数内最多有几个声明&quot;new-cap&quot;: 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用&quot;new-parens&quot;: 2,//new时必须加小括号&quot;newline-after-var&quot;: 2,//变量声明后是否需要空一行&quot;object-curly-spacing&quot;: [0, &quot;never&quot;],//大括号内是否允许不必要的空格&quot;object-shorthand&quot;: 0,//强制对象字面量缩写语法&quot;one-var&quot;: 1,//连续声明&quot;operator-assignment&quot;: [0, &quot;always&quot;],//赋值运算符 += -=什么的&quot;operator-linebreak&quot;: [2, &quot;after&quot;],//换行时运算符在行尾还是行首&quot;padded-blocks&quot;: 0,//块语句内行首行尾是否要空行&quot;prefer-const&quot;: 0,//首选const&quot;prefer-spread&quot;: 0,//首选展开运算&quot;prefer-reflect&quot;: 0,//首选Reflect的方法&quot;quotes&quot;: [1, &quot;single&quot;],//引号类型 `` &quot;&quot; &apos;&apos;&quot;quote-props&quot;:[2, &quot;always&quot;],//对象字面量中的属性名是否强制双引号&quot;radix&quot;: 2,//parseInt必须指定第二个参数&quot;id-match&quot;: 0,//命名检测&quot;require-yield&quot;: 0,//生成器函数必须有yield&quot;semi&quot;: [2, &quot;always&quot;],//语句强制分号结尾&quot;semi-spacing&quot;: [0, &#123;&quot;before&quot;: false, &quot;after&quot;: true&#125;],//分号前后空格&quot;sort-vars&quot;: 0,//变量声明时排序&quot;space-after-keywords&quot;: [0, &quot;always&quot;],//关键字后面是否要空一格&quot;space-before-blocks&quot;: [0, &quot;always&quot;],//不以新行开始的块&#123;前面要不要有空格&quot;space-before-function-paren&quot;: [0, &quot;always&quot;],//函数定义时括号前面要不要有空格&quot;space-in-parens&quot;: [0, &quot;never&quot;],//小括号里面要不要有空格&quot;space-infix-ops&quot;: 0,//中缀操作符周围要不要有空格&quot;space-return-throw-case&quot;: 2,//return throw case后面要不要加空格&quot;space-unary-ops&quot;: [0, &#123; &quot;words&quot;: true, &quot;nonwords&quot;: false &#125;],//一元运算符的前/后要不要加空格&quot;spaced-comment&quot;: 0,//注释风格不要有空格什么的&quot;strict&quot;: 2,//使用严格模式&quot;use-isnan&quot;: 2,//禁止比较时使用NaN，只能用isNaN()&quot;valid-jsdoc&quot;: 0,//jsdoc规则&quot;valid-typeof&quot;: 2,//必须使用合法的typeof的值&quot;vars-on-top&quot;: 2,//var必须放在作用域顶部&quot;wrap-iife&quot;: [2, &quot;inside&quot;],//立即执行函数表达式的小括号风格&quot;wrap-regex&quot;: 0,//正则表达式字面量用小括号包起来&quot;yoda&quot;: [2, &quot;never&quot;]//禁止尤达条件 &#125; &#125; 参考文章：ESLint配置参数介绍关于eslint使用规则，和各种报错应对书写规则。*","tags":[{"name":"html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"HTML5-Canvas之矩阵和多边形的绘制（2）","date":"2016-12-25T09:50:33.000Z","path":"2016/12/25/MySQL在windows下的安装与配置（小白操作图文新）/","text":"MySQL安装官网版本： https://dev.mysql.com/downloads/mysql/5.6.html#downloads 有msi和zip两种下载形式，推荐下载msi这种形式，安装简单我下载的是mysql-5.5.44-winx64.msi 如下图，自己可随意选择对应版本 安装过程注意几点： 安装类型选择Typical-典型安装 安装最后，会有个复选框，询问是否进行MySQL配置操作，可以先不配置，因为等额下我们自己可以进行额外的配置。结果和它是一样的，只需单击finish按钮，如下图 MySQL配置接下来，我们就要进行配置，那么我们要到那个地方进行配置呢？ 首先，我们要找到，配置向导文件，然后点击进入一般情况下，典型安装都是讲文件安装在C:\\Program Files\\MySQL\\MySQL Server 5.5\\bin， 选择配置类型详细配置对于初学者配置特别多，难以掌握，最好选择标准配置，点击Next按钮 是否安装windows服务之后询问是否安装windows服务和配置环境变量，一般情况下是都要勾选的 设置root用户和密码 准备执行设置选项觉得哪一步需要修改，可以back回去修改，各方面确认好之后，就可以点击Execute按钮 配置完成 上图中，第二个选项Write configuration file，写入配置文件，存储在安装目录下my.ini第三个选项，Start Service，当前启动你的服务，因为刚才已经设置为windows的一个服务 下面验证一下 配置文件my.ini存不存在, windows服务中是否存在MySQL的一个服务 右键点击“我的电脑”，在弹出的快捷菜单中选择“管理”，打开“计算机管理” 可以看到MySQL服务已启动 到此为止，我们已经完成了最简单的配置,如果要进行其他的配置，我们就需要了解MySQL目录结构了， 下图就很好地表示各目录的功能： 除了通过配置向导的图形化界面来配置，我们还可以来修改配置文件来实现 标准配置当中没有的编码方式配置文件在哪呢？ 就是我们刚才提到的bin文件夹下的my.ini 在my.ini文件中，我们发现有几个选项比较重要： client–指的MySQL客户端 port–指的MySQL的端口号（默认3306） default-character-set默认编码方式（默认的是latin1，要修改为utf8，不是utf-8哈） mysqld主要是进行MySQL服务器端的配置 注意修改了MLSQL的配置，要进行重新启动才行 启动关闭MySQL服务 运行cmd，输入net stop mysql(其实在服务列表中，所有的服务都可以通过net stop XX来停止) 运行cmd，输入net start mysql(其实在服务列表中，所有的服务都可以通过net start XX来启动)如下图 关于cmd界面无法启动mysql： 必须要使用管理员身份运行cmd程序 如果下载MySQL5.7版本的，在windows服务上Mysql的名字默认是MySQL57，因此在cmd运行 net start/stop mysql 是无效的，必须改成 net start/stop mysql57才行 或者 在dos下运行net start mysql 不能启动mysql！提示发生系统错误 5；拒绝访问！切换到管理员模式就可以启动了。所以我们要以管理员身份来运行cmd程序来启动mysql。 那么如何用管理员身份来运行cmd程序呢？ 1.在开始菜单的搜索框张收入cmd，然后右键单击，并选择以管理员身份运行！ 如果每天都要启动mysql服务，这样不很麻烦？所以： 2.右键单击cmd选择“附到【开始】菜单(U)”;这是就可以到开始菜单上找到cmd了， 3.右击选择属性，选择快捷方式，选择高级，选择以管理员身份运行，单击确定 这样再输入net start mysql就不会出错了！ 这样修改配置就成功了","tags":[{"name":"html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"HTML5-Canvas初探（1）","date":"2016-12-18T09:50:33.000Z","path":"2016/12/18/HTML5-Canvas初探/","text":"canvas其实没有那么玄乎，它不外乎是一个H5的标签，跟其它HTML标签如出一辙：1&lt;canvas&gt;&lt;/canvas&gt; canvas 元素用于在网页上绘制图形。 那么什么是 Canvas？ HTML5 的 canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，您可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 canvas本身没有任何的绘图能力，所有的绘图工作都是通过js来实现的。通常我们在js通过getElementById来获取要操作的canvas（这意味着咱得给canvas设个id）：123456&lt;canvas id=&quot;myCanvas&quot;&gt;&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;); //获取要操作的canvas//操作canvas的代码...&lt;/script&gt; 注意最好在一开始的时候就给canvas设置好其宽高（若不设定宽高，浏览器会默认设置canvas大小为宽300、高100像素），而且不能使用css来设置（会被拉伸），建议直接写于canvas标签内部： &lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt; 也可以在js脚本中设置： 1234567&lt;canvas id=&quot;myCanvas&quot;&gt;&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);c.width=200;c.height=200;&lt;/script&gt; 为什么不能用css来设置呢？这是因为 canvas 元素有元素本身大小与元素绘图表面大小两套尺寸。 设置 width 和 height 时，实际上是同时修改了该元素本身大小和元素绘图表面大小； 而设置 css，只会改变元素本身大小，并不会改变元素绘图表面大小。 关于canvas大小需要知道的一点是，后续咱们对canvas所做的全部绘图操作，超出此大小范围的部分是不可见的。顾名思义，可以把canvas看成一块画布，其大小是咱设定好的宽高，那么无论你怎么画，画布外的地方自然是画不到的。 对于有些浏览器是不支持canvas功能的，我们可以直接在canvas标签中写一些替换内容，在浏览器不支持canvas时显示：123&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt; 接着在聊如何在canvas上绘图前，咱得先说说.getContext(“2d”)这东西。.getContext() 是canvas的绘图对象/方法，要让canvas执行绘图工作必须先获取canvas的.getContext()对象来执行。 .getContext()只接受一个参数，该参数用于获取canvas的绘图环境，例如.getContext(“2d”)表示该canvas的绘图环境为2D平面（可以绘制文本、直线、弧线、矩形、圆形等）。当前H5只支持2D环境，在不久的将来会开放3D绘图功能。（故咱可将“getContext”翻译为“获取绘图环境”） 接下来：主要是对canvas线段绘制功能的介绍理论不多说，我们先来个小例子，从最简单的绘制直线开始： 1234567891011&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:solid 1px #CCC;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.moveTo(10,10); //定义绘画开始的位置ctx.lineTo(150,50); //画一条直线，结束点坐标是x=150,y=50ctx.stroke(); //描边&lt;/script&gt; 效果如下：在这里我们使用了3个getContext(“2d”)对象的绘图方法： .moveTo(x坐标 , y坐标) 可以理解为定位画笔在画布上的位置（注意所有绘图方法所定义的坐标是相对canvas而言的而不是浏览器窗口，对canvas来说，最左上角的点的坐标是(0,0)） .lineTo(x坐标 , y坐标) 顾名思义，就是画一条直线到某个点，很好理解。需要知道的是此方法仅仅做路径运动，而不存在任何视觉上的绘图效果（上色、描边） .stroke() 描边方法，有玩过AfterEffect的朋友会很清楚，不给运动路径加stroke特效的画是不存在描边效果的，canvas也一样，想要运动路径轨迹能有视觉效果，需要使用相应的上色/描边方法 自此我们很轻松地绘制了一条黑色的直线，但如果我们想要绘制一条红色的或者其它颜色的线段，该怎么做呢？ 答案很简单，使用ctx.strokeStyle来设定描边的颜色即可。我们画三条红色的线段吧： 123456789&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:solid 1px #CCC; margin:30px;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt;var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); //获取该canvas的2D绘图环境对象ctx.moveTo(0,0); //咱把“画笔”移到坐标(0,0)ctx.line 注释都说的很清楚了，故不再赘述实现原理，其效果如下： 注意在开始绘制路径的时候，一定要加上moveTo(x,y)，否则第一个lineTo()的运动轨迹将不计入绘图中（浏览器会认为没获取到该运动轨迹的起始点，故忽略此线段）。 另外有一个问题，如果上方我们会出来的两条线段（嗯，一条折线，一条直线），我们希望第一条折线是蓝色的，第二条直线是红色的，应当怎么做？ 你会很自然地做如下处理：1234567891011121314&lt;script&gt; var c = document.getElementById(&quot;myCanvas&quot;); var ctx = c.getContext(&quot;2d&quot;); ctx.moveTo(0,0); ctx.lineTo(150,50); ctx.lineTo(20,100); ctx.strokeStyle = &quot;blue&quot;; //设定描边颜色为蓝色 ctx.stroke(); ctx.moveTo(90,90); ctx.lineTo(80,150); ctx.strokeStyle = &quot;red&quot;; //设定描边颜色为红色 ctx.stroke(); &lt;/script&gt; 但运行脚本会发现，折线除了被描了一遍蓝色，也被描了一遍红色：这是因为canvas在第二次给路径上色时，是把之前的所有路径轨迹合在一起来上色的，除非咱们让canvas知道那折线和直线应该是独立开来的俩路径。 我们可以使用.beginPath()来解决： 123456789101112131415&lt;script&gt; var c = document.getElementById(&quot;myCanvas&quot;); var ctx = c.getContext(&quot;2d&quot;); ctx.moveTo(0,0); ctx.lineTo(150,50); ctx.lineTo(20,100); ctx.strokeStyle = &quot;blue&quot;; //设定描边颜色为蓝色 ctx.stroke(); ctx.beginPath(); //告诉canvas咱们要重新绘制一条全新的路径了，之前画的东西从此再无关系 ctx.moveTo(90,90); ctx.lineTo(80,150); ctx.strokeStyle = &quot;red&quot;; //设定描边颜色为红色 ctx.stroke(); &lt;/script&gt; 有的朋友一开始会搞不清楚beginPath()的用途，觉得有moveTo()就可以了，其实beginPath()可以做到上述的隔离路径绘制效果的作用，防止之前的效果被污染。 接着唠嗑.strokeStyle的赋值方式，咱们上方是直接用了 ctx.strokeStyle=”red” 来定义描边颜色为红色，不过ctx.strokeStyle可获值的形式有三种： ctx.strokeStyle=color|gradient|pattern; //即支持 “颜色/渐变/图案笔刷” 的赋值 先看看color赋值方式，和我们常规的css赋值是一样的，支持css3颜色值标准，如下例：12345//下面四种形式都是一样的，表示描边颜色为“橙色”ctx.strokeStyle = &quot;orange&quot;;ctx.strokeStyle = &quot;#FFA500&quot;; //#rrggbb形式ctx.strokeStyle = &quot;rgb(255,165,0)&quot;; //RGB形式ctx.strokeStyle = &quot;rgba(255,165,0,1)&quot;; //比上面的rgb多了个a（Alpha），即透明度 2 . 再看下渐变gradient，这个稍有复杂： 12345678910111213var c = document.getElementById(&quot;myCanvas&quot;);var ctx = c.getContext(&quot;2d&quot;); ctx.moveTo(0,0); ctx.lineTo(150,50); ctx.lineTo(20,100); var grd = ctx.createLinearGradient(0,0,170,0); //定义线性渐变对象，设定渐变线起始点和结束点坐标，坐标格式为(起始点x,起始点y,结束点x,结束点y)grd.addColorStop(0,&quot;black&quot;); //定义渐变线起点颜色grd.addColorStop(0.5,&quot;red&quot;); //定义渐变线中间点的颜色grd.addColorStop(1,&quot;yellow&quot;); //定义渐变线结束点的颜色ctx.strokeStyle = grd; //将渐变对象赋值给strokeStylectx.stroke(); //描边 效果如下： 这里我们提到了一个概念叫“渐变线”，没有玩过设计的朋友需要了解下渐变的知识点，我们可以把LinearGradient（线性渐变，另有放射状/圆形渐变RadialGradient）范围看成一个矩形（你可以通过Illustator、Photoshop等专业设计软件来辅助你理解这点）：我们一开始定义线性渐变对象的代码 var grd = ctx.createLinearGradient(0,0,170,0) 不外乎就是设定了线性渐变线起始点为(0,0)，结束点为(170,0)。 紧接着我们通过 addColorStop( 渐变线位置, 颜色 ) 来设定了渐变色值，分别在渐变线0、0.5、1的位置设置了黑色、红色、黄色，其渐变效果如下：通过 ctx.strokeStyle = grd 将渐变赋值给描边方法，最终描边得到了我们想要的渐变效果。 3 . 最后看看pattern描边方式，strokeStyle之所以不叫strokeColor是因为它除了支持颜色描边还支持图案描边（搞设计的朋友或许称作笔触描边会更有feel）。 线性渐变描边需要先createLinerGradient(xstart,ystart,xend,yend)，那么设置图案描边自然也要先新建一个canvasPattern对象：1createPattern(image, repetitionStyle) 其中参数 image 代表图案对象，一般通过 document.createElement(‘img’) 或者 new Image() ，再定义其src值来创建该对象。而repetitionStyle参数很好理解，即图案重复形式，其可选值有”repeat” 、”repeat-x”、”repeat-y” 和”no-repeat” （和css的background-repeat可选值一样，不赘述）。 我们这样写1234567891011121314151617&lt;body&gt;&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:solid 1px #CCC; margin:30px;&quot;&gt;您的浏览器不支持canvas，建议使用最新版的Chrome&lt;/canvas&gt;&lt;script&gt; var c = document.getElementById(&quot;myCanvas&quot;); var ctx = c.getContext(&quot;2d&quot;); pic = new Image(); //创建图片对象，或者 pic = document.createElement(&apos;img&apos;) pic.src = &quot;http://images.cnblogs.com/cnblogs_com/vajoy/558870/o_5.jpg&quot;; //定义图片的映射地址 var redTexture = ctx.createPattern(pic, &quot;repeat&quot;); //定义Pattern对象，设定填充图案为pic图片，填充形式为平铺 ctx.strokeStyle = redTexture; //定义描边样式为上一行设定的Pattern描边 ctx.moveTo(80,10); ctx.lineTo(10,90); ctx.stroke();&lt;/script&gt; 效果如下：注意这里我还加了个 ctx.lineWidth = 8 来设定线段的粗度。 自此我们学习了strokeStyle的三个赋值方式，也学习了上述的通过 ctx.lineWidth = lineWeight 的形式来给线段设定粗度。 咱们再学习两个很简单的线段属性 lineCap 和 lineJoin。 ⑴ lineCap是设定线段端点的形状（线帽），其值可以是 butt 默认，即线条端点为平直的边缘round 线条端点为圆角线帽square 为线条端点添加正方形线帽 1234567891011121314151617181920212223242526272829&lt;canvas id=&quot;myCanvas&quot; width=&quot;250&quot; height=&quot;120&quot; style=&quot;border:1px solid #DDD;&quot;&gt;&lt;/canvas&gt;&lt;script&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.lineWidth=10;ctx.beginPath();ctx.lineCap=&quot;butt&quot;;ctx.moveTo(20,10);ctx.lineTo(200,60);ctx.strokeStyle=&quot;red&quot;;ctx.stroke();ctx.beginPath();ctx.lineCap=&quot;round&quot;;ctx.moveTo(30,90);ctx.lineTo(200,40);ctx.strokeStyle=&quot;blue&quot;;ctx.stroke();ctx.beginPath();ctx.lineCap=&quot;square&quot;;ctx.moveTo(10,30);ctx.lineTo(200,80);ctx.strokeStyle=&quot;green&quot;;ctx.stroke();&lt;/script&gt; 效果如下： 光看此图可能看不太出“butt”和”square”的区别，但懂得使用AI绘制矢量的同学们应该比较了解： ⑵ lineJoin则是设定折线的交接处的外角类型，其值可为： miter 默认，折线交接处为尖角round 折线交接处为圆角bevel 折线交接处为斜角 12345678910111213141516171819202122232425262728293031&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;220&quot; style=&quot;border:1px solid #DDD;&quot;&gt;&lt;/canvas&gt;&lt;script&gt;var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.lineWidth=13;ctx.lineJoin=&quot;bevel&quot;;ctx.moveTo(20,20);ctx.lineTo(100,50);ctx.lineTo(20,80);ctx.strokeStyle=&quot;red&quot;;ctx.stroke();ctx.beginPath();ctx.lineJoin=&quot;round&quot;;ctx.moveTo(20,60);ctx.lineTo(100,90);ctx.lineTo(20,150);ctx.strokeStyle=&quot;green&quot;;ctx.stroke();ctx.beginPath();ctx.lineJoin=&quot;miter&quot;;ctx.moveTo(20,90);ctx.lineTo(100,150);ctx.lineTo(20,200);ctx.strokeStyle=&quot;blue&quot;;ctx.stroke();&lt;/script&gt; 效果如下 需要了解的是，miter还受到了属性miterLimit的影响（点此查看详细），但个人觉得它跟bevel实现的效果是一致的，故在此不做介绍。这次就到这里了，下次再见了啦！ 下面推荐一下其他很好的博文HTML5- Canvas入门（一）玩转html5&lt;canvas&gt;画图","tags":[{"name":"html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"项目常用的less语法详解","date":"2016-12-10T09:50:33.000Z","path":"2016/12/10/项目常用的less语法详解/","text":"什么是less？ less是一种动态样式语言，属于css预处理语言的一种，类似于css的语法，为css赋予了动态语言的特性，如变量、继承，运算，函数等，更方便css的编写和维护 编译工具 Koala编译 国人开发的less/sass编译工具、 下载地址： http://koala-app.com/index-zh.html 常用： 输出方式compress(进行压缩) Node.js库 浏览器端使用Koala配置及使用 新建后缀为.less文件：index.less头部写上：@charset “utf-8”; //设定字符集 把文件夹拖到koala中，设置输出路径为style下的index.css使用koala进行编译，然后就生成了一个index.css文件。 之后我们只要编辑index.less文件即可。 项目中常用的语言特性注释 less有两种注释 //*会在css中编译出来/*/ //不会在css中编译出来第一种的注释会在css中编译出来，第二种不会 变量： 变量允许我们单独定义一系列通用的样式，然后在需要的时候去调用。所以在做全局样式调整的时候我们可能只需要修改几行代码就可以了。 less中声明变量用@开头，例：@变量名：值；less源码： 12@margin-left:30px;box&#123;margin: margin-left;&#125; 编译后的css1box&#123;margin:30px;&#125; 混合模式（Mixins） 混合可以将一个定义好的class A轻松的引入到另一个class B中，从而简单实现class B继承class A中的所有属性。我们还可以带参数地调用，就像使用函数一样。 123456789101112131415161718192021222324252627282930313233343536373839404142//混合.box&#123; width: @text_width; height: 100px; background: green; .border;&#125;.border&#123; border:solid 1px pink;&#125;//混合，可带参数.border_02(@border_width)&#123; border:solid yellow @border_width;&#125;.test_mix2&#123; .border_02(30px); //注意：参数不初始化，括号里必须要有个值，&#125;//混合默认带值.border_03(@border_width:10px)&#123; border:solid yellow @border_width;&#125;.test_mix3&#123; .border_03();&#125;//混合好例子（适用多个浏览器）.border_radius(@radius:5px)&#123; -webkit-border-radius:@radius; -moz-border-radius:@radius; border-radius:@radius;&#125;.radius_test&#123; width: 100px; height: 100px; background: pink; .border_radius(30px);&#125; 匹配模式： 有点像switch或者if 判断满足哪个条件就用哪一个。 其他的就是混合。 @_ ： ,这个很强大：无论匹配到什么值，均会运行，类似于成全局了（函数名一致） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465.float(left)&#123; float:left; &#125;//调用匹配模式：那么就是： .setFloat&#123; .float(left); &#125; //举个三角例子//匹配模式(原始)// .tri_test&#123; // width: 0; // height: 0 // overflow: hidden;// border-width: 150px;// border-color: red transparent transparent transparent;// border-style: solid dashed dashed dashed ;//dashed 虚线// &#125;//匹配模式.triangle(top, @w: 5px, @c:#ccc)&#123; //朝上 border-width: @w; border-color: transparent transparent #ccc transparent; border-style: dashed dashed solid dashed ;//dashed 虚线&#125;.triangle(bottom, @w: 5px, @c:#ccc)&#123; //朝下 border-width: @w; border-color: @c transparent transparent transparent; border-style: solid dashed dashed dashed ;//dashed 虚线&#125;.triangle(left, @w: 5px, @c:#ccc)&#123; //朝左 border-width: @w; border-color: transparent @c transparent transparent; border-style: dashed solid dashed dashed ;//dashed 虚线&#125;.triangle(right, @w: 5px, @c:#ccc)&#123; //朝右 border-width: @w; border-color: transparent transparent transparent @c ; border-style: dashed dashed dashed solid ;//dashed 虚线&#125;.triangle(@_, @w: 5px, @c:#ccc)&#123; //@_ 强大：无论匹配到什么值，均会运行这个函数 width: 0; height: 0; overflow: hidden;&#125;.tri_test&#123; .triangle(top, 100px);&#125;//好例子：：匹配：定位.pos(r)&#123; position:relative;&#125;.pos(a)&#123; position:absolute;&#125;.pos(f)&#123; position:fixed;&#125;.match&#123; width: 100px; height: 150px; background-color: green; .pos(r);&#125; 运算 任何数字，颜色或者变量都可以参与运算，运算应该包裹在括号里 例如+ - * / 12345@val:300px;.box&#123; width: @val + 20;/*less没有强制要求必须加单位，只要有一个有单位即可*/ height: (@val - 20) * 5; color: #ccc - 10 ;/*less会把颜色转成 255 的数值，然后进行计算，输出颜色值对应的颜色，工作中很少用到*/ 嵌套规则 &amp; 代表上一层选择器 用处1：123a&#123; &amp;:hover&#123;&#125; &#125;； 用处2：123.content&#123; &amp;_item1&#123; &#125; &#125; //&amp;_item1就相当于。content_item1 1234567891011121314151617181920212223242526272829303132//嵌套例子/*.list&#123;&#125;.list li&#123;&#125;.list a&#123;&#125;.list span&#123;&#125;*/下面所属关系，一层套一层，省去了重复的东西.list&#123; width: 600px; margin:30px auto; padding: 0; list-style: none; li&#123; height: 30px; line-height: 30px; background-color: pink; margin-bottom: 5px; &#125; a&#123; float: left; //&amp; 代表上一层选择器 &amp;:hover&#123; color: red; &#125; &#125; span&#123; float: right; &#125;&#125; &amp; 代表他的上一层选择器 12345678//&amp; 代表他的上一层选择器a&#123; float: left; //&amp; 代表上一层选择器 &amp;:hover&#123; color: red; &#125; &#125; &amp;同样代表他的上一层选择器，起连接作用 123456789101112131415161718//嵌套小例子//HTML&lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;content_item1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;content_item2&quot;&gt;&lt;/div&gt; &lt;/div&gt;//LESS.content&#123; width: 40px; height: 40px; background: #ccc; &amp;_item1&#123; //&amp;_item1就相当于。content_item1 width: 20px; height: 20px; background: pink; &#125;&#125; @arguments变量（用的不是很多）懒人必备 @arguments包含了所有传递进来的参数。 123456789101112 @border（@w：30px，@c：red，@s：solid）&#123; border：@w @c @s&#125;//如果你不想单独处理每一个参数的话就可以像这样写：.border_arg(@w:30px,@c:red,@ww:solid)&#123;border:@arguments;//这个@arguments就相当于@w,@c,@s 包含所有参数&#125;//调用.test_arguments&#123;.border_arg(40px);&#125; 封装 可以把封装的东西放到一个单独的 less里面，只需要在main.less主文件里面 @import 加文件名 xx 可以省略后缀名. 加载css需要 @import(less) “xxx.css”换汤不换药 其中“”前面有一个空格 还是css那一套加载方式，放到哪里就在哪里加载，样式表！123//引入a.less和a.css例子@import &quot;a.less&quot;; //引入其他的less样式表,其中.less可写可不写@import (less) &quot;a.css&quot; //引入css样式表，注意（less）和“a.css”中间有个空格 less 也有作用域1234567.content1&#123;@w:100px;width:@w;&#125;.content2&#123;width:@w;//错误，这个@w引用不了，因为他在.content1中&#125; 欲知更多，请戳less-中文官网可学习视频：less即学即用-慕课","tags":[{"name":"less","slug":"less","permalink":"http://yoursite.com/tags/less/"}]},{"title":"AngularJs指令解密","date":"2016-12-04T09:50:33.000Z","path":"2016/12/04/AngularJs指令解密/","text":"指令定义在《AngularJs权威教程》中，指令可以简单理解成特定的DOM元素上运行的函数；我认为还可以理解成将将自定义的HTML标签解析成原始的标签，然后为其加入一些扩展的功能（函数）.angularjs 提供了一个强大的扩展系统，通过指令机制，我们可以通过自定义指令来扩展自己的指令系统。 在AngularJS的核心里，指令可以绑定元素的属性（例如可见性，class列表，内部文本，内部HTML或者值）到scope的属性或表达式。最值得注意的是，一旦监测到scope中的变化被标记，这些绑定就会被更新。反过来也是相似的，使用$observe函数能够监测DOM属性，当监测到属性变化时会触发一个回调。 AngularJS应用的模块中有很多方法可以使用，其中directive()这个方法是用来定义指令的：不急，首先要注意下指令的名字，先看个简单例子：12345678angular .module(&apos;myApp&apos;, []) .directive(&apos;myDirective&apos;, myDirective);myDirective.$inject = [&apos;$timeout&apos;, &apos;UserDefinedService&apos;]function myDirective($timeout, UserDefinedService) &#123; // 指令定义放在这里&#125; 尽管在上面的的代码片段中我们定义了一个命名为myDirective的指令,AngularJS约定在 HTML 标记里使用破折号的形式连接名字。如果这个指令作为一个属性实现，那么我在 HTML 中就会像这样调用：&lt;span my-directive&gt;&lt;/span&gt; 还有：directive()方法可以接受两个参数： name(字符串)指令的名字，用来在视力中引用特定的指令。 factory_function(函数)这个函数返回一个对象，其中定义了指令的全部行为。$compile服务利用这个方法返回的对象，在DOM调用指令时来构造指令的行为。 注意：为了避免与未来的HTML标准冲突，给自定义的指令加入前缀来代表自定义的命名空间。AngularJS本身已经使用了ng-前缀，所以可以选择除此以外的名字。在例子中我们使用my-前缀（比如my-derictive）。 当AngularJS在DOM中遇到具名的指令时，会去匹配已经注册过的指令，并通过名字在注册过的对象中查找。此时，就开始了一个指令的生命周期，指令的生命周期开始于\\$compile方法并结束于link方法 下面，来看看定义一个指令时可以使用的全部设置选项。可能的选项如下所示，每个键的值说明了可以将这个属性设置为何种类型或者什么样的函数：12345678910111213141516171819202122232425262728293031angular .module(&apos;myApp&apos;, []) .directive(&apos;myDirective&apos;, myDirective);function myDirective() &#123; return: &#123; restrict: String, // priority: Number, terminal: Boolean, template: String or Template Function: function(tElement, tAttrs) &#123;...&#125;, templateUrl: String, replace: Boolean or String, scope: Boolean or Object, transclude: Boolean, controller: String or function(scope, element, attrs, transclude, otherInjectables) &#123;...&#125;, controllerAs: String, require: String, link: function(scope, iElement, iAttrs) &#123;...&#125;, compile: // 返回一个对象或连接函数，如下所示: function(tElement, tAttrs, transclude) &#123; return &#123; pre: function(scope, iElement, iAttrs， controller) &#123;...&#125;, post: function(scope, iElement, iAttrs, controller) &#123;...&#125; &#125; // 或者 return function postLink(...) &#123;...&#125; &#125; &#125;&#125; 下面我们来详细说说每种设置 restrict(字符串string)restrict是一个可选的参数。它告诉AngularJS这个指令在DOM中可以何种形式被声明。默认AngularJS认为restrict的值是A，即以属性的形式来进行声明。可选值如下：E(元素)： &lt;my-directive&gt;&lt;/my-directive&gt; A(属性，默认值)：&lt;div my-directive=&quot;expression&quot;&gt;&lt;/div&gt; C(类名)：&lt;div class=&quot;my-directive:expression;&quot;&gt;&lt;/div&gt;M(注释)：&lt;!-- directive:my-directive expression --&gt;AE : 可以结合上面的任意值来放松限制。 千万别用 ‘C’ 或者 ‘M’ 来限制你的指令。 用 ‘C’ 不能使之在标记中凸显出来， 用 ‘M’ 是为了向后兼容。 如果你觉得有趣， 你可以用一个例子来设置 restrict 为 ‘ACME’。这些选项可以单独使用，也可以混合在一起使用。 属性是用来声明指令最常用的方式，因为它能在包括老版本的IE浏览器在内的所有浏览器中正常工作，并且不需要在文档头部注册新的标签。 包含某个组件的核心行为时使用元素型。用额外的行为、状态或者其他内容进行修饰或扩展时使用属性型优先级(数值型Number) 优先级参数可以被设置为一个数值。大多数指令会忽略这个参数，使用默认值0，但也有些场景设置高优先级是非常重要甚至是必须的。例如，ngRepeat将这个参数设置为1000，这样就可以保证在同一元素上，它总是在其他指令之前被调用。 如果一个元素上具有两个优先级相同的指令，声明在前面的那个会被优先调用。如果其中一个的优先级更高，则不管声明的顺序如何都会被优先调用：具有更高优先级的指令总是优先运行。 terminal(布尔型Boolean) terminal是一个布尔型参数，可以被设置为true或false。这个参数用来告诉AngularJS停止运行当前元素上比本指令优先级低的指令。但同当前指令优先级相同的指令还是会被执行。如果元素上某个指令设置了terminal参数并具有较高的优先级，就不要再用其他低优先级的指令对其进行修饰了，因为不会被调用。但是具有相同优先级的指令还是会被继续调用。 template(字符串string或函数Function)template参数是可选的，必须被设置为以下两种形式之一： 一段HTML文本;一个可以接受两个参数的函数，参数为tElement和tAttrs，并返回一个代表模板的字符串。tElement和tAttrs中的t代表template，是相对于instance的。在讨论链接和编译设置时会详细介绍，模板元素或属性与实例元素或属性之间的区别。 在实际生产中，更好的选择是使用templateUrl参数引用外部模板，因为多行文本阅读和维护起来都是一场噩梦。 templateUrl（字符串String | 函数Function）可选的参数，可以是以下类型： 一个代表外部HTML文件路径的字符串 一个可以接受两个参数的函数，参数为tElement和tAttrs，并返回一个外部HTML文件路径的字符串 模板的URL都将通过AngularJS内置的安全层， 特别是\\$getTrustedResourceUrl，这样可以保护模板不会被不信任的源加载 调用指令时会在后台通过Ajax来请求HTML模板文件，也就是说： * 需要防止CORS错误 * 编译和链接要暂停，等待模板加载完成 模板加载后，AngularJS会将它默认缓存到$templateCache服务中，，可以提前将模板缓存到一个定义模板的JavaScript文件中，这样就不需要通过XHR来加载模板了 replace(布尔型Boolean)replace是一个可选参数，如果设置了这个参数，值必须为true，因为默认值为false。默认值意味着模板会被当作子元素插入到调用此指令的元素内部：123456&lt;div some-directive&gt;&lt;/div&gt;.directive(&apos;someDirective&apos;, function() &#123; return &#123; template: &apos;&lt;div&gt;some stuff here&lt;/div&gt;&apos; &#125;&#125;) 调用指令之后的结果如下(这是默认replace为false时的情况)：123&lt;div some-directive&gt; &lt;div&gt;some stuff here&lt;/div&gt;&lt;/div&gt; 如果replace被设置为了true：123456.directive(&apos;someDirective&apos;, function() &#123; return &#123; replace: true, // 修饰过 template: &apos;&lt;div&gt;some stuff here&lt;/div&gt;&apos; &#125;&#125;) 指令调用后的结果将是：1&lt;div&gt;some stuff here&lt;/div&gt; scope（布尔值Boolean | 对象Object）scope参数是可选的，默认为false： false：直接调用相同的作用域对象； true：从当前作用域对象继承一个新的作用域对象； 对象：创建一个同当前作用域相隔离的作用域对象。 ####独立作用域 scope属性值设置为true，作用是让自定义的每一个指令拥有独立的作用域，而不是共享一个作用域。 隔离作用域 通常情况下，当我们需要创建可复用的组建时，我们需要的就是具有隔离作用域的指令。它不依赖于上下文或者说是父级的作用域，所以可以随意迁移，不需要考虑依赖数据的问题。 隔离作用域实现起来很简单，只要将自定义指令返回对象中“scope”值写成“{}”就行。 1234567891011121314151617181920//隔离作用域app.directive(&apos;helloWorld&apos;, function() &#123; return &#123; scope: &#123;&#125;,//隔离作用域 restrict: &apos;AE&apos;, replace: true, template: &apos;&lt;p style=&quot;background-color:&#123;&#123;color&#125;&#125;&quot;&gt;Hello World&lt;/p&gt;&apos;, link: function(scope, elem, attrs) &#123; elem.bind(&apos;click&apos;, function() &#123; elem.css(&apos;background-color&apos;,&apos;white&apos;); scope.$apply(function() &#123; scope.color = &quot;white&quot;; &#125;); &#125;); elem.bind(&apos;mouseover&apos;, function() &#123; elem.css(&apos;cursor&apos;, &apos;pointer&apos;); &#125;); &#125; &#125;;&#125;); 使用隔离作用域时，可以将指令内部的隔离作用 域，同指令外部的作用域进行数据绑定： * 本地作用域属性：使用@符号将本地作用域同DOM属性的值进行绑定 * 双向绑定：通过=可以将本地作用域上的属性同父级作用域上的属性进行双向的数据绑定 * 父级作用域绑定：通过&amp;符号可以对父级作用域进行绑定，以便在其中运行函数 transclude（布尔值Boolean）可选，默认为false 可以将整个模板，包括其中的指令通过嵌入全部传入一个指令中。这样做可以将任意内容和作用域传递给指令。transclude参数就是用来实现这个目的的，指令的内部可以访问外部指令的作用域，并且模板也可以访问外部的作用域对象 只有当你希望创建一个可以包含任意内容的指令时，才使用transclude: true controller（字符串String | 函数Function）可选： * 字符串：以字符串的值为名字，查找注册在应用中的控制器的构造函数 * 函数：直接定义内联的控制器 可以向控制器中注入如下服务： \\$scope: 与指令元素相关联的当前作用域 \\$element: 当前指令对应的元素 \\$attrs: 由当前元素的属性组成的对象 \\$transclude: 嵌入链接函数会与对应的嵌入作用域进行预绑定。transclude链接函数是实际被执行用来克隆元素和操作DOM的函数。controllerAs （字符串String） 用来设置控制器的别名，可以以此为名来发布控制器，并且作用域可以访问controllerAs。这样就可以在视图中引用控制器，甚至无需注入$scope。 require（字符串String | 数组Array）字符串或数组元素的值是会在当前指令的作用域中使用的指令名称。require会将控制器注入到其值所指定的指令中，并作为当前指令的链接函数的第四个参数。 默认情况下，指令只会在自身的元素上查找控制器。可以用下面的前缀进行修饰，改变查找控制器时的行为： ?: 如果在当前指令中没有找到所需要的控制器，会将null作为传给link函数的第四个参数 ^: 如果添加了^前缀，指令会在上游的指令链中查找require参数所指定的控制器 ?^: 将前面两个选项的行为组合起来，可选择地加载需要的指令并在父指令链中进行查找 没有前缀: ，指令将会在自身所提供的控制器中进行查找，如果没有找到任何控制器（或具有指定名字的指令）就抛出一个错误 compile（对象Object | 函数Function）在compile函数内部，只对DOM进行操作，返回函数等效于使用link配置，返回对象的话包含两个函数： preLink会在编译阶段之后、指令连接到子元素之前运行 postLink会在所有子元素指令都链接之后才运行1234567compile: function(tElement, tAttrs, transclude) &#123; // 一些DOM操作 return &#123; pre: function preLink(scope, iElement, iAttrs, controller) &#123;&#125;, post: function postLink(scope, iElement, iAttrs, controller) &#123;&#125; &#125;;&#125; link（函数Function）link函数会访问scope对象，其返回一个postLink函数。如果在compile中返回了post，那么link选项就会被忽略 link: function postLink(scope, iElement, iAttrs){} compile和linkcompile和link有许多异同： compile函数只会被调用一次，而link函数的调用次数可能会很多。compile用于对模板自身的转换，而link负责模型和视图之间进行动态关联link函数能够访问scope作用域对象，而compile不会，因为在编译阶段，scope对象还不存在。link和compile都会接收指令声明的DOM元素以及属性列表compile可以返回preLink和postLink函数，而link只能返回postLink函数 AngularJS的生命周期 AngularJS应用启动后会进行编译和链接，作用域会同HTML进行绑定，应用可以对用户在HTML中进行的操作进行实时响应。 编译三个阶段 首先浏览器会用它的标准API将HTML解析成DOM。模板必须是可被解析的HTML。这是AngularJS和那些“以字符串为基础而非以DOM元素为基础的”模板系统的区别之处。 DOM的编译是有\\$compile方法来执行的。这个方法会遍历DOM并找到匹配的指令。一旦找到一个，它就会被加入一个指令列表中，这个列表是用来记录所有和当前DOM相关的指令的。 一旦所有的指令都被确定了，会按照优先级被排序，并且他们的compile方法会被调用。指令的\\$compile()函数能修改DOM结构，并且要负责生成一个link函数（后面会提到）。\\$compile方法最后返回一个合并起来的链接函数，这是链接函数是每一个指令的compile函数返回的链接函数的集合。 通过调用一步所说的链接函数来将模板与作用域链接起来。这会轮流调用每一个指令的链接函数，让每一个指令都能对DOM注册监听事件，和建立对作用域的的监听。这样最后就形成了作用域的DOM的动态绑定。任何一个作用域的改变都会在DOM上体现出来。大致过程如下：12345678910111213var $compile = ...; // injected into your codevar scope = ...;var html = &apos;&lt;div ng-bind=&apos;exp&apos;&gt;&lt;/div&gt;&apos;;// Step 1: parse HTML into DOM elementvar template = angular.element(html);// Step 2: compile the templatevar linkFn = $compile(template);// Step 3: link the compiled template with the scope.linkFn(scope); 模板之中可能含有指令，指令之中可能又含有模板，模板之中又含有指令，由此形成一棵模板树。只有具有最高优先级的指令中的模板会被编译。如果一个元素已经有一个含有模板的指令了，永远不要对其用另一个指令进行修饰。一个指令会将内部子指令的模板合并在一起成为一个模板函数并返回，它无法查找父指令，只能通过模板函数访问内部子指令 ngModelngModel提供更底层的API来处理控制器内的数据。 为了设置作用域中的视图值，需要调用ngModel.\\$setViewValue()函数，接受一个字符串参数value，表示想要赋予的实际值，然后：ngModel.\\$setViewValue()方法会更新控制器本地的\\$viewValue，然后将值传递给每一个\\$parser函数值被解析且\\$parser所有函数都完成后，值会赋给\\$modeValue属性，并且传递给指令中ng-model属性提供的表达式所有步骤都完成后，\\$viewChangeListeners中所有的监听器都会被调用 单独调用\\$setViewValue()不会唤起一个新的digest循环，因此如果想更新指令，需要在设置\\$viewValue后手动触发digestngModel的\\$render方法可以定义视图具体的渲染方式，它在$parser完成后被调用 ngModelController中有几个属性可用来检查甚至修改视图： \\$viewValue： 保存着更新视图所需的实际字符串。 \\$modelValue：由数据模型持有。\\$modelValue和\\$viewValue可能是不同的，取决于\\$parser流水线是否对其进行了操作。 \\$parsers：\\$parsers的值是一个由函数组成的数组，其中的函数会以流水线的形式被逐一调用。ngModel从DOM中读取的值会被传入\\$parsers中的函数，并依次被其中的解析器处理。 \\$formatters：\\$formatters的值是一个由函数组成的数组，其中的函数会以流水线的形式在数据模型的值 发生变化时被逐一调用。它和\\$parser流水线互不影响，用来对值进行格式化和转换，以便在绑定了这个值的控件中显示。 \\$viewChangeListeners：\\$viewChangeListeners的值是一个由函数组成的数组，其中的函数会以流水线的形式在视图中的值发生变化时被逐一调用。通过\\$viewChangeListeners，可以在无需使用\\$watch的情况下实现类似的行为。由于返回值会被忽略，因此这些函数不需要返回值。 友情链接AngularJs权威教程很好玩的博客–AngularJs指令详解AngularJS - 指令详解天镶的读书笔记","tags":[{"name":"AngularJs","slug":"AngularJs","permalink":"http://yoursite.com/tags/AngularJs/"}]},{"title":"AngularJS浅谈-博客","date":"2016-11-28T09:50:33.000Z","path":"2016/11/28/AngularJs浅谈/","text":"AngularJS是啥？（一脸懵逼）简介： AngularJS诞生于2009年，由Misko Hevery 等人创建，后为Google所收购。是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVC、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。 具体点说： AngularJS 是一个 JavaScript 框架 AngularJS 是以一个 JavaScript 文件形式发布的，可通过 script 标签添加到网页中：&lt;script src=&quot;../libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; AngularJS 扩展了 HTML AngularJS 通过 ng-directives 扩展了 HTML。ng-app 指令定义一个 AngularJS 应用程序。ng-model 指令把元素值（比如输入域的值）绑定到应用程序。ng-bind 指令把应用程序数据绑定到 HTML 视图。ng-init 指令初始化 AngularJS 应用程序变量 那么，重点来了，AngularJs可以干啥啊？AngularJS 使得开发现代的单一页面应用程序（SPAs：Single Page Applications）变得更加容易。 AngularJS 把应用程序数据绑定到 HTML 元素。AngularJS 可以克隆和重复 HTML 元素。AngularJS 可以隐藏和显示 HTML 元素。AngularJS 可以在 HTML 元素”背后”添加代码。AngularJS 支持输入验证。 举个荔枝（例子）吧！12345678910111213141516171819202122232425262728293031&lt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;例子&lt;/title&gt; &lt;script src=&quot;angular-1.0.1.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt; 名：&lt;input type=&quot;text&quot; ng-model=&quot;lastName&quot;&gt;&lt;br&gt; 姓：&lt;input type=&quot;text&quot; ng-model=&quot;firstName&quot;&gt;&lt;br&gt; &lt;br&gt; 姓名：&#123;&#123;firstName+&quot; &quot;+ lastName&#125;&#125; &lt;br&gt; 姓名：&#123;&#123;fullName()&#125;&#125;&lt;/div&gt;&lt;script&gt; var app=angular.module(&apos;myApp&apos;,[]); app.controller(&apos;myCtrl&apos;,function($scope)&#123; $scope.firstName=&quot;重庆&quot;; $scope.lastName=&quot;黄&quot;; $scope.fullName = function() &#123; return $scope.firstName + &quot; &quot; + $scope.lastName; &#125; &#125;);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 初始化加载流程 统一过程： 1、浏览器载入HTML，然后把它解析成DOM。2、浏览器载入angular.js脚本。3、AngularJS等到DOMContentLoaded事件触发。4、AngularJS寻找ng-app指令，这个指令指示了应用的边界。5、使用ng-app中指定的模块来配置注入器(\\$injector)。6、注入器($injector)是用来创建“编译服务(\\$compile service)”和“根作用域(\\$rootScope)”的。7、编译服务(\\$compile service)是用来编译DOM并把它链接到根作用域(\\$rootScope)的。 具体过程： AngularJS 应用程序由 ng-app 定义。应用程序在 内运行。ng-controller=”myCtrl” \b属性是一个 AngularJS 指令。用于定义一个控制器。myCtrl 函数是一个 JavaScript 函数。AngularJS 使用$scope 对象来调用控制器。在 AngularJS 中， $scope 是一个应用象(属于应用变量和函数)。控制器的 $scope （相当于作用域、控制范围）用来保存AngularJS Model(模型)的对象。控制器在作用域中创建了两个属性 (firstName 和 lastName)。ng-model 指令绑定输入域到控制器的属性（firstName 和 lastName）。 记住一点：在大型的应用程序中，通常是把控制器存储在外部文件中。只需要把 &lt;script&gt; 标签中的代码复制到名为 js文件.js 的外部文件中即可，然后在script中引用js文件： 接下来说一下AngularJs中核心的集中特性吧！！ 先来个图！ MVC模块化自动化双向数据绑定 MVC（Model模型 View视图 Controller控制器） 首先要知道为什么要MVC？ AngularJs程序分为3部分：模板，表现层逻辑，数据（model）。 模板：我们用html，css写的ui视图代码，其中包含AngularJs的指令，表达式，并最终会被AngularJs编译机制编译为附加在dom树上。AngularJs的指令（directive）可以由我们自由扩展。 表现层逻辑：包括应用程序逻辑和行为。用javascript定义作为视图控制器逻辑。在AngularJs作为MVC框架，在控制器中我们无需添加对于dom级的事件监听，这些在AngularJs中已经内置了。在ui节点dom事件发生后AngularJs会自动转到scope上的某个行为（Action）逻辑。 数据：视图对象（viewobject）需要被AngularJs Scope（1.0中作为service出现）引用，可以使任何类型的javascript对象，数组，基本类型，对象。并且AngularJs会自动异步更新模型，即在ui发生改变的时他会自动刷新模型（mode），反之在模型发生改变的时候也会自动刷新ui。在这里我们不需要定义形如getter，setter的一些列方法。 MVC之间的关系，下面这张图看一下MVC中都包含些什么东西 再看下面这张图-其中service是共用的的东西抽象出来的服务 模块化 AngularJs的模块（module):它是一个集合，相当于一个框子，由模型，视图，过滤器，服务等等组成 我们都知道JavaScript很容易就写出全局函数，所以无论是用jQuery还是纯JavaScript，我们都会使用模块化的策略避免写出来的函数污染全局。 1234567891011121314HTML代码:&lt;!doctype html&gt;&lt;html ng-app=&quot;HelloAngular&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller=&quot;helloNgCtrl&quot;&gt; &lt;p&gt;&#123;&#123;greeting.text&#125;&#125;,Angular&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;js/angular-1.3.0.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;NgModule1.js&quot;&gt;&lt;/script&gt;&lt;/html&gt; 123456789101112//JS代码1:var modelName = angular.module(&apos;modelName&apos;,[]);modelName .controller(&apos;contollerName&apos;,[&apos;$scope&apos;,function($scope)&#123; $scope.greeting = &#123;$scope.greeting=&#123;text:&apos;hello&apos;&#125;;&#125;&#125;]);//JS代码2function HelloAngular($scope)&#123; $scope.greeting=&#123; text:&apos;hello&apos; &#125;;&#125; 很明显JS1代码函数污染了全局，而Js2代码通过一个模块进行封装，从而避免污染了全局。 在前面我们看到ng-app指令。它的作用是自动启动一个AngularJS应用，ng-app指令一般指派在应用的根元素上，比如，body或者html标签。在每一个HTML文档中，只能有一个AngularJS应用可以被自动启动，在HTML文档中第一个被找到定义在根元素上的ng-app指令将会作为自动启动的应用。那我们在js代码中定义的模块和ng-app有什么关系呢？很明显，它是告诉AngularJS应用在启动时加载指定的模块，假设这里ng-app只是放一个纯标签，而不给它赋值。那么它就不知道这里该加载什么模块，于是，它也不认识在模块中定义的textController控制器。 但是，赋值与否和启动一个AngularJS的应用无关：12345&lt;body ng-app&gt; &lt;div ng-controller=&quot;helloNgCtrl&quot;&gt; &lt;p&gt;&#123;&#123;greeting.text&#125;&#125;,Angular&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; 这样也是可以启动AngularJS应用，并实现name模型的绑定。 看一下ng官方的模块切分方式 最后看一下模块化的完整项目结构，有利于大家对项目的整体认知 双向数据绑定 先来个官方例子：123456789101112131415161718&lt;!doctype html&gt; 2 &lt;html ng-app&gt; 3 4 &lt;head&gt; 5 6 &lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&gt;&lt;/script&gt; 7 8 &lt;/head&gt; 9 10 &lt;body&gt;11 12 Your name: &lt;input type=&quot;text&quot; ng-model=&quot;yourname&quot; placeholder=&quot;World&quot;&gt;//一个输入框，默认内容为World13 14 &lt;hr&gt;15 16 Hello &#123;&#123;yourname || &apos;World&apos;&#125;&#125;!18 &lt;/body&gt;20 &lt;/html&gt; 注:在输入框中输入任何字符都会立即绑定更新到页面. 这里采用ng-model指令（directive）绑定是模型scope属性yourname。并采用表达式将yourname绑定到文本信息中。这里只需要任何的dom时间监听，因为AngularJs内置了。 友情链接：MVC框架-破浪博客AngularJs实战视频AngularJs中文铁锚的CSDN博客模块化","tags":[{"name":"AngularJs","slug":"AngularJs","permalink":"http://yoursite.com/tags/AngularJs/"}]},{"title":"JS-我待this如初见","date":"2016-08-18T09:50:33.000Z","path":"2016/08/18/JS-我待this如初见/","text":"何为this？this是对象，是在运行时基于函数的执行环境(和对象有关)绑定的，首先，当代码没执行前，或没执行到之前，this 是没有指向的,所以切记：在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了。因为this的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。this只要一出现，一定牵扯到函数和对象一般方法：首先分析this所在的函数是被当做哪个对象的方法调用的，则该对象就是this所引用的对象。 其实，this的取值，分五种情况。我们来挨个看一下。 全局和调用普通函数 构造函数 函数作为对象的一个属性 函数用call或apply或bind 事件监听函数中的this 情况1：全局 &amp; 调用普通函数在全局环境下，this永远是window，这个应该没有非议。123console.log(this==window);//turethis.a=20;console.log(window.a); 普通函数在调用时，其中的this也都是window。 1234567var home=&quot;中国&quot;;var person=function()&#123; var home=&quot;河南&quot; console.log(this); //window console.log(this.home); //中国 &#125;person(); 但是严格模式下 this是undefined(竞然)：12345678910function person1()&#123; return this; &#125;person1()===window; //truefunction person2()&#123; &quot;use strict&quot; //严格模式 return this;&#125;person2()===undefined; //true 情况2：构造函数所谓构造函数就是用来new对象的函数。其实严格来说，所有的函数都可以new一个对象，但是有些函数的定义是为了new一个对象，而有些函数则不是。另外注意，构造函数的函数名第一个字母大写（规则约定）。例如：Object、Array、Function等。 如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象 1234567891011121314window.home=&quot;中国&quot;;window.age=&quot;5000+&quot;;function Person()&#123; this.home=&quot;河南&quot;; this.age=20; console.log(this); //Person &#123;home: &quot;河南&quot;, age: 20&#125; console.log(this.home);// 河南&#125;var chongqing = new Person();console.log(chongqing.home); //河南还是中国console.log(chongqing.age); //20还是5000+console.log(age); //5000+还是20 以上代码中，如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象,即上文中的chongqing。 上个例子中构造函数没有返回值，默认返回this，但是若有返回语句，返回一个对象的话，会将return的对象作为返回值12345678910111213function Myclass()&#123; this.a=20;&#125;var o=new Myclass();console.log(o.a); //20function Person()&#123; this.a=20; return &#123; a: 21&#125;;&#125;var o=new Person();console.log(o.a); //21还是20 注意，以上仅限new Person()的情况，即Person函数作为构造函数的情况。如果直接调用Person函数，而不是new Person()，情况就大不一样了。相当于普通函数1234567891011window.home=&quot;中国&quot;;window.age=&quot;5000+&quot;;function Person()&#123; this.home=&quot;河南&quot;; this.age=20; console.log(this); //window 还是Person &#123;home: &quot;河南&quot;, age: 20&#125; console.log(this.home);//???河南还是中国 console.log(home);//???河南还是中国&#125;Person(); 这种情况下this是window，就是相当于普通函数中的this 构造函数还有一种情况，在构造函数的prototype中，this代表着什么？在整个原型链中，this代表的是当前对象的值1234567891011121314window.home=&quot;中国&quot;;window.age=&quot;5000+&quot;;function Person()&#123; this.home=&quot;河南&quot;; this.age=20; console.log(this); //Person &#123;home: &quot;河南&quot;, age: 20&#125;&#125;Person.prototype.getHome=function()&#123; console.log(this.home); //河南&#125;var chongqing= new Person();chongqing.getHome();// 如上代码，在Person.prototype.getHome函数中，this指向的是chongqing对象。因此可以通过this.name获取chongqing.name的值。 其实，不仅仅是构造函数的prototype，即便是在整个原型链中，this代表的也都是当前对象的值。 情况3：函数作为对象的一个方法在这又分两种情况： 函数作为对象的方法被调用,此时函数中的this指向该对象 函数被赋值到了另一个变量中，this的值是window ###1. 如果函数作为对象的一个方法时，并且作为对象的一个方法被调用时，函数中的this指向该对象。1234567891011window.home=&quot;中国&quot;;window.age=&quot;5000+&quot;;var obj=&#123; home:&quot;河南&quot;, person: function()&#123; console.log(this); //Object &#123;home: &quot;河南&quot;&#125; console.log(this.home); //河南 &#125;&#125;;obj.person(); 以上代码中，person不仅作为一个对象的一个方法，而且的确是作为对象的一个方法被调用。结果this就是obj对象。 注意，如果person函数不作为obj的一个方法被调用，会是什么结果呢？ 2. 如果person函数被赋值到了另一个变量中，并没有作为obj的一个方法被调用，那么this的值就是window1234567891011window.home=&quot;中国&quot;;window.age=&quot;5000+&quot;;var obj=&#123; home:&quot;河南&quot;, person: function()&#123; console.log(this); //？？window还是object console.log(this.home); //？？中国还是河南 &#125;&#125;;var person1=obj.person;person1(); 如上代码，如果person函数被赋值到了另一个变量中，并没有作为obj的一个属性被调用，那么this的值就是window,相当于全局了，this.home的值为中国 3.闭包中使用this对象（对象方法函数中又有一个匿名函数）-this用处（诡异） 在ES3中，此时使用this比较糟糕，因为this失去了方向，引用的是window对象，而不是定义函数所在的对象,欣慰的是，this在ES5中是固定的，我们应该清楚地了解这种情况注意： 在ES3中，当函数作为某个对象的方法调用时，this等于那个对象，不过在闭包中，匿名函数的执行环境具有全局性，此时通常this指向window1234567891011var obj=&#123; home:&quot;河南&quot;, person: function()&#123; function person1()&#123; console.log(this); //window console.log(this.home); //undefined &#125; person1();&#125;&#125;;obj.person(); 总结：当this值的宿主环境被封装在另一个函数内部或在另一个函数的上下文被调用时，this将永远是对window对象的引用（再次说明，this在ES5中是固定的） 如何改变上述情况呢？可以在父函数中使用作用域链来保留对this的引用，以使this值不丢失。如下代码演示了如何使用that变量及其作用域来有效跟踪函数上下文12345678910111213var obj=&#123; home:&quot;河南&quot;, person: function()&#123; var that=this; //person作用域中，保存this引用对象obj（而不是window） function person1()&#123; //输出通过作用域得到河南，因为that=this console.log(that); //Object &#123;home: &quot;河南&quot;&#125; console.log(that.home); //河南 &#125; person1();&#125;&#125;;obj.person(); 情况4：函数用call或者apply或bind调用 先简单说一下call和apply和bind如何使用 call(),apply() 关于call和apply，首先这两个方法的用途都是在特定的作用域中调用函数，，都有两个参数call/apply(作用域，传递给函数的参数) 它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数。 apply的用法和call大致相同，只有一点区别，apply只接受两个参数，第一个参数和call相同，第二个参数必须是一个数组，数组中的元素对应的就是函数的形参。注意不同的是接受参数的方式不同，call()传递给函数的参数必须逐个列举出来，而apply()则是参数数组 bind() bind（）创造一个函数的实例，其this值会被绑定到传给bind（）函数的值。 牢记：当一个函数被call或apply或bind调用时，this的值就取传入的对象的值,即call（）或apply或bind（）括号里的对象。 call实例12345678910window.home=&quot;中国&quot;;window.age=&quot;5000+&quot;;var obj=&#123; home:&quot;河南&quot;&#125;;var person=function()&#123; console.log(this); //Object &#123;home: &quot;河南&quot;&#125; console.log(this.home); //河南 &#125;person.call(obj); 还要注意：apply()的参数为空时，默认调用全局对象。 123456789 var x = 0; function test()&#123; alert(this.x); &#125; var o=&#123;&#125;; o.x = 1; o.m = test; o.m.apply(); //0 bind()实例12345678window.color=&quot;red&quot;;var o=&#123;color:&quot;blue&quot;&#125;;function sayColor()&#123; alert(this.color);&#125;var objectSayColor=sayColor.bind(o);objectSayColor(); //blue还是red sayColor()调用bind（）并传入对象o。创建了objectSaycolor（）函数，objectSaycolor（）函数中的this的值等于o，因此，即使是在全局作用域中调用这个函数也会看到“blue”。 情况5：事件监听函数中的this(大家应该熟悉)12345var one = document.getElementByIdx( &apos;one&apos; );one.onclick = function()&#123; alert( this.innerHTML ); //this指向的是one元素， 友情链接：Javascript高级程序设计（第3版）-关于this对象-182页JavaScript启示录-this部分博客-深入理解Js-this博客-js中this慕课网Javascript深入浅出-this部分博客-this关键字详解 Ending（欲知后事如何，且听下回分解）","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Hello World","date":"2016-06-06T08:05:40.000Z","path":"2016/06/06/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}]}]